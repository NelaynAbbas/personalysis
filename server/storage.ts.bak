import { 
  User, 
  users, 
  companies,
  surveys,
  surveyResponses,
  PersonalityTrait,
  collaborationSessions,
  collaborationParticipants,
  collaborationChanges,
  collaborationComments,
  CollaborationSession,
  CollaborationParticipant,
  CollaborationChange,
  CollaborationComment
} from '../shared/schema';
import { db } from './db';
import { eq, and, desc } from 'drizzle-orm';
import { sql } from 'drizzle-orm/sql';

// Type definitions for business intelligence data models
export interface CompetitorAnalysis {
  name: string;
  marketShare: number;
  strengthScore: number;
  weaknessScore: number;
  overallThreatLevel: number;
  primaryCompetitiveAdvantage: string;
  keyWeakness: string;
  customerSentiment: number;
  pricingPosition: string;
  productFeatureComparison: {
    [feature: string]: {
      competitor: number;
      our: number;
    };
  };
}

export interface MarketFitAnalysis {
  productId: string;
  overallFitScore: number;
  problemSolutionFit: number;
  productMarketFit: number;
  targetMarketSize: {
    total: number;
    addressable: number;
    serviceable: number;
  };
  customerNeedAlignment: number;
  valuePropositionClarity: number;
  priceToValuePerception: number;
  productDifferentiation: number;
  competitiveAdvantage: string[];
  marketChallenges: string[];
  customerPainPoints: {
    painPoint: string;
    severity: number;
    frequency: number;
    addressedByProduct: number;
  }[];
  recommendations: string[];
}

export interface CustomerSegment {
  name: string;
  size: number;
  percentageOfCustomers: number;
  growthRate: number;
  dominantTraits: PersonalityTrait[];
  keyDemographics: {
    ageGroups: Record<string, number>;
    genderDistribution: Record<string, number>;
    incomeRange: Record<string, number>;
    education: Record<string, number>;
    location: Record<string, number>;
  };
  purchasingBehaviors: string[];
  productPreferences: string[];
  communicationChannels: Record<string, number>;
  customerLifetimeValue: number;
  acquisitionCost: number;
  targetFit: number;
}

export interface ProductFeaturePriority {
  featureName: string;
  importance: number;
  currentSatisfaction: number;
  developmentCost: number;
  timeToImplement: string;
  impactOnSales: number;
  competitiveNecessity: number;
  customerSegmentRelevance: Record<string, number>;
  technicalFeasibility: number;
  strategicAlignment: number;
  overallPriority: number;
}

export interface PricingStrategy {
  strategyName: string;
  appropriateness: number;
  potentialRevenue: number;
  customerAcceptance: number;
  competitiveSustainability: number;
  implementationComplexity: number;
  profitMargin: number;
  marketPenetration: number;
  customerSegmentImpact: Record<string, number>;
  overallScore: number;
  pricingStructure: {
    base: number;
    tiers: Array<{
      name: string;
      price: number;
      features: string[];
    }>;
  };
}

export interface MarketingStrategy {
  strategyName: string;
  effectiveness: number;
  costEfficiency: number;
  implementationTimeline: string;
  revenueImpact: number;
  brandAlignment: number;
  customerReach: number;
  competitiveAdvantage: number;
  channelBreakdown: Record<string, number>;
  messagingThemes: string[];
  targetedPersonas: string[];
  overallScore: number;
}

export interface RevenueForecasting {
  scenario: string;
  probabilityOfOccurrence: number;
  timeframe: string;
  projectedRevenue: number;
  growthRate: number;
  marketShareProjection: number;
  customerAdoption: number;
  contributingFactors: string[];
  riskFactors: string[];
  confidenceLevel: number;
  monthlyBreakdown: Record<string, number>;
}

export interface SimulatedFocusGroup {
  productConcept: string;
  participants: Array<{
    id: string;
    traits: PersonalityTrait[];
    demographics: Record<string, any>;
  }>;
  overallSentiment: number;
  keyThemes: Record<string, number>;
  suggestedImprovements: string[];
  purchaseIntent: number;
  pricePerception: string;
  valuePerception: number;
  featureFeedback: Record<string, {
    importance: number;
    satisfaction: number;
    comments: string[];
  }>;
  competitiveComparisons: Record<string, number>;
  participantQuotes: string[];
}

export interface IStorage {
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: Omit<User, 'id' | 'createdAt'>): Promise<User>;
  
  // Company operations
  getCompany(id: number): Promise<any>;
  getCompanyByApiKey(apiKey: string): Promise<any>;
  
  // Survey operations
  getSurveyResponse(id: number): Promise<any>;
  getSurveyResponsesByCompany(companyId: number): Promise<any[]>;
  createSurveyResponse(responseData: any): Promise<any>;
  
  // Basic analytics operations
  getCompanyStats(companyId: number): Promise<any>;
  getSurveyAnalytics(surveyId: number): Promise<any>;
  
  // Advanced business analysis operations
  getCompetitorAnalysis(companyId: number): Promise<CompetitorAnalysis[]>;
  getMarketFitAnalysis(companyId: number, productId: string): Promise<MarketFitAnalysis>;
  getCustomerSegments(companyId: number): Promise<CustomerSegment[]>;
  getProductFeaturePriorities(companyId: number): Promise<ProductFeaturePriority[]>;
  getPricingStrategies(companyId: number): Promise<PricingStrategy[]>;
  getMarketingStrategies(companyId: number): Promise<MarketingStrategy[]>;
  getRevenueForecasts(companyId: number): Promise<RevenueForecasting[]>;
  getFocusGroupSimulation(companyId: number, productConcept: string): Promise<SimulatedFocusGroup>;
  
  // Collaboration operations
  getCollaborationSessions(): Promise<CollaborationSession[]>;
  getCollaborationSession(id: number): Promise<CollaborationSession | undefined>;
  createCollaborationSession(session: Omit<CollaborationSession, 'id' | 'createdAt'>): Promise<CollaborationSession>;
  getCollaborationParticipants(sessionId: number): Promise<CollaborationParticipant[]>;
  getCollaborationParticipant(sessionId: number, userId: number): Promise<CollaborationParticipant | undefined>;
  createCollaborationParticipant(participant: Omit<CollaborationParticipant, 'id'>): Promise<CollaborationParticipant>;
  updateCollaborationParticipant(sessionId: number, userId: number, data: Partial<Omit<CollaborationParticipant, 'id' | 'sessionId' | 'userId'>>): Promise<CollaborationParticipant | undefined>;
  updateParticipantCursor(sessionId: number, userId: number, cursorPosition: { x: number, y: number }): Promise<CollaborationParticipant | undefined>;
  updateParticipantStatus(sessionId: number, userId: number, status: string): Promise<CollaborationParticipant | undefined>;
  getCollaborationChanges(sessionId: number): Promise<CollaborationChange[]>;
  getCollaborationChangesByEntity(sessionId: number, entityType: string, entityId: number): Promise<CollaborationChange[]>;
  createCollaborationChange(change: Omit<CollaborationChange, 'id' | 'timestamp'>): Promise<CollaborationChange>;
  getCollaborationComments(sessionId: number): Promise<CollaborationComment[]>;
  createCollaborationComment(comment: Omit<CollaborationComment, 'id' | 'createdAt'>): Promise<CollaborationComment>;
  updateCollaborationComment(id: string, data: Partial<Omit<CollaborationComment, 'id' | 'sessionId' | 'userId'>>): Promise<CollaborationComment | undefined>;
}

export class DatabaseStorage implements IStorage {
  // User operation methods
  async getUser(id: number): Promise<User | undefined> {
    try {
      const [user] = await db.select()
        .from(users)
        .where(eq(users.id, id))
        .limit(1);
      return user;
    } catch (error) {
      console.error(`Error fetching user with ID ${id}:`, error);
      throw error;
    }
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    try {
      const [user] = await db.select()
        .from(users)
        .where(eq(users.username, username))
        .limit(1);
      return user;
    } catch (error) {
      console.error(`Error fetching user with username ${username}:`, error);
      throw error;
    }
  }
  
  async createUser(userData: Omit<User, 'id' | 'createdAt'>): Promise<User> {
    try {
      const now = new Date();
      const [newUser] = await db.insert(users)
        .values({
          ...userData,
          createdAt: now,
          updatedAt: now,
          lastLogin: null
        })
        .returning();
      
      console.log('Created new user:', newUser);
      return newUser;
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  }
  
  // Company operation methods
  async getCompany(id: number): Promise<any> {
    try {
      const [company] = await db.select()
        .from(companies)
        .where(eq(companies.id, id))
        .limit(1);
      return company;
    } catch (error) {
      console.error(`Error fetching company with ID ${id}:`, error);
      throw error;
    }
  }
  
  async getCompanyByApiKey(apiKey: string): Promise<any> {
    try {
      const [company] = await db.select()
        .from(companies)
        .where(eq(companies.apiKey, apiKey))
        .limit(1);
      return company;
    } catch (error) {
      console.error(`Error fetching company by API key:`, error);
      throw error;
    }
  }
  
  // Survey response methods
  async getSurveyResponse(id: number): Promise<any> {
    try {
      const [response] = await db.select()
        .from(surveyResponses)
        .where(eq(surveyResponses.id, id))
        .limit(1);
      return response;
    } catch (error) {
      console.error(`Error fetching survey response with ID ${id}:`, error);
      throw error;
    }
  }
  
  async getSurveyResponsesByCompany(companyId: number): Promise<any[]> {
    try {
      const responses = await db.select()
        .from(surveyResponses)
        .where(eq(surveyResponses.companyId, companyId));
      return responses;
    } catch (error) {
      console.error(`Error fetching survey responses for company ID ${companyId}:`, error);
      throw error;
    }
  }
  
  async createSurveyResponse(responseData: any): Promise<any> {
    try {
      console.log('Creating new survey response:', responseData);
      
      // Set default values for required fields if they don't exist
      const now = new Date();
      const data = {
        ...responseData,
        responses: responseData.responses || {},
        traits: responseData.traits || [],
        demographics: responseData.demographics || {},
        createdAt: now,
        updatedAt: now,
        startTime: responseData.startTime || now
      };
      
      // Insert the response into the database
      const [newResponse] = await db.insert(surveyResponses)
        .values(data)
        .returning();
      
      console.log('Created new survey response with ID:', newResponse.id);
      return newResponse;
    } catch (error) {
      console.error('Error creating survey response:', error);
      throw error;
    }
  }

  // Collaboration methods
  async getCollaborationSessions(): Promise<CollaborationSession[]> {
    try {
      const sessions = await db.select()
        .from(collaborationSessions)
        .orderBy(desc(collaborationSessions.createdAt));
      
      return sessions;
    } catch (error) {
      console.error('Error fetching collaboration sessions:', error);
      throw error;
    }
  }

  async getCollaborationSession(id: number): Promise<CollaborationSession | undefined> {
    try {
      const [session] = await db.select()
        .from(collaborationSessions)
        .where(eq(collaborationSessions.id, id))
        .limit(1);
      
      return session;
    } catch (error) {
      console.error(`Error fetching collaboration session with ID ${id}:`, error);
      throw error;
    }
  }

  async createCollaborationSession(sessionData: Omit<CollaborationSession, 'id' | 'createdAt'>): Promise<CollaborationSession> {
    try {
      const now = new Date();
      const [newSession] = await db.insert(collaborationSessions)
        .values({
          ...sessionData,
          createdAt: now,
          updatedAt: now
        })
        .returning();
      
      console.log('Created new collaboration session:', newSession);
      return newSession;
    } catch (error) {
      console.error('Error creating collaboration session:', error);
      throw error;
    }
  }

  async getCollaborationParticipants(sessionId: number): Promise<CollaborationParticipant[]> {
    try {
      const participants = await db.select()
        .from(collaborationParticipants)
        .where(eq(collaborationParticipants.sessionId, sessionId));
      
      return participants;
    } catch (error) {
      console.error(`Error fetching participants for session ID ${sessionId}:`, error);
      throw error;
    }
  }

  async getCollaborationParticipant(sessionId: number, userId: number): Promise<CollaborationParticipant | undefined> {
    try {
      const [participant] = await db.select()
        .from(collaborationParticipants)
        .where(
          and(
            eq(collaborationParticipants.sessionId, sessionId),
            eq(collaborationParticipants.userId, userId)
          )
        )
        .limit(1);
      
      return participant;
    } catch (error) {
      console.error(`Error fetching participant for session ID ${sessionId} and user ID ${userId}:`, error);
      throw error;
    }
  }

  async createCollaborationParticipant(participantData: Omit<CollaborationParticipant, 'id'>): Promise<CollaborationParticipant> {
    try {
      const now = new Date();
      const [newParticipant] = await db.insert(collaborationParticipants)
        .values({
          ...participantData,
          lastActive: now
        })
        .returning();
      
      console.log('Created new collaboration participant:', newParticipant);
      return newParticipant;
    } catch (error) {
      console.error('Error creating collaboration participant:', error);
      throw error;
    }
  }

  async updateCollaborationParticipant(
    sessionId: number,
    userId: number,
    data: Partial<Omit<CollaborationParticipant, 'id' | 'sessionId' | 'userId'>>
  ): Promise<CollaborationParticipant | undefined> {
    try {
      const now = new Date();
      const [updatedParticipant] = await db.update(collaborationParticipants)
        .set({
          ...data,
          lastActiveAt: now
        })
        .where(
          and(
            eq(collaborationParticipants.sessionId, sessionId),
            eq(collaborationParticipants.userId, userId)
          )
        )
        .returning();
      
      return updatedParticipant;
    } catch (error) {
      console.error(`Error updating participant for session ID ${sessionId} and user ID ${userId}:`, error);
      throw error;
    }
  }
  
  async updateParticipantCursor(
    sessionId: number,
    userId: number,
    cursorPosition: { x: number, y: number }
  ): Promise<CollaborationParticipant | undefined> {
    try {
      const now = new Date();
      const [updatedParticipant] = await db.update(collaborationParticipants)
        .set({
          cursor: cursorPosition,
          lastActiveAt: now
        })
        .where(
          and(
            eq(collaborationParticipants.sessionId, sessionId),
            eq(collaborationParticipants.userId, userId)
          )
        )
        .returning();
      
      return updatedParticipant;
    } catch (error) {
      console.error(`Error updating cursor for session ID ${sessionId} and user ID ${userId}:`, error);
      throw error;
    }
  }
  
  async updateParticipantStatus(
    sessionId: number,
    userId: number,
    status: string
  ): Promise<CollaborationParticipant | undefined> {
    try {
      const now = new Date();
      const [updatedParticipant] = await db.update(collaborationParticipants)
        .set({
          status,
          lastActiveAt: now
        })
        .where(
          and(
            eq(collaborationParticipants.sessionId, sessionId),
            eq(collaborationParticipants.userId, userId)
          )
        )
        .returning();
      
      return updatedParticipant;
    } catch (error) {
      console.error(`Error updating status for session ID ${sessionId} and user ID ${userId}:`, error);
      throw error;
    }
  }

  async getCollaborationChanges(sessionId: number): Promise<CollaborationChange[]> {
    try {
      const changes = await db.select()
        .from(collaborationChanges)
        .where(eq(collaborationChanges.sessionId, sessionId))
        .orderBy(desc(collaborationChanges.timestamp));
      
      return changes;
    } catch (error) {
      console.error(`Error fetching changes for session ID ${sessionId}:`, error);
      throw error;
    }
  }
  
  async getCollaborationChangesByEntity(
    sessionId: number,
    entityType: string,
    entityId: number
  ): Promise<CollaborationChange[]> {
    try {
      const changes = await db.select()
        .from(collaborationChanges)
        .where(
          and(
            eq(collaborationChanges.sessionId, sessionId),
            eq(collaborationChanges.entityType, entityType),
            eq(collaborationChanges.entityId, entityId)
          )
        )
        .orderBy(desc(collaborationChanges.timestamp));
      
      return changes;
    } catch (error) {
      console.error(`Error fetching changes for session ID ${sessionId}, entity type ${entityType}, entity ID ${entityId}:`, error);
      throw error;
    }
  }

  async createCollaborationChange(changeData: Omit<CollaborationChange, 'id' | 'timestamp'>): Promise<CollaborationChange> {
    try {
      const now = new Date();
      const [newChange] = await db.insert(collaborationChanges)
        .values({
          ...changeData,
          timestamp: now
        })
        .returning();
      
      return newChange;
    } catch (error) {
      console.error('Error creating collaboration change:', error);
      throw error;
    }
  }

  async getCollaborationComments(sessionId: number): Promise<CollaborationComment[]> {
    try {
      const comments = await db.select()
        .from(collaborationComments)
        .where(eq(collaborationComments.sessionId, sessionId))
        .orderBy(collaborationComments.createdAt);
      
      return comments;
    } catch (error) {
      console.error(`Error fetching comments for session ID ${sessionId}:`, error);
      throw error;
    }
  }

  async createCollaborationComment(commentData: Omit<CollaborationComment, 'id' | 'createdAt'>): Promise<CollaborationComment> {
    try {
      const now = new Date();
      const [newComment] = await db.insert(collaborationComments)
        .values({
          ...commentData,
          createdAt: now
        })
        .returning();
      
      return newComment;
    } catch (error) {
      console.error('Error creating collaboration comment:', error);
      throw error;
    }
  }

  async updateCollaborationComment(
    id: string,
    data: Partial<Omit<CollaborationComment, 'id' | 'sessionId' | 'userId'>>
  ): Promise<CollaborationComment | undefined> {
    try {
      const [updatedComment] = await db.update(collaborationComments)
        .set(data)
        .where(eq(collaborationComments.id, id))
        .returning();
      
      return updatedComment;
    } catch (error) {
      console.error(`Error updating comment with ID ${id}:`, error);
      throw error;
    }
  }
  
  private getDemoCompanyStats(companyId: number): any {
    return {
      companyId: companyId,
      totalResponses: 523,
      responseCount: 523,
      completionRate: 92,
      averageCompletionTime: 240,
      completedResponses: 480,
      averageSatisfactionScore: 8.7,
      responseRateChange: 15.4,
      // All the data fields including properly formatted engagement metrics
      topTraits: [
        { name: "Openness", score: 72, category: "personality" },
        { name: "Conscientiousness", score: 68, category: "personality" },
        { name: "Agreeableness", score: 64, category: "personality" },
        { name: "Enthusiasm", score: 73, category: "business" },
        { name: "Analytical Thinking", score: 74, category: "business" },
        { name: "Creative Thinking", score: 68, category: "business" },
        { name: "Adaptability", score: 62, category: "business" }
      ],
      demographics: {
        age: {
          "18-24": 84,
          "25-34": 156,
          "35-44": 120,
          "45-54": 87,
          "55-64": 53,
          "65+": 22
        },
        gender: {
          "Male": 267,
          "Female": 243,
          "Non-binary": 12
        },
        genderDistribution: [
          { label: "Male", value: 267, percentage: 51 },
          { label: "Female", value: 243, percentage: 47 },
          { label: "Non-binary", value: 12, percentage: 2 }
        ],
        ageDistribution: [
          { range: "18-24", percentage: 16 },
          { range: "25-34", percentage: 30 },
          { range: "35-44", percentage: 23 },
          { range: "45-54", percentage: 17 },
          { range: "55-64", percentage: 10 },
          { range: "65+", percentage: 4 }
        ],
        ageGroups: { 
          "18-24": 84,
          "25-34": 156,
          "35-44": 120,
          "45-54": 87,
          "55-64": 53,
          "65+": 22
        },
        locationDistribution: [
          { location: "United States", count: 220 },
          { location: "United Kingdom", count: 95 },
          { location: "Canada", count: 78 },
          { location: "Australia", count: 65 },
          { location: "Germany", count: 45 }
        ],
        educationDistribution: [
          { label: "High School", value: 67, percentage: 13 },
          { label: "Bachelor's", value: 258, percentage: 49 },
          { label: "Master's", value: 156, percentage: 30 },
          { label: "PhD", value: 42, percentage: 8 }
        ],
        incomeDistribution: [
          { label: "Under $50k", value: 98, percentage: 19 },
          { label: "$50k-$100k", value: 245, percentage: 47 },
          { label: "$100k-$150k", value: 132, percentage: 25 },
          { label: "Over $150k", value: 48, percentage: 9 }
        ]
      },
      engagementMetrics: {
        dailyActiveUsers: 145,
        monthlyActiveUsers: 2230,
        averageSessionLength: 7.8,
        questionsPerMinute: 1.6,
        bounceRate: 22,
        retentionRate: 78,
        completionByDevice: [
          { device: "Desktop", percentage: 58 },
          { device: "Mobile", percentage: 36 },
          { device: "Tablet", percentage: 6 }
        ],
        dropOffPoints: [
          { questionNumber: 5, dropOffRate: 8 },
          { questionNumber: 10, dropOffRate: 12 },
          { questionNumber: 15, dropOffRate: 18 }
        ],
        peakEngagementTimes: [
          { time: "9am-12pm", percentage: 28 },
          { time: "1pm-4pm", percentage: 35 },
          { time: "6pm-9pm", percentage: 25 },
          { time: "Other", percentage: 12 }
        ],
        userGrowth: [
          { month: "Jan", users: 1450 },
          { month: "Feb", users: 1680 },
          { month: "Mar", users: 1920 },
          { month: "Apr", users: 2230 }
        ],
        activities: [
          { name: "Survey Completion", count: 184, trend: "up" },
          { name: "Account Creation", count: 76, trend: "up" },
          { name: "Result Sharing", count: 42, trend: "neutral" },
          { name: "Team Invites", count: 38, trend: "up" },
          { name: "Report Downloads", count: 29, trend: "down" }
        ]
      },
      businessContext: {
        industries: [
          { name: "Technology", percentage: 42 },
          { name: "Finance", percentage: 28 },
          { name: "Healthcare", percentage: 15 },
          { name: "Education", percentage: 10 },
          { name: "Other", percentage: 5 }
        ],
        companySizes: [
          { size: "1-50 employees", percentage: 25 },
          { size: "51-200 employees", percentage: 35 },
          { size: "201-1000 employees", percentage: 25 },
          { size: "1000+ employees", percentage: 15 }
        ],
        departments: [
          { name: "Management", percentage: 30 },
          { name: "Sales", percentage: 20 },
          { name: "Marketing", percentage: 15 },
          { name: "Product", percentage: 15 },
          { name: "Engineering", percentage: 10 },
          { name: "Other", percentage: 10 }
        ],
        roles: [
          { name: "Executive", percentage: 15 },
          { name: "Middle Management", percentage: 35 },
          { name: "Team Lead", percentage: 25 },
          { name: "Individual Contributor", percentage: 25 }
        ],
        decisionStyles: [
          { name: "Data-driven", percentage: 45 },
          { name: "Intuitive", percentage: 25 },
          { name: "Collaborative", percentage: 20 },
          { name: "Authoritative", percentage: 10 }
        ]
      },
      // Rest of the demo data...
    };
  }

  async getCompanyStats(companyId: number): Promise<any> {
    console.log(`getCompanyStats called with companyId: ${companyId}`);
    
    // Special handling for the demo account - could be either ID 1 or 2
    if (companyId === 1 || companyId === 2) {
      // We're treating either companyId 1 or 2 as the demo account for this purpose
      console.log(`Returning demo company stats for DEMO company ID ${companyId}`);
      
      // Return the structured demo data with engagement metrics
      return this.getDemoCompanyStats(companyId);
        completedResponses: 480,
        averageSatisfactionScore: 8.7,
        responseRateChange: 15.4,
        // Trait data for chart components with consistent structure and categories
        topTraits: [
          { name: "Openness", score: 72, category: "personality" },
          { name: "Conscientiousness", score: 68, category: "personality" },
          { name: "Extraversion", score: 54, category: "personality" },
          { name: "Agreeableness", score: 63, category: "personality" },
          { name: "Neuroticism", score: 36, category: "personality" },
          { name: "Risk Tolerance", score: 69, category: "business" },
          { name: "Decision Speed", score: 57, category: "business" },
          { name: "Analytical Thinking", score: 74, category: "business" },
          { name: "Creative Thinking", score: 68, category: "business" },
          { name: "Adaptability", score: 62, category: "business" }
        ],
        // Original traits array format 
        traits: [
          { name: "Openness", score: 72, category: "personality" },
          { name: "Conscientiousness", score: 68, category: "personality" },
          { name: "Extraversion", score: 54, category: "personality" },
          { name: "Agreeableness", score: 63, category: "personality" },
          { name: "Neuroticism", score: 36, category: "personality" },
          { name: "Risk Tolerance", score: 69, category: "business" },
          { name: "Decision Speed", score: 57, category: "business" },
          { name: "Analytical Thinking", score: 74, category: "business" },
          { name: "Creative Thinking", score: 68, category: "business" },
          { name: "Adaptability", score: 62, category: "business" }
        ],
        // Average traits in alternative format for backward compatibility
        averageTraits: [
          { name: "Openness", score: 72, category: "personality" },
          { name: "Conscientiousness", score: 68, category: "personality" },
          { name: "Extraversion", score: 54, category: "personality" },
          { name: "Agreeableness", score: 63, category: "personality" },
          { name: "Neuroticism", score: 36, category: "personality" },
          { name: "Risk Tolerance", score: 69, category: "business" },
          { name: "Decision Speed", score: 57, category: "business" },
          { name: "Analytical Thinking", score: 74, category: "business" },
          { name: "Creative Thinking", score: 68, category: "business" },
          { name: "Adaptability", score: 62, category: "business" }
        ],
        // FIXED FORMAT demographics for frontend
        demographics: {
          // Legacy format preserved for backward compatibility
          age: {
            "18-24": 84,
            "25-34": 156,
            "35-44": 120,
            "45-54": 87,
            "55-64": 53,
            "65+": 22
          },
          gender: {
            "Male": 267,
            "Female": 243,
            "Non-binary": 12
          },
          // Enhanced distribution arrays - EXACTLY MATCHES frontend component needs
          genderDistribution: [
            { label: "Male", value: 267, percentage: 51 },
            { label: "Female", value: 243, percentage: 47 },
            { label: "Non-binary", value: 12, percentage: 2 }
          ],
          ageDistribution: [
            { range: "18-24", percentage: 16 },
            { range: "25-34", percentage: 30 },
            { range: "35-44", percentage: 23 },
            { range: "45-54", percentage: 17 },
            { range: "55-64", percentage: 10 },
            { range: "65+", percentage: 4 }
          ],
          // Added for older format compatibility
          ageGroups: { 
            "18-24": 84,
            "25-34": 156,
            "35-44": 120,
            "45-54": 87,
            "55-64": 53,
            "65+": 22
          },
          locationDistribution: [
            { location: "United States", count: 220 },
            { location: "United Kingdom", count: 95 },
            { location: "Canada", count: 78 },
            { location: "Australia", count: 65 },
            { location: "Germany", count: 45 }
          ],
          educationDistribution: [
            { label: "High School", value: 67, percentage: 13 },
            { label: "Bachelor's", value: 258, percentage: 49 },
            { label: "Master's", value: 156, percentage: 30 },
            { label: "PhD", value: 42, percentage: 8 }
          ],
          incomeDistribution: [
            { label: "Under $50k", value: 98, percentage: 19 },
            { label: "$50k-$100k", value: 245, percentage: 47 },
            { label: "$100k-$150k", value: 132, percentage: 25 },
            { label: "Over $150k", value: 48, percentage: 9 }
          ]
        },
        monthOverMonthGrowth: {
          respondents: 12.5,
          completion: 3.8,
          satisfaction: 2.1,
          retention: 5.2,
          engagement: 8.6
        },
        // Enhanced surveyStats with actual values and percentages
        surveyStats: {
          activeCount: 3,
          completedCount: 8,
          draftCount: 2,
          totalCount: 13,
          avgQuestionsPerSurvey: 12.5,
          avgCompletionTimeMinutes: 8.2,
          avgResponseRate: 68.5,
          mostPopularTimesToComplete: [
            { timeSlot: "9am-12pm", percentage: 38 },
            { timeSlot: "1pm-5pm", percentage: 42 },
            { timeSlot: "6pm-10pm", percentage: 20 }
          ]
        },
        // Enhanced response distribution with trend data
        responseDistribution: {
          "Last 24 hours": 28,
          "Last week": 143,
          "Last month": 352,
          "Last quarter": 1246,
          daily: [
            { date: "2025-05-06", count: 18 },
            { date: "2025-05-07", count: 23 },
            { date: "2025-05-08", count: 19 },
            { date: "2025-05-09", count: 25 },
            { date: "2025-05-10", count: 28 },
            { date: "2025-05-11", count: 31 },
            { date: "2025-05-12", count: 28 }
          ],
          weekly: [
            { week: "Week 1", count: 112 },
            { week: "Week 2", count: 125 },
            { week: "Week 3", count: 143 },
            { week: "Week 4", count: 143 }
          ]
        },
        // Enhanced sentiment data
        sentiment: {
          positive: 68,
          neutral: 22,
          negative: 10,
          trend: [
            { month: "Jan", positive: 62, neutral: 26, negative: 12 },
            { month: "Feb", positive: 64, neutral: 25, negative: 11 },
            { month: "Mar", positive: 66, neutral: 24, negative: 10 },
            { month: "Apr", positive: 68, neutral: 22, negative: 10 }
          ],
          keyPhrases: [
            { phrase: "easy to use", count: 87, sentiment: "positive" },
            { phrase: "intuitive interface", count: 72, sentiment: "positive" },
            { phrase: "helpful support", count: 53, sentiment: "positive" },
            { phrase: "confusing navigation", count: 28, sentiment: "negative" },
            { phrase: "slow loading", count: 22, sentiment: "negative" }
          ]
        },
        // FIXED FORMAT business context for frontend
        businessContext: {
          industries: [
            { name: "Technology", percentage: 42 },
            { name: "Finance", percentage: 28 },
            { name: "Healthcare", percentage: 15 },
            { name: "Education", percentage: 10 },
            { name: "Other", percentage: 5 }
          ],
          companySizes: [
            { size: "1-50 employees", percentage: 25 },
            { size: "51-200 employees", percentage: 35 },
            { size: "201-1000 employees", percentage: 25 },
            { size: "1000+ employees", percentage: 15 }
          ],
          departments: [
            { name: "Management", percentage: 30 },
            { name: "Sales", percentage: 20 },
            { name: "Marketing", percentage: 15 },
            { name: "Product", percentage: 15 },
            { name: "Engineering", percentage: 10 },
            { name: "Other", percentage: 10 }
          ],
          roles: [
            { name: "Executive", percentage: 15 },
            { name: "Middle Management", percentage: 35 },
            { name: "Team Lead", percentage: 25 },
            { name: "Individual Contributor", percentage: 25 }
          ],
          decisionStyles: [
            { name: "Data-driven", percentage: 45 },
            { name: "Intuitive", percentage: 25 },
            { name: "Collaborative", percentage: 20 },
            { name: "Authoritative", percentage: 10 }
          ]
        },
        // Added data for stereotypes tab - FIXED FORMAT for frontend
        genderStereotypes: {
          maleAssociated: [
            { trait: "Risk-taking", score: 72, description: "Tendency to take risks in business and personal decisions" },
            { trait: "Competitiveness", score: 76, description: "Drive to outperform others and achieve goals" },
            { trait: "Assertiveness", score: 73, description: "Confidence in expressing opinions and taking action" },
            { trait: "Analytical Thinking", score: 69, description: "Logical approach to problem-solving" }
          ],
          femaleAssociated: [
            { trait: "Emotional Intelligence", score: 78, description: "Ability to understand and manage emotions" },
            { trait: "Collaborative", score: 75, description: "Tendency to work well with others" },
            { trait: "Detail-oriented", score: 76, description: "Focus on precision and thoroughness" },
            { trait: "Empathy", score: 81, description: "Ability to understand others' perspectives" }
          ],
          neutralAssociated: [
            { trait: "Adaptability", score: 70, description: "Ability to adjust to new conditions" },
            { trait: "Creativity", score: 68, description: "Ability to generate novel ideas" },
            { trait: "Persistence", score: 72, description: "Determination despite obstacles" }
          ]
        },
        // FIXED FORMAT engagement metrics for frontend
        engagementMetrics: {
          dailyActiveUsers: 145,
          monthlyActiveUsers: 2230,
          averageSessionLength: 7.8,
          questionsPerMinute: 1.6,
          bounceRate: 22,
          retentionRate: 78,
          completionByDevice: [
            { device: "Desktop", percentage: 58 },
            { device: "Mobile", percentage: 36 },
            { device: "Tablet", percentage: 6 }
          ],
          dropOffPoints: [
            { questionNumber: 5, dropOffRate: 8 },
            { questionNumber: 10, dropOffRate: 12 },
            { questionNumber: 15, dropOffRate: 18 }
          ],
          peakEngagementTimes: [
            { time: "9am-12pm", percentage: 28 },
            { time: "1pm-4pm", percentage: 35 },
            { time: "6pm-9pm", percentage: 25 },
            { time: "Other", percentage: 12 }
          ],
          userGrowth: [
            { month: "Jan", users: 1450 },
            { month: "Feb", users: 1680 },
            { month: "Mar", users: 1920 },
            { month: "Apr", users: 2230 }
          ],
          activities: [
            { name: "Survey Completion", count: 184, trend: "up" },
            { name: "Account Creation", count: 76, trend: "up" },
            { name: "Result Sharing", count: 42, trend: "neutral" },
            { name: "Team Invites", count: 38, trend: "up" },
            { name: "Report Downloads", count: 29, trend: "down" }
          ]
        },
        // Keep original engagement format for backward compatibility
        engagement: {
          averageSessionLength: 7.8,
          questionsPerMinute: 1.6,
          completionByDevice: [
            { device: "Desktop", percentage: 58 },
            { device: "Mobile", percentage: 36 },
            { device: "Tablet", percentage: 6 }
          ],
          dropOffPoints: [
            { questionNumber: 5, dropOffRate: 8 },
            { questionNumber: 10, dropOffRate: 12 },
            { questionNumber: 15, dropOffRate: 18 }
          ],
          peakEngagementTimes: [
            { time: "9am-12pm", percentage: 28 },
            { time: "1pm-4pm", percentage: 35 },
            { time: "6pm-9pm", percentage: 25 },
            { time: "Other", percentage: 12 }
          ]
        },
        // Added data for product recommendations - FIXED FORMAT for frontend
        productRecommendations: {
          categories: {
            "Team Collaboration": 45,
            "HR Management": 30,
            "Professional Development": 15,
            "Productivity Tools": 10
          },
          topProducts: [
            { name: "Team Collaboration Suite", confidence: 92, category: "Team Collaboration", description: "Enterprise-grade collaboration platform", attributes: ["Real-time collaboration", "Task management", "Team analytics"] },
            { name: "HR Excellence Platform", confidence: 88, category: "HR Management", description: "Comprehensive HR solution", attributes: ["Employee development", "Performance tracking", "Culture assessment"] },
            { name: "Leadership Development Program", confidence: 85, category: "Professional Development", description: "Executive coaching program", attributes: ["Executive coaching", "Leadership assessment", "Skill development"] },
            { name: "Productivity Analytics", confidence: 79, category: "Productivity Tools", description: "Team productivity measurement suite", attributes: ["Time tracking", "Performance metrics", "Improvement suggestions"] }
          ]
        },
        // Added comparison metrics
        industryComparisons: {
          averageCompletionRate: 87, // Your rate is 92
          averageSatisfactionScore: 7.9, // Your score is 8.7
          averageResponseRate: 62, // industry benchmark
          averageEngagementScore: 74 // industry benchmark
        }
      };
    }
    console.log(`Generating company stats for company ID: ${companyId}`);
    
    try {
      // Use direct SQL query to get all survey responses for this company from the database
      // This avoids the relational query issues with businessContexts table
      const rawResponses = await db.execute(sql`
        SELECT sr.*, s.title as survey_title 
        FROM survey_responses sr 
        JOIN surveys s ON sr.survey_id = s.id 
        WHERE sr.company_id = ${companyId}
      `);
      
      // Ensure we have an array to work with for consistency
      const responses = Array.isArray(rawResponses) ? rawResponses : [];
      
      console.log(`Found ${responses.length} survey responses for company ${companyId}`);
      
      if (responses.length === 0) {
        return {
          companyId,
          responsesCount: 0,
          surveysCount: 0,
          message: "No survey responses found for this company"
        };
      }
      
      // Count unique surveys - handle array format from SQL query
      const uniqueSurveyIds = new Set();
      responses.forEach(r => {
        if (r.survey_id) {
          uniqueSurveyIds.add(r.survey_id);
        }
      });
      const uniqueSurveys = uniqueSurveyIds.size;
      
      // Calculate completion rate - handle SQL result format
      const completedResponses = responses.filter(r => r.completed === true || r.completed === 1).length;
      const completionRate = responses.length > 0 
        ? (completedResponses / responses.length) * 100 
        : 0;
      
      // Calculate average satisfaction score
      const satisfactionScores = [];
      responses.forEach(r => {
        if (r.satisfaction_score !== null && r.satisfaction_score !== undefined) {
          satisfactionScores.push(r.satisfaction_score);
        }
      });
      
      const averageSatisfactionScore = satisfactionScores.length > 0
        ? satisfactionScores.reduce((sum, score) => sum + score, 0) / satisfactionScores.length
        : 0;
      
      // Aggregate personality traits across all responses
      const traitMap = new Map();
      
      responses.forEach(response => {
        try {
          const traits = response.traits ? JSON.parse(response.traits) : [];
          if (Array.isArray(traits)) {
            traits.forEach((trait: PersonalityTrait) => {
              if (trait && trait.name && trait.score !== undefined) {
                if (traitMap.has(trait.name)) {
                  traitMap.set(trait.name, {
                    count: traitMap.get(trait.name).count + 1,
                    totalScore: traitMap.get(trait.name).totalScore + trait.score,
                    category: trait.category || 'general'
                  });
                } else {
                  traitMap.set(trait.name, {
                    count: 1,
                    totalScore: trait.score,
                    category: trait.category || 'general'
                  });
                }
              }
            });
          }
        } catch (e) {
          console.error('Error parsing traits from response:', e);
        }
      });
      
      // Calculate average scores for each trait
      const traitAverages = Array.from(traitMap.entries()).map(([name, data]) => ({
        name,
        score: Math.round(data.totalScore / data.count),
        category: data.category
      }));
      
      // Sort traits by score and take top 5
      const topTraits = traitAverages
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      // Aggregate demographic data
      const demographics = responses.reduce((demo, response) => {
        try {
          const demographicsData = response.demographics ? JSON.parse(response.demographics) : null;
          if (demographicsData) {
            // Process gender
            if (demographicsData.gender) {
              demo.genderCounts[demographicsData.gender] = 
                (demo.genderCounts[demographicsData.gender] || 0) + 1;
            }
            
            // Process age
            if (demographicsData.age) {
              let ageGroup = '55+';
              if (demographicsData.age < 25) ageGroup = '18-24';
              else if (demographicsData.age < 35) ageGroup = '25-34';
              else if (demographicsData.age < 45) ageGroup = '35-44';
              else if (demographicsData.age < 55) ageGroup = '45-54';
              
              demo.ageCounts[ageGroup] = (demo.ageCounts[ageGroup] || 0) + 1;
            }
            
            // Process location
            if (demographicsData.location) {
              demo.locationCounts[demographicsData.location] = 
                (demo.locationCounts[demographicsData.location] || 0) + 1;
            }
          }
        } catch (e) {
          console.error('Error parsing demographics from response:', e);
        }
        return demo;
      }, { 
        genderCounts: {}, 
        ageCounts: {}, 
        locationCounts: {} 
      });
      
      // Format demographic data for the frontend
      const formattedDemographics = {
        genderDistribution: Object.entries(demographics.genderCounts).map(([label, value]) => ({ 
          label, 
          value: typeof value === 'number' ? value : 0
        })),
        ageDistribution: Object.entries(demographics.ageCounts).map(([label, value]) => ({ 
          label, 
          value: typeof value === 'number' ? value : 0
        })),
        locationDistribution: Object.entries(demographics.locationCounts)
          .sort((a, b) => (b[1] as number) - (a[1] as number))
          .slice(0, 5)
          .map(([label, value]) => ({ 
            label, 
            value: typeof value === 'number' ? value : 0
          }))
      };
      
      // Return formatted analytics data
      return {
        companyId,
        responsesCount: responses.length,
        surveysCount: uniqueSurveys,
        completionRate: parseFloat(completionRate.toFixed(1)),
        averageSatisfactionScore: parseFloat(averageSatisfactionScore.toFixed(1)),
        topTraits,
        demographics: formattedDemographics,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      console.error(`Error generating company stats for ${companyId}:`, error);
      throw error;
    }
  }
  
  async getSurveyAnalytics(surveyId: number): Promise<any> {
    console.log(`Fetching analytics for survey ID: ${surveyId}`);
    
    try {
      // Try to get the company ID associated with this survey
      const [surveyData] = await db.execute(sql`
        SELECT company_id FROM surveys WHERE id = ${surveyId}
      `);
      
      // Check if this survey belongs to demo companies (IDs 1 or 2)
      const companyId = surveyData?.company_id;
      
      if (companyId === 1 || companyId === 2) {
        console.log(`Returning demo analytics for DEMO company (${companyId}) survey ID: ${surveyId}`);
      // COMPLETE HARDCODED DEMO DATA that exactly matches the template/design of real client data
      return {
        // Basic survey metrics matching exact format expected by frontend
        surveyId: surveyId,
        title: "Personality Assessment",
        totalResponses: 412,
        completedResponses: 351,
        responseCount: 412,
        completionRate: 85.2,
        averageTimeSpent: 326,
        dropoffRate: 14.8,
        averageSatisfactionScore: 8.4,
        surveyCount: 1,
        // Comprehensive trait data with consistent structure
        traitDistribution: {
          analytical: 28,
          creative: 22,
          detail_oriented: 19,
          emotionally_intelligent: 24,
          extroverted: 18,
          introverted: 17,
          leadership: 23,
          problem_solving: 27,
          risk_taking: 16,
          teamwork: 25
        },
        // Enhanced trait array format for visualization components
        traitScores: [
          { name: "Analytical", score: 28, category: "cognitive" },
          { name: "Creative", score: 22, category: "cognitive" },
          { name: "Detail-oriented", score: 19, category: "work" },
          { name: "Emotional Intelligence", score: 24, category: "interpersonal" },
          { name: "Extraversion", score: 18, category: "personality" },
          { name: "Introversion", score: 17, category: "personality" },
          { name: "Leadership", score: 23, category: "interpersonal" },
          { name: "Problem-solving", score: 27, category: "cognitive" },
          { name: "Risk-taking", score: 16, category: "decision" },
          { name: "Teamwork", score: 25, category: "interpersonal" }
        ],
        // Comprehensive demographic data with both counts and percentages
        demographicBreakdown: {
          age: {
            "18-24": 15,
            "25-34": 35,
            "35-44": 28,
            "45-54": 15,
            "55+": 7
          },
          gender: {
            "Male": 52,
            "Female": 47,
            "Non-binary": 1
          },
          location: {
            "Urban": 62,
            "Suburban": 30,
            "Rural": 8
          },
        },
        // Response trends over time with formatted dates
        responseOverTime: [
          { date: "2025-04-05", count: 12 },
          { date: "2025-04-06", count: 8 },
          { date: "2025-04-07", count: 15 },
          { date: "2025-04-08", count: 18 },
          { date: "2025-04-09", count: 22 },
          { date: "2025-04-10", count: 20 },
          { date: "2025-04-11", count: 25 },
          { date: "2025-04-12", count: 28 }
        ],
        // Enhanced demographic data with formatted structure
        demographicDistribution: {
          ageDistribution: [
            { label: "18-24", value: 62, percentage: 15 },
            { label: "25-34", value: 144, percentage: 35 },
            { label: "35-44", value: 115, percentage: 28 },
            { label: "45-54", value: 62, percentage: 15 },
            { label: "55+", value: 29, percentage: 7 }
          ],
          genderDistribution: [
            { label: "Male", value: 214, percentage: 52 },
            { label: "Female", value: 194, percentage: 47 },
            { label: "Non-binary", value: 4, percentage: 1 }
          ],
          locationDistribution: [
            { label: "Urban", value: 256, percentage: 62 },
            { label: "Suburban", value: 123, percentage: 30 },
            { label: "Rural", value: 33, percentage: 8 }
          ],
          educationDistribution: [
            { label: "High School", value: 53, percentage: 13 },
            { label: "Bachelor's", value: 226, percentage: 55 },
            { label: "Master's", value: 107, percentage: 26 },
            { label: "PhD", value: 26, percentage: 6 }
          ],
          incomeDistribution: [
            { label: "Under $50K", value: 74, percentage: 18 },
            { label: "$50K-$100K", value: 165, percentage: 40 },
            { label: "$100K-$150K", value: 115, percentage: 28 },
            { label: "Over $150K", value: 58, percentage: 14 }
          ]
        },
        // Sentiment analysis data with positive/negative/neutral breakdowns
        sentimentAnalysis: {
          overall: 78,
          positive: 68,
          neutral: 24,
          negative: 8,
          byCategory: [
            { category: "User Interface", positive: 72, neutral: 21, negative: 7 },
            { category: "Features", positive: 81, neutral: 15, negative: 4 },
            { category: "Value", positive: 65, neutral: 25, negative: 10 },
            { category: "Support", positive: 70, neutral: 20, negative: 10 }
          ],
          keyPhrases: [
            { phrase: "intuitive design", sentiment: "positive", count: 87 },
            { phrase: "easy to use", sentiment: "positive", count: 76 },
            { phrase: "valuable insights", sentiment: "positive", count: 64 },
            { phrase: "confusing navigation", sentiment: "negative", count: 28 },
            { phrase: "missing features", sentiment: "negative", count: 12 }
          ]
        },
        // Additional business analytics metrics
        businessMetrics: {
          keySegments: [
            { name: "Enterprise Decision Makers", percentage: 32 },
            { name: "HR Professionals", percentage: 28 },
            { name: "Team Leaders", percentage: 23 },
            { name: "Individual Contributors", percentage: 17 }
          ],
          industryBreakdown: [
            { industry: "Technology", percentage: 34 },
            { industry: "Finance", percentage: 22 },
            { industry: "Healthcare", percentage: 18 },
            { industry: "Education", percentage: 14 },
            { industry: "Manufacturing", percentage: 12 }
          ],
          recommendedActions: [
            "Emphasize analytical insights for tech sector",
            "Develop specialized finance industry reports",
            "Enhance team dynamics visualizations",
            "Create executive-friendly summary dashboards"
          ]
        }
      };
    }
    } catch (error) {
      console.error(`Error checking for demo account (1 or 2): ${error}`);
      // Continue with normal processing if there was an error checking demo status
    }
    
    try {
      // Get the survey details with direct SQL
      const [survey] = await db.execute(sql`
        SELECT * FROM surveys WHERE id = ${surveyId}
      `);
      
      if (!survey) {
        throw new Error(`Survey with ID ${surveyId} not found`);
      }
      
      // Get all responses for this specific survey with direct SQL
      const rawResponses = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE survey_id = ${surveyId}
      `);
      
      // Ensure we have an array to work with for consistency
      const responses = Array.isArray(rawResponses) ? rawResponses : [];
      
      console.log(`Found ${responses.length} responses for survey ${surveyId}`);
      
      if (responses.length === 0) {
        return {
          surveyId,
          title: survey.title || `Survey ${surveyId}`,
          responseCount: 0,
          message: "No responses found for this survey"
        };
      }
      
      // Calculate basic metrics - handle SQL result format
      const completedResponses = responses.filter(r => r.completed === true || r.completed === 1).length;
      const completionRate = (completedResponses / responses.length) * 100;
      
      // Calculate average satisfaction score from responses that have one
      const satisfactionScores = [];
      responses.forEach(r => {
        if (r.satisfaction_score !== null && r.satisfaction_score !== undefined) {
          satisfactionScores.push(r.satisfaction_score);
        }
      });
      
      const averageSatisfactionScore = satisfactionScores.length > 0
        ? satisfactionScores.reduce((sum, score) => sum + score, 0) / satisfactionScores.length
        : 0;
      
      // Aggregate personality traits across all responses
      const traitMap = new Map();
      
      responses.forEach(response => {
        try {
          const traits = response.traits ? JSON.parse(response.traits) : [];
          if (Array.isArray(traits)) {
            traits.forEach((trait: PersonalityTrait) => {
              if (trait && trait.name && trait.score !== undefined) {
                if (traitMap.has(trait.name)) {
                  traitMap.set(trait.name, {
                    count: traitMap.get(trait.name).count + 1,
                    totalScore: traitMap.get(trait.name).totalScore + trait.score,
                    category: trait.category || 'general'
                  });
                } else {
                  traitMap.set(trait.name, {
                    count: 1,
                    totalScore: trait.score,
                    category: trait.category || 'general'
                  });
                }
              }
            });
          }
        } catch (e) {
          console.error('Error parsing traits from response:', e);
        }
      });
      
      // Calculate average scores for each trait
      const traitAverages = Array.from(traitMap.entries()).map(([name, data]) => ({
        name,
        score: Math.round(data.totalScore / data.count),
        category: data.category
      }));
      
      // Sort traits by score and take top 5
      const topTraits = traitAverages
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      // Aggregate demographic data
      const demographics = responses.reduce((demo, response) => {
        try {
          const demographicsData = response.demographics ? JSON.parse(response.demographics) : null;
          if (demographicsData) {
            // Process gender
            if (demographicsData.gender) {
              demo.genderCounts[demographicsData.gender] = 
                (demo.genderCounts[demographicsData.gender] || 0) + 1;
            }
            
            // Process age
            if (demographicsData.age) {
              let ageGroup = '55+';
              if (demographicsData.age < 25) ageGroup = '18-24';
              else if (demographicsData.age < 35) ageGroup = '25-34';
              else if (demographicsData.age < 45) ageGroup = '35-44';
              else if (demographicsData.age < 55) ageGroup = '45-54';
              
              demo.ageCounts[ageGroup] = (demo.ageCounts[ageGroup] || 0) + 1;
            }
            
            // Process location
            if (demographicsData.location) {
              demo.locationCounts[demographicsData.location] = 
                (demo.locationCounts[demographicsData.location] || 0) + 1;
            }
          }
        } catch (e) {
          console.error('Error parsing demographics from response:', e);
        }
        return demo;
      }, { 
        genderCounts: {}, 
        ageCounts: {}, 
        locationCounts: {} 
      });
      
      // Format demographic data for the frontend
      const formattedDemographics = {
        genderDistribution: Object.entries(demographics.genderCounts).map(([label, value]) => ({ 
          label, 
          value: typeof value === 'number' ? value : 0
        })),
        ageDistribution: Object.entries(demographics.ageCounts).map(([label, value]) => ({ 
          label, 
          value: typeof value === 'number' ? value : 0
        })),
        locationDistribution: Object.entries(demographics.locationCounts)
          .sort((a, b) => (b[1] as number) - (a[1] as number))
          .slice(0, 5)
          .map(([label, value]) => ({ 
            label, 
            value: typeof value === 'number' ? value : 0
          }))
      };
      
      // Calculate response trend data by grouping into periods (weeks)
      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
      
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
      
      const threeWeeksAgo = new Date();
      threeWeeksAgo.setDate(threeWeeksAgo.getDate() - 21);
      
      const fourWeeksAgo = new Date();
      fourWeeksAgo.setDate(fourWeeksAgo.getDate() - 28);
      
      // Group responses by week - convert SQL date format safely
      const getCreatedDate = (r) => {
        try {
          return r.createdAt ? new Date(r.createdAt) : null;
        } catch (e) {
          return null;
        }
      };
      
      const responsesByPeriod = [
        { 
          period: "Week 1", 
          count: responses.filter(r => {
            const date = getCreatedDate(r);
            return date && date >= fourWeeksAgo && date < threeWeeksAgo;
          }).length 
        },
        { 
          period: "Week 2", 
          count: responses.filter(r => {
            const date = getCreatedDate(r);
            return date && date >= threeWeeksAgo && date < twoWeeksAgo;
          }).length 
        },
        { 
          period: "Week 3", 
          count: responses.filter(r => {
            const date = getCreatedDate(r);
            return date && date >= twoWeeksAgo && date < oneWeekAgo;
          }).length 
        },
        { 
          period: "Week 4", 
          count: responses.filter(r => {
            const date = getCreatedDate(r);
            return date && date >= oneWeekAgo;
          }).length 
        }
      ];
      
      // Calculate month-over-month growth
      // For demo purposes we're simulating this since we might not have 2 months of data
      const thisMonthCount = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date >= twoWeeksAgo;
      }).length;
      
      const lastMonthCount = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date < twoWeeksAgo;
      }).length;
      
      // Calculate growth percentages
      const respondentGrowth = lastMonthCount > 0 
        ? ((thisMonthCount - lastMonthCount) / lastMonthCount) * 100 
        : 0;
      
      // Calculate completion rate growth
      const thisMonthCompleted = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date >= twoWeeksAgo && 
          (r.completed === true || r.completed === 1);
      }).length;
      
      const thisMonthCompletionRate = thisMonthCount > 0 
        ? (thisMonthCompleted / thisMonthCount) * 100 
        : 0;
      
      const lastMonthCompleted = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date < twoWeeksAgo && 
          (r.completed === true || r.completed === 1);
      }).length;
      
      const lastMonthCompletionRate = lastMonthCount > 0 
        ? (lastMonthCompleted / lastMonthCount) * 100 
        : 0;
      
      const completionGrowth = lastMonthCompletionRate > 0 
        ? ((thisMonthCompletionRate - lastMonthCompletionRate) / lastMonthCompletionRate) * 100 
        : 0;
      
      // Calculate satisfaction growth
      const thisMonthSatisfactionResponses = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date >= twoWeeksAgo && 
          (r.satisfaction_score !== null && r.satisfaction_score !== undefined);
      });
      
      const thisMonthSatisfaction = thisMonthSatisfactionResponses.length > 0
        ? thisMonthSatisfactionResponses.reduce((sum, r) => sum + r.satisfaction_score, 0) / thisMonthSatisfactionResponses.length
        : 0;
      
      const lastMonthSatisfactionResponses = responses.filter(r => {
        const date = getCreatedDate(r);
        return date && date < twoWeeksAgo && 
          (r.satisfaction_score !== null && r.satisfaction_score !== undefined);
      });
      
      const lastMonthSatisfaction = lastMonthSatisfactionResponses.length > 0
        ? lastMonthSatisfactionResponses.reduce((sum, r) => sum + r.satisfaction_score, 0) / lastMonthSatisfactionResponses.length
        : 0;
      
      const satisfactionGrowth = lastMonthSatisfaction > 0 
        ? ((thisMonthSatisfaction - lastMonthSatisfaction) / lastMonthSatisfaction) * 100 
        : 0;
      
      // Calculate market segments based on traits
      const traitBasedSegments = {
        "Early Adopter": ["Innovation Adoption", "Risk Tolerance"],
        "Tech Enthusiast": ["Technical Complexity Tolerance", "Early Technology Adoption"],
        "Value Conscious": ["Cost Sensitivity", "Value Analysis"],
        "Traditional Buyer": ["Brand Loyalty", "Reliability Focus"],
        "Late Adopter": ["Risk Aversion", "Traditional Values"]
      };
      
      // Count occurrences of traits that map to segments
      const segmentCounts = {};
      const totalSegmentTraits = responses.reduce((total, response) => {
        let matchingTraits = 0;
        
        if (response.traits && Array.isArray(response.traits)) {
          response.traits.forEach((trait: PersonalityTrait) => {
            if (trait.name) {
              // Check which segment this trait might belong to
              Object.entries(traitBasedSegments).forEach(([segment, traits]) => {
                if (traits.includes(trait.name)) {
                  segmentCounts[segment] = (segmentCounts[segment] || 0) + 1;
                  matchingTraits++;
                }
              });
            }
          });
        }
        
        return total + matchingTraits;
      }, 0);
      
      // Calculate percentages for segments
      const marketSegments = Object.entries(segmentCounts).map(([segment, count]) => ({
        segment,
        percentage: totalSegmentTraits > 0 
          ? Math.round((count as number / totalSegmentTraits) * 100) 
          : 0
      })).sort((a, b) => b.percentage - a.percentage);
      
      // Add "Other" category if the total is less than 100%
      const totalPercentage = marketSegments.reduce((sum, segment) => sum + segment.percentage, 0);
      if (totalPercentage < 100 && totalPercentage > 0) {
        marketSegments.push({
          segment: "Other",
          percentage: 100 - totalPercentage
        });
      }
      
      // If we don't have enough data, provide some reasonable defaults
      if (marketSegments.length === 0) {
        marketSegments.push(
          { segment: "Early Adopter", percentage: 32 },
          { segment: "Tech Enthusiast", percentage: 24 },
          { segment: "Value Conscious", percentage: 23 },
          { segment: "Traditional Buyer", percentage: 16 },
          { segment: "Late Adopter", percentage: 5 }
        );
      }
      
      return {
        surveyId,
        title: survey.title || `Survey ${surveyId}`,
        responseCount: responses.length,
        completionRate: parseFloat(completionRate.toFixed(1)),
        averageSatisfactionScore: parseFloat(averageSatisfactionScore.toFixed(1)),
        topTraits,
        demographics: formattedDemographics,
        responsesByPeriod,
        monthOverMonthGrowth: {
          respondents: parseFloat(respondentGrowth.toFixed(1)),
          completion: parseFloat(completionGrowth.toFixed(1)),
          satisfaction: parseFloat(satisfactionGrowth.toFixed(1))
        },
        marketSegments: marketSegments.slice(0, 5), // Take top 5 segments
        lastUpdated: new Date()
      };
    } catch (error) {
      console.error(`Error generating survey analytics for ${surveyId}:`, error);
      throw error;
    }
  }
  
  async getCompetitorAnalysis(companyId: number): Promise<CompetitorAnalysis[]> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getCompetitorAnalysis called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning demo competitor analysis for DEMO company ID: ${companyId}`);
      
      // Hardcoded demo competitor data
      const demoCompetitors = [
        {
          id: 1,
          name: "MarketInsight Pro",
          marketShare: 34,
          strengthScore: 86,
          weaknessScore: 45,
          overallThreatLevel: 68,
          primaryCompetitiveAdvantage: "Enterprise-grade security features",
          keyWeakness: "High pricing point",
          customerSentiment: 72,
          pricingPosition: "Premium",
          productFeatureComparison: {
            "Analytics Depth": { competitor: 80, our: 75 },
            "User Experience": { competitor: 65, our: 82 },
            "Integration Options": { competitor: 90, our: 78 },
            "Customization": { competitor: 72, our: 85 }
          }
        },
        {
          id: 2,
          name: "SurveyMaster",
          marketShare: 28,
          strengthScore: 73,
          weaknessScore: 52,
          overallThreatLevel: 61,
          primaryCompetitiveAdvantage: "User-friendly interface",
          keyWeakness: "Limited advanced analytics",
          customerSentiment: 68,
          pricingPosition: "Mid-tier",
          productFeatureComparison: {
            "Analytics Depth": { competitor: 60, our: 75 },
            "User Experience": { competitor: 85, our: 82 },
            "Integration Options": { competitor: 72, our: 78 },
            "Customization": { competitor: 68, our: 85 }
          }
        },
        {
          id: 3,
          name: "Persona Insight",
          marketShare: 16,
          strengthScore: 91,
          weaknessScore: 38,
          overallThreatLevel: 74,
          primaryCompetitiveAdvantage: "Advanced personality modeling",
          keyWeakness: "Limited survey tools",
          customerSentiment: 81,
          pricingPosition: "Premium",
          productFeatureComparison: {
            "Analytics Depth": { competitor: 95, our: 75 },
            "User Experience": { competitor: 70, our: 82 },
            "Integration Options": { competitor: 65, our: 78 },
            "Customization": { competitor: 68, our: 85 }
          }
        }
      ];
      
      return demoCompetitors;
    }
    console.log(`Fetching competitor analysis for company ID: ${companyId}`);
    
    try {
      // Get the company details to determine industry using direct SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      const industry = company.industry || 'Technology';
      
      // Get survey responses for sentiment analysis with direct SQL
      const rawResponsesResult = await db.execute(sql`
        SELECT sr.*, s.title as survey_title 
        FROM survey_responses sr 
        JOIN surveys s ON sr.survey_id = s.id 
        WHERE sr.company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const rawResponses = Array.isArray(rawResponsesResult) ? rawResponsesResult : 
                           rawResponsesResult && typeof rawResponsesResult === 'object' ? [rawResponsesResult] : [];
      
      // Ensure we have an array to work with for consistency
      const responses = Array.isArray(rawResponses) ? rawResponses : [];
      
      // Extract competitor information from survey responses
      const competitorMap = new Map<string, {
        mentions: number,
        sentiment: number[],
        strengths: Set<string>,
        weaknesses: Set<string>,
        pricing: string | null,
        features: Record<string, number>
      }>();
      
      // We're skipping the businessContext lookup since the table doesn't exist yet
      
      // Extract competitor mentions from survey responses
      responses.forEach(response => {
        if (!response.responses || typeof response.responses !== 'object') return;
        
        const responseData = response.responses as Record<string, any>;
        
        // Look for competitor-related fields in the response
        const competitorFields = ['competitor', 'competitors', 'competitorComparison', 'marketComparison'];
        
        competitorFields.forEach(field => {
          if (!responseData[field]) return;
          
          // Handle array of competitor names
          if (Array.isArray(responseData[field])) {
            responseData[field].forEach((comp: any) => {
              const compName = typeof comp === 'string' ? comp : comp?.name || '';
              if (!compName) return;
              
              if (!competitorMap.has(compName)) {
                competitorMap.set(compName, {
                  mentions: 1,
                  sentiment: (comp?.sentiment && typeof comp.sentiment === 'number') ? [comp.sentiment] : [],
                  strengths: new Set(Array.isArray(comp?.strengths) ? comp.strengths : []),
                  weaknesses: new Set(Array.isArray(comp?.weaknesses) ? comp.weaknesses : []),
                  pricing: comp?.pricing || comp?.pricePoint || null,
                  features: {}
                });
              } else {
                const data = competitorMap.get(compName)!;
                data.mentions += 1;
                
                if (comp?.sentiment && typeof comp.sentiment === 'number') {
                  data.sentiment.push(comp.sentiment);
                }
                
                if (Array.isArray(comp?.strengths)) {
                  comp.strengths.forEach((s: string) => data.strengths.add(s));
                }
                
                if (Array.isArray(comp?.weaknesses)) {
                  comp.weaknesses.forEach((w: string) => data.weaknesses.add(w));
                }
              }
            });
          }
          // Handle object with competitor names as keys
          else if (typeof responseData[field] === 'object') {
            Object.entries(responseData[field]).forEach(([compName, compData]) => {
              if (!compName) return;
              
              if (!competitorMap.has(compName)) {
                competitorMap.set(compName, {
                  mentions: 1,
                  sentiment: (compData && typeof (compData as any).sentiment === 'number') ? [(compData as any).sentiment] : [],
                  strengths: new Set(),
                  weaknesses: new Set(),
                  pricing: (compData && typeof compData === 'object') ? (compData as any).pricing || null : null,
                  features: {}
                });
              } else {
                const data = competitorMap.get(compName)!;
                data.mentions += 1;
                
                if (compData && typeof compData === 'object') {
                  if (typeof (compData as any).sentiment === 'number') {
                    data.sentiment.push((compData as any).sentiment);
                  }
                  
                  if ((compData as any).strength) {
                    data.strengths.add((compData as any).strength);
                  }
                  
                  if ((compData as any).weakness) {
                    data.weaknesses.add((compData as any).weakness);
                  }
                  
                  if ((compData as any).features && typeof (compData as any).features === 'object') {
                    Object.entries((compData as any).features).forEach(([feature, score]) => {
                      if (typeof score === 'number') {
                        data.features[feature] = score;
                      }
                    });
                  }
                }
              }
            });
          }
        });
        
        // Also scan for mentions of competitors in free-text responses
        Object.entries(responseData).forEach(([field, value]) => {
          if (typeof value !== 'string' || competitorFields.includes(field)) return;
          
          // Extract potential competitor names from free text
          // This is simplified and would need NLP for real-world scenarios
          competitorMap.forEach((data, competitorName) => {
            if (value.toLowerCase().includes(competitorName.toLowerCase())) {
              data.mentions += 1;
            }
          });
        });
      });
      
      // If we found no competitors, extract from traits and demographics in survey responses
      if (competitorMap.size === 0) {
        console.log("No competitors found in direct response data, analyzing demographics and traits");
        
        // Extract competitor information from survey response traits and demographics
        responses.forEach(response => {
          try {
            // Parse traits to find potential competitor indications
            const traits = response.traits ? JSON.parse(response.traits) : [];
            if (Array.isArray(traits)) {
              // Higher openness to new products might indicate competitive shopping
              const opennessTrait = traits.find(t => 
                t.name && (t.name.toLowerCase().includes('openness') || 
                          t.name.toLowerCase().includes('curiosity')));
              
              if (opennessTrait && opennessTrait.score > 70) {
                // Determine competitor name based on industry
                const topCompetitor = industry === 'Healthcare' ? 'MedicalInsights' :
                                     industry === 'Finance' ? 'FinancialAnalytica' :
                                     industry === 'Retail' ? 'RetailIQ' :
                                     'TechInsights Pro';
                                     
                if (!competitorMap.has(topCompetitor)) {
                  competitorMap.set(topCompetitor, {
                    mentions: 1,
                    sentiment: [opennessTrait.score / 20], // Scale 0-5
                    strengths: new Set(['Industry-specific solutions']),
                    weaknesses: new Set(['Higher price point']),
                    pricing: 'Premium',
                    features: {'Analysis': 85}
                  });
                } else {
                  const data = competitorMap.get(topCompetitor)!;
                  data.mentions += 1;
                }
              }
            }
            
            // Parse demographics to identify potential competitor preferences
            const demographics = response.demographics ? JSON.parse(response.demographics) : {};
            if (demographics && demographics.profession) {
              // Different professions might prefer different competitors
              const profession = demographics.profession.toLowerCase();
              let competitor = null;
              
              if (profession.includes('tech') || profession.includes('developer') || profession.includes('engineer')) {
                competitor = 'TechMind';
              } else if (profession.includes('manager') || profession.includes('executive')) {
                competitor = 'ExecView';
              } else if (profession.includes('analyst') || profession.includes('researcher')) {
                competitor = 'AnalyticsPlus';
              }
              
              if (competitor && !competitorMap.has(competitor)) {
                competitorMap.set(competitor, {
                  mentions: 1,
                  sentiment: [3.5],
                  strengths: new Set(['Profession-specific features']),
                  weaknesses: new Set(['Limited cross-functional capabilities']),
                  pricing: 'Mid-range',
                  features: {'Specialization': 80}
                });
              } else if (competitor) {
                const data = competitorMap.get(competitor)!;
                data.mentions += 1;
              }
            }
          } catch (error) {
            console.error("Error parsing response data for competitors:", error);
          }
        });
        
        // If still no competitors found after analysis, add industry-appropriate ones
        if (competitorMap.size === 0) {
          console.log("No competitors identified from traits/demographics, using industry defaults");
          // Industry-specific default competitor
          const mainCompetitor = industry === 'Healthcare' ? 'MedicalMindInsight' :
                                industry === 'Finance' ? 'FinancialInsight' :
                                industry === 'Retail' ? 'RetailAnalytics' :
                                'TechInsights Pro';
          
          competitorMap.set(mainCompetitor, {
            mentions: 8,
            sentiment: [3.9],
            strengths: new Set(['Industry specialization', 'Comprehensive analytics']),
            weaknesses: new Set(['Higher price point', 'Complex implementation']),
            pricing: 'Premium',
            features: {
              'Analysis': 85,
              'Integration': 80,
              'Reporting': 75
            }
          });
          
          // Add a smaller competitor with fewer features but lower cost
          competitorMap.set('PersonaSmart', {
            mentions: 5,
            sentiment: [3.5],
            strengths: new Set(['Lower cost solution', 'Simple setup']),
            weaknesses: new Set(['Fewer features', 'Limited support']),
            pricing: 'Budget',
            features: {
              'Analysis': 60,
              'Integration': 60,
              'Reporting': 50
            }
          });
        }
      }
      
      // Convert the competitor map to the expected response format
      const competitors: CompetitorAnalysis[] = [];
      
      // Calculate total mentions for market share calculation
      const totalMentions = Array.from(competitorMap.values()).reduce((sum, data) => sum + data.mentions, 0);
      
      // Sort competitors by mention count (most mentioned first) and convert to analysis format
      Array.from(competitorMap.entries())
        .sort((a, b) => b[1].mentions - a[1].mentions)
        .slice(0, 5) // Limit to top 5 competitors
        .forEach(([name, data], index) => {
          // Calculate market share based on mentions
          const marketShare = totalMentions > 0 
            ? Math.round((data.mentions / totalMentions) * 100) 
            : Math.round(100 / competitorMap.size); // Equal distribution if no mentions
          
          // Calculate average sentiment score
          const averageSentiment = data.sentiment.length > 0
            ? data.sentiment.reduce((sum, score) => sum + score, 0) / data.sentiment.length
            : 3.7; // Default neutral-positive sentiment
          
          // Determine strength and weakness scores
          const strengthScore = 70 + Math.round(Math.random() * 20); // 70-90 range
          const weaknessScore = 50 + Math.round(Math.random() * 20); // 50-70 range
          
          // Get primary strengths and weaknesses
          const strengthsArray = Array.from(data.strengths);
          const weaknessesArray = Array.from(data.weaknesses);
          
          // If no strengths/weaknesses specified, use industry-specific defaults
          const primaryStrength = strengthsArray.length > 0 
            ? strengthsArray[0] 
            : this.getDefaultStrength(industry, name);
            
          const keyWeakness = weaknessesArray.length > 0 
            ? weaknessesArray[0] 
            : this.getDefaultWeakness(industry, name);
          
          // Calculate threat level based on sentiment, market share, and strength
          const overallThreatLevel = Math.round(
            (averageSentiment / 5) * 50 + // 20% based on customer sentiment (0-20)
            (marketShare / 100) * 30 + // 30% based on market share (0-30)
            (strengthScore / 100) * 50 // 50% based on strength score (35-45)
          );
          
          // Generate feature comparison based on provided data or defaults
          const featureComparison: Record<string, { competitor: number; our: number }> = {};
          
          // Use features from data if available, otherwise generate based on industry
          const features = Object.keys(data.features).length > 0 
            ? Object.keys(data.features) 
            : this.getIndustryFeatures(industry);
          
          features.slice(0, 4).forEach(feature => {
            // Use the score from data if available, otherwise generate
            const competitorScore = data.features[feature] || (70 + Math.floor(Math.random() * 21));
            
            // Our score is based on whether this is a strength for us
            const isOurStrength = Math.random() > 0.4; // 60% chance it's our strength
            const ourScore = isOurStrength 
              ? competitorScore + 5 + Math.floor(Math.random() * 11) // 5-15 points better
              : competitorScore - 5 - Math.floor(Math.random() * 11); // 5-15 points worse
            
            featureComparison[feature] = {
              competitor: Math.min(95, Math.max(55, competitorScore)),
              our: Math.min(95, Math.max(65, ourScore))
            };
          });
          
          // Determine pricing position
          const pricingPosition = data.pricing || 
            (index === 0 ? 'Premium' : index === competitorMap.size - 1 ? 'Budget' : 'Mid-range');
          
          // Add the competitor analysis
          competitors.push({
            name,
            marketShare,
            strengthScore,
            weaknessScore,
            overallThreatLevel,
            primaryCompetitiveAdvantage: primaryStrength,
            keyWeakness,
            customerSentiment: averageSentiment,
            pricingPosition,
            productFeatureComparison: featureComparison
          });
        });
      
      return competitors;
    } catch (error) {
      console.error(`Error fetching competitor analysis for company ${companyId}:`, error);
      throw error;
    }
  }
  
  // Helper function to get default strength based on industry and competitor name
  private getDefaultStrength(industry: string, competitorName: string): string {
    if (competitorName.toLowerCase().includes('tech') || 
        competitorName.toLowerCase().includes('ai')) {
      return 'Advanced technology features';
    } else if (competitorName.toLowerCase().includes('med') || 
               competitorName.toLowerCase().includes('health')) {
      return 'Healthcare industry expertise';
    } else if (competitorName.toLowerCase().includes('team') || 
               competitorName.toLowerCase().includes('collab')) {
      return 'Team collaboration features';
    } else if (competitorName.toLowerCase().includes('budget') || 
               competitorName.toLowerCase().includes('smart')) {
      return 'Cost-effective solution';
    } else {
      // Default for each industry
      switch (industry) {
        case 'Technology':
          return 'Innovation and cutting-edge features';
        case 'Healthcare':
          return 'HIPAA compliance and security';
        case 'Financial Services':
          return 'Finance-specific analytics';
        case 'Retail':
          return 'Customer behavior insights';
        default:
          return 'Industry-specific features';
      }
    }
  }
  
  // Helper function to get default weakness based on industry and competitor name
  private getDefaultWeakness(industry: string, competitorName: string): string {
    if (competitorName.toLowerCase().includes('premium') || 
        competitorName.toLowerCase().includes('pro')) {
      return 'Higher price point';
    } else if (competitorName.toLowerCase().includes('budget') || 
               competitorName.toLowerCase().includes('basic')) {
      return 'Limited feature set';
    } else if (competitorName.toLowerCase().includes('tech') || 
               competitorName.toLowerCase().includes('ai')) {
      return 'Complex user interface';
    } else {
      // Default for each industry
      switch (industry) {
        case 'Technology':
          return 'Limited customization options';
        case 'Healthcare':
          return 'Complex deployment process';
        case 'Financial Services':
          return 'Limited integration options';
        case 'Retail':
          return 'Weaker predictive analytics';
        default:
          return 'Limited customer support';
      }
    }
  }
  
  // Helper function to get industry-specific features
  private getIndustryFeatures(industry: string): string[] {
    // Return relevant features for each industry
    switch (industry) {
      case 'Technology':
        return ['AI Analysis', 'Team Integration', 'Custom Reporting', 'Data Visualization', 
                'API Access', 'Developer Tools'];
      case 'Healthcare':
        return ['Healthcare Specialization', 'HIPAA Compliance', 'Patient Insights', 
                'Team Integration', 'Data Security', 'Clinical Validation'];
      case 'Financial Services':
        return ['Financial Industry Knowledge', 'Compliance Features', 'Risk Assessment', 
                'Client Matching', 'Team Integration', 'Data Security'];
      case 'Retail':
        return ['Customer Insights', 'Sales Team Optimization', 'Customer Service Training', 
                'Team Integration', 'Retention Analysis', 'Engagement Metrics'];
      default:
        return ['AI Analysis', 'Team Integration', 'Custom Reporting', 'Data Visualization', 
                'User Experience', 'Customer Support'];
    }
  }
  
  async getMarketFitAnalysis(companyId: number, productId: string): Promise<any> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getMarketFitAnalysis called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning demo market fit analysis for DEMO company ID: ${companyId}`);
      
      // Create hardcoded demo market fit data
      const demoMarketFit = {
        productId,
        productName: productId === "product1" ? "PersonalysisPro Core" : "TeamInsight Dashboard",
        overallFitScore: 82.5,
        problemSolutionFit: 86,
        productMarketFit: 79,
        targetMarketSize: {
          total: 8500000000, // $8.5B
          addressable: 2100000000, // $2.1B
          serviceable: 650000000 // $650M
        },
        customerNeedAlignment: 88,
        valuePropositionClarity: 84,
        priceToValuePerception: 78,
        productDifferentiation: 92,
        competitiveAdvantage: [
          "Proprietary personality assessment algorithms",
          "AI-driven team compatibility matching",
          "Real-time collaborative insights",
          "Industry-specific benchmarking"
        ],
        marketChallenges: [
          "Privacy concerns around personality data",
          "Integration with existing HR systems",
          "Educating market on scientific validity",
          "Competitive pricing pressure"
        ],
        customerPainPoints: [
          {
            painPoint: "Ineffective team composition",
            severity: 87,
            frequency: 92,
            addressedByProduct: 95
          },
          {
            painPoint: "Poor understanding of customer needs",
            severity: 85,
            frequency: 78,
            addressedByProduct: 88
          },
          {
            painPoint: "Hiring mismatches",
            severity: 92,
            frequency: 75,
            addressedByProduct: 91
          },
          {
            painPoint: "Unclear pathways for employee development",
            severity: 79,
            frequency: 82,
            addressedByProduct: 85
          }
        ],
        recommendations: [
          "Enhance API integrations with popular HR platforms",
          "Develop industry-specific assessment templates",
          "Create ROI calculator for marketing materials",
          "Add team conflict resolution module",
          "Expand educational content on personality science"
        ]
      };
      
      return demoMarketFit;
    }
    console.log(`Fetching market fit for company ID: ${companyId}, product ID: ${productId}`);
    
    try {
      // Get the company details using direct SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      const industry = company.industry || 'Technology';
      
      // Skip business context lookup since the table doesn't exist yet
      // Use company details directly
      const context = null;
      
      // Even without business context, analyze survey data for market fit insights
      console.log(`No business context table, analyzing survey data directly for company ${companyId}`);
      
      // Get survey responses for this company using direct SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
      
      // Calculate product-market fit score based on survey responses mentioning this product
      const productMentions = responses.filter(r => {
        if (r.responses && typeof r.responses === 'object') {
          const responsesValues = Object.values(r.responses);
          // Use default product names since we don't have context
          const productName = `Product ${productId}`;
          
          return responsesValues.some(value => 
            typeof value === 'string' && (
              value.toLowerCase().includes(productName.toLowerCase())
            )
          );
        }
        return false;
      });
      
      // Calculate overall fit score (60-95 range)
      // Base on percentage of positive sentiment in product mentions
      let overallFitScore = 75; // Default
      if (productMentions.length > 0) {
        const positiveResponses = productMentions.filter(r => {
          if (r.satisfactionScore && r.satisfactionScore > 7) {
            return true;
          }
          return false;
        }).length;
        
        const positivePercentage = productMentions.length > 0 
          ? (positiveResponses / productMentions.length) 
          : 0.5;
        
        overallFitScore = Math.round(60 + (positivePercentage * 35));
      }
      
      // Define market segments
      const segments = [
        'Enterprise Customers',
        'Mid-Market',
        'SMB', 
        'Startups',
        'Government',
        'Education'
      ];
      
      // Calculate segment-specific fit scores
      const segmentFitScores = segments.map(segment => {
        // For now, use random variation around the overall score
        const variation = Math.floor(Math.random() * 16) - 8; // -8 to +7
        const score = Math.min(95, Math.max(60, overallFitScore + variation));
        const potential = Math.min(95, score + Math.floor(Math.random() * 10) + 2);
        
        return {
          segmentName: segment,
          score,
          potential
        };
      });
      
      // Sort by score (highest first) and take top 3
      segmentFitScores.sort((a, b) => b.score - a.score);
      const topSegments = segmentFitScores.slice(0, 3);
      
      // Calculate trait alignments based on survey responses
      const traitAlignments = [];
      const traitMap = new Map();
      
      responses.forEach(response => {
        if (response.traits && Array.isArray(response.traits)) {
          response.traits.forEach((trait: PersonalityTrait) => {
            if (trait.name && trait.score) {
              if (traitMap.has(trait.name)) {
                traitMap.set(trait.name, traitMap.get(trait.name) + trait.score);
              } else {
                traitMap.set(trait.name, trait.score);
              }
            }
          });
        }
      });
      
      // Get top 5 traits
      Array.from(traitMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .forEach(([trait, score]) => {
          traitAlignments.push({
            trait,
            alignment: Math.min(95, Math.floor((score / responses.length) * 10))
          });
        });
      
      // If no traits found, use defaults
      if (traitAlignments.length === 0) {
        traitAlignments.push(
          { trait: 'Analytical', alignment: 85 },
          { trait: 'Innovative', alignment: 80 },
          { trait: 'Deliberative', alignment: 75 },
          { trait: 'Collaborative', alignment: 70 },
          { trait: 'Detail-Oriented', alignment: 65 }
        );
      }
      
      // Use the industry we already retrieved at the beginning of the method
      // No need to query for the company again
      const marketSizes = {
        'Technology': { total: 5000000000, addressable: 800000000, serviceable: 150000000 },
        'Healthcare': { total: 8000000000, addressable: 1200000000, serviceable: 200000000 },
        'Financial Services': { total: 10000000000, addressable: 1500000000, serviceable: 250000000 },
        'Retail': { total: 6000000000, addressable: 900000000, serviceable: 180000000 },
        'Manufacturing': { total: 7000000000, addressable: 1000000000, serviceable: 190000000 },
        'Education': { total: 4000000000, addressable: 600000000, serviceable: 120000000 }
      };
      
      // Use industry-specific market size or default to Technology
      const marketSizePotential = marketSizes[industry] || marketSizes['Technology'];
      
      // Return complete market fit analysis
      return {
        productId,
        productName: `Product ${productId}`,
        productDescription: '',
        overallFitScore,
        segmentFitScores: topSegments,
        traitAlignments: traitAlignments.slice(0, 3),
        marketSizePotential,
        industry: industry,
        category: 'Software'
      };
    } catch (error) {
      console.error(`Error fetching market fit analysis for company ${companyId}, product ${productId}:`, error);
      throw error;
    }
  }
  
  async getCustomerSegments(companyId: number): Promise<any> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getCustomerSegments called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning demo customer segments for DEMO company ID: ${companyId}`);
      
      // Create hardcoded demo customer segments
      const demoSegments = [
        {
          name: "Strategic Innovators",
          size: 1250000,
          percentageOfCustomers: 28.5,
          growthRate: 12.8,
          dominantTraits: [
            { name: "Openness", score: 87 },
            { name: "Extraversion", score: 72 },
            { name: "Conscientiousness", score: 81 }
          ],
          keyDemographics: {
            ageGroups: {
              "18-24": 5,
              "25-34": 37,
              "35-44": 42,
              "45-54": 12,
              "55+": 4
            },
            genderDistribution: {
              "Male": 68,
              "Female": 31,
              "Non-binary/Other": 1
            },
            incomeRange: {
              "Under $50K": 8,
              "$50K-$100K": 34,
              "$100K-$150K": 42,
              "Over $150K": 16
            },
            education: {
              "High School": 2,
              "Some College": 18,
              "Bachelor's": 52,
              "Master's or higher": 28
            },
            location: {
              "Urban": 68,
              "Suburban": 27,
              "Rural": 5
            }
          },
          purchasingBehaviors: [
            "Research-driven decisions",
            "Prioritize innovation",
            "Early technology adopters",
            "Value quality over price"
          ],
          productPreferences: [
            "Advanced analytics features",
            "Integration capabilities",
            "Customization options",
            "Mobile access"
          ],
          communicationChannels: {
            "Email": 85,
            "LinkedIn": 72,
            "Industry conferences": 68,
            "Webinars": 62,
            "Twitter": 48
          },
          customerLifetimeValue: 12500,
          acquisitionCost: 2800,
          targetFit: 92
        },
        {
          name: "Operational Optimizers",
          size: 980000,
          percentageOfCustomers: 22.3,
          growthRate: 8.5,
          dominantTraits: [
            { name: "Conscientiousness", score: 92 },
            { name: "Neuroticism", score: 32 },
            { name: "Agreeableness", score: 76 }
          ],
          keyDemographics: {
            ageGroups: {
              "18-24": 3,
              "25-34": 22,
              "35-44": 38,
              "45-54": 28,
              "55+": 9
            },
            genderDistribution: {
              "Male": 54,
              "Female": 45,
              "Non-binary/Other": 1
            },
            incomeRange: {
              "Under $50K": 12,
              "$50K-$100K": 46,
              "$100K-$150K": 32,
              "Over $150K": 10
            },
            education: {
              "High School": 8,
              "Some College": 25,
              "Bachelor's": 48,
              "Master's or higher": 19
            },
            location: {
              "Urban": 45,
              "Suburban": 42,
              "Rural": 13
            }
          },
          purchasingBehaviors: [
            "Process-oriented decisions",
            "Value stability and reliability",
            "Cost-conscious",
            "Seek proven solutions"
          ],
          productPreferences: [
            "Reporting tools",
            "Process automation",
            "Reliability metrics",
            "Training resources"
          ],
          communicationChannels: {
            "Email": 92,
            "Industry websites": 65,
            "Webinars": 58,
            "Trade publications": 42,
            "Facebook": 28
          },
          customerLifetimeValue: 9800,
          acquisitionCost: 1950,
          targetFit: 85
        },
        {
          name: "Growth-Focused Leaders",
          size: 650000,
          percentageOfCustomers: 14.8,
          growthRate: 17.2,
          dominantTraits: [
            { name: "Extraversion", score: 88 },
            { name: "Openness", score: 76 },
            { name: "Agreeableness", score: 62 }
          ],
          keyDemographics: {
            ageGroups: {
              "18-24": 2,
              "25-34": 31,
              "35-44": 45,
              "45-54": 18,
              "55+": 4
            },
            genderDistribution: {
              "Male": 61,
              "Female": 38,
              "Non-binary/Other": 1
            },
            incomeRange: {
              "Under $50K": 5,
              "$50K-$100K": 28,
              "$100K-$150K": 42,
              "Over $150K": 25
            },
            education: {
              "High School": 1,
              "Some College": 12,
              "Bachelor's": 58,
              "Master's or higher": 29
            },
            location: {
              "Urban": 72,
              "Suburban": 24,
              "Rural": 4
            }
          },
          purchasingBehaviors: [
            "Results-driven decisions",
            "Aggressive growth focus",
            "Competitive advantage seekers",
            "Performance-based evaluation"
          ],
          productPreferences: [
            "Predictive analytics",
            "Competitive intelligence",
            "Real-time data access",
            "Executive dashboards"
          ],
          communicationChannels: {
            "Email": 78,
            "LinkedIn": 85,
            "Executive events": 72,
            "Industry conferences": 68,
            "Direct outreach": 61
          },
          customerLifetimeValue: 15200,
          acquisitionCost: 3500,
          targetFit: 88
        }
      ];
      
      return demoSegments;
    }
    console.log(`Fetching customer segments for company ID: ${companyId}`);
    
    try {
      // Get all survey responses for this company using direct SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
      
      if (!responses.length) {
        console.log(`No survey responses found for company ${companyId}`);
        return [];
      }
      
      // First, analyze demographic data to identify segments
      const demographicData = {
        ages: {},
        genders: {},
        locations: {},
        incomes: {},
        interests: {}
      };
      
      responses.forEach(response => {
        if (response.demographics && typeof response.demographics === 'object') {
          // Count ages by range
          const age = response.demographics.age;
          if (age) {
            const ageRange = 
              age < 25 ? 'Under 25' :
              age < 35 ? '25-34' :
              age < 45 ? '35-44' :
              age < 55 ? '45-54' :
              age < 65 ? '55-64' : '65+';
            
            demographicData.ages[ageRange] = (demographicData.ages[ageRange] || 0) + 1;
          }
          
          // Count genders
          const gender = response.demographics.gender;
          if (gender) {
            demographicData.genders[gender] = (demographicData.genders[gender] || 0) + 1;
          }
          
          // Count locations
          const location = response.demographics.location;
          if (location) {
            demographicData.locations[location] = (demographicData.locations[location] || 0) + 1;
          }
          
          // Count income ranges
          const income = response.demographics.income;
          if (income) {
            demographicData.incomes[income] = (demographicData.incomes[income] || 0) + 1;
          }
          
          // Count interests
          const interests = response.demographics.interests;
          if (interests && Array.isArray(interests)) {
            interests.forEach(interest => {
              demographicData.interests[interest] = (demographicData.interests[interest] || 0) + 1;
            });
          }
        }
      });
      
      // Next, cluster responses based on dominant personality traits
      const traitClusters = {};
      
      responses.forEach(response => {
        if (response.traits && Array.isArray(response.traits)) {
          // Find the dominant trait for this response
          let dominantTrait = null;
          let highestScore = 0;
          
          response.traits.forEach((trait: PersonalityTrait) => {
            if (trait.score > highestScore) {
              highestScore = trait.score;
              dominantTrait = trait.name;
            }
          });
          
          if (dominantTrait) {
            if (!traitClusters[dominantTrait]) {
              traitClusters[dominantTrait] = {
                count: 0,
                traits: {},
                demographics: {
                  ages: {},
                  genders: {},
                  locations: {},
                  incomes: {},
                  interests: {}
                },
                responses: []
              };
            }
            
            // Increment count for this cluster
            traitClusters[dominantTrait].count++;
            
            // Add all traits from this response to the cluster
            response.traits.forEach((trait: PersonalityTrait) => {
              if (!traitClusters[dominantTrait].traits[trait.name]) {
                traitClusters[dominantTrait].traits[trait.name] = {
                  total: 0,
                  count: 0
                };
              }
              
              traitClusters[dominantTrait].traits[trait.name].total += trait.score;
              traitClusters[dominantTrait].traits[trait.name].count++;
            });
            
            // Add demographic data to this cluster
            if (response.demographics && typeof response.demographics === 'object') {
              const demographics = response.demographics;
              
              // Age
              if (demographics.age) {
                const ageRange = 
                  demographics.age < 25 ? 'Under 25' :
                  demographics.age < 35 ? '25-34' :
                  demographics.age < 45 ? '35-44' :
                  demographics.age < 55 ? '45-54' :
                  demographics.age < 65 ? '55-64' : '65+';
                
                traitClusters[dominantTrait].demographics.ages[ageRange] = 
                  (traitClusters[dominantTrait].demographics.ages[ageRange] || 0) + 1;
              }
              
              // Gender
              if (demographics.gender) {
                traitClusters[dominantTrait].demographics.genders[demographics.gender] = 
                  (traitClusters[dominantTrait].demographics.genders[demographics.gender] || 0) + 1;
              }
              
              // Location
              if (demographics.location) {
                traitClusters[dominantTrait].demographics.locations[demographics.location] = 
                  (traitClusters[dominantTrait].demographics.locations[demographics.location] || 0) + 1;
              }
              
              // Income
              if (demographics.income) {
                traitClusters[dominantTrait].demographics.incomes[demographics.income] = 
                  (traitClusters[dominantTrait].demographics.incomes[demographics.income] || 0) + 1;
              }
              
              // Interests
              if (demographics.interests && Array.isArray(demographics.interests)) {
                demographics.interests.forEach(interest => {
                  traitClusters[dominantTrait].demographics.interests[interest] = 
                    (traitClusters[dominantTrait].demographics.interests[interest] || 0) + 1;
                });
              }
            }
            
            // Add response to this cluster for further analysis
            traitClusters[dominantTrait].responses.push(response);
          }
        }
      });
      
      // Generate customer segments from the clusters
      const totalResponses = responses.length;
      const segments = [];
      
      // Sort clusters by size (largest first)
      const sortedClusters = Object.entries(traitClusters)
        .sort((a, b) => b[1].count - a[1].count);
      
      // Take the top 3 clusters as our primary segments
      const topClusters = sortedClusters.slice(0, 3);
      
      topClusters.forEach(([traitName, cluster], index) => {
        // Calculate dominant traits for this segment
        const dominantTraits = Object.entries(cluster.traits)
          .map(([trait, data]) => ({
            trait,
            score: Math.round(data.total / data.count)
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 3);
        
        // Calculate demographic summary
        // Find most common age range
        const ageEntries = Object.entries(cluster.demographics.ages);
        const mostCommonAge = ageEntries.length > 0 
          ? ageEntries.sort((a, b) => b[1] - a[1])[0][0]
          : 'Unknown';
        
        // Calculate average age (approximate middle of range)
        let averageAge;
        switch(mostCommonAge) {
          case 'Under 25': averageAge = 22; break;
          case '25-34': averageAge = 30; break;
          case '35-44': averageAge = 40; break;
          case '45-54': averageAge = 50; break;
          case '55-64': averageAge = 60; break;
          case '65+': averageAge = 70; break;
          default: averageAge = 35;
        }
        
        // Find dominant gender
        const genderEntries = Object.entries(cluster.demographics.genders);
        const dominantGender = genderEntries.length > 0
          ? genderEntries.sort((a, b) => b[1] - a[1])[0][0]
          : 'Mixed';
        
        // Find top income range
        const incomeEntries = Object.entries(cluster.demographics.incomes);
        const topIncome = incomeEntries.length > 0
          ? incomeEntries.sort((a, b) => b[1] - a[1])[0][0]
          : '$50K-$100K';
        
        // Find top locations
        const locationEntries = Object.entries(cluster.demographics.locations);
        const topLocations = locationEntries.length > 0
          ? locationEntries
              .sort((a, b) => b[1] - a[1])
              .slice(0, 3)
              .map(entry => entry[0])
          : ['New York', 'Chicago', 'Los Angeles'];
        
        // Find top interests
        const interestEntries = Object.entries(cluster.demographics.interests);
        const topInterests = interestEntries.length > 0
          ? interestEntries
              .sort((a, b) => b[1] - a[1])
              .slice(0, 3)
              .map(entry => entry[0])
          : ['Technology', 'Business', 'Travel'];
        
        // Generate segment size and percentage
        const size = Math.floor(cluster.count * (100 + Math.random() * 50));
        const percentOfTotal = Math.round((cluster.count / totalResponses) * 100);
        
        // Generate purchase behavior based on response patterns
        // This is simplified and would be more sophisticated in a real system
        const averageOrderValue = 5000 + (Math.random() * 20000);
        const purchaseFrequency = 1 + (Math.random() * 2);
        const loyaltyScore = 7 + (Math.random() * 3);
        
        // Create segment name based on dominant traits and demographics
        let name;
        if (dominantTraits[0].trait === 'Analytical' || dominantTraits[0].trait === 'Deliberative') {
          name = 'Strategic Decision Makers';
        } else if (dominantTraits[0].trait === 'Empathetic' || dominantTraits[0].trait === 'Collaborative') {
          name = 'Team-Focused Professionals';
        } else if (dominantTraits[0].trait === 'Innovative' || dominantTraits[0].trait === 'Creative') {
          name = 'Innovation Leaders';
        } else if (dominantTraits[0].trait === 'Detail-Oriented' || dominantTraits[0].trait === 'Organized') {
          name = 'Process-Driven Managers';
        } else {
          name = `${dominantTraits[0].trait} Professionals`;
        }
        
        // Add demographic qualifier if strong pattern exists
        if (dominantGender !== 'Mixed' && genderEntries.length > 0 && genderEntries[0][1] > cluster.count * 0.7) {
          if (dominantGender === 'Female') {
            name = `Female ${name}`;
          } else if (dominantGender === 'Male') {
            name = `Male ${name}`;
          }
        }
        
        // Add segment to results
        segments.push({
          id: `seg-${index + 1}`,
          name,
          size,
          percentOfTotal,
          dominantTraits,
          demographicSummary: {
            averageAge,
            dominantGender,
            averageIncome: topIncome,
            topLocations,
            topInterests
          },
          purchaseBehavior: {
            averageOrderValue: Math.round(averageOrderValue),
            purchaseFrequency: Math.round(purchaseFrequency * 10) / 10,
            loyaltyScore: Math.round(loyaltyScore * 10) / 10
          }
        });
      });
      
      return segments;
    } catch (error) {
      console.error(`Error fetching customer segments for company ${companyId}:`, error);
      throw error;
    }
  }
  
  async getProductFeaturePriorities(companyId: number): Promise<ProductFeaturePriority[]> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getProductFeaturePriorities called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning hardcoded demo product features for DEMO company ID: ${companyId}`);
      // Hardcoded demo features data instead of using require
      const demoFeatures = [
        {
          featureId: "feat-1",
          featureName: "AI-Powered Recommendations",
          description: "Machine learning algorithm that provides personalized product recommendations based on personality traits",
          overallAppeal: 87.3,
          segmentAppeal: {
            "Value Seeker": 72.1,
            "Premium Buyer": 93.5,
            "Early Adopter": 96.2,
            "Brand Loyal": 79.8
          },
          developmentCost: 85000,
          timeToImplement: 3, // months
          roi: 3.7, // 3.7x return
          alignedTraits: [
            { trait: "Analytical Thinking", strength: 92 },
            { trait: "Decision Style", strength: 88 },
            { trait: "Value Consciousness", strength: 79 }
          ]
        },
        {
          featureId: "feat-2",
          featureName: "Interactive Insight Dashboard",
          description: "Visual dashboard with interactive elements for exploring personality insights and product correlations",
          overallAppeal: 81.6,
          segmentAppeal: {
            "Value Seeker": 68.9,
            "Premium Buyer": 89.2,
            "Early Adopter": 90.3,
            "Brand Loyal": 75.1
          },
          developmentCost: 65000,
          timeToImplement: 2, // months
          roi: 2.9, // 2.9x return
          alignedTraits: [
            { trait: "Analytical Thinking", strength: 85 },
            { trait: "Creative Problem Solving", strength: 91 },
            { trait: "Risk Tolerance", strength: 74 }
          ]
        },
        {
          featureId: "feat-3",
          featureName: "CRM Integration API",
          description: "API for seamless integration with popular CRM systems to enrich customer profiles",
          overallAppeal: 79.4,
          segmentAppeal: {
            "Value Seeker": 85.7,
            "Premium Buyer": 87.9,
            "Early Adopter": 78.1,
            "Brand Loyal": 69.5
          },
          developmentCost: 55000,
          timeToImplement: 2.5, // months
          roi: 3.2, // 3.2x return
          alignedTraits: [
            { trait: "Value Consciousness", strength: 88 },
            { trait: "Conscientiousness", strength: 92 },
            { trait: "Decision Style", strength: 83 }
          ]
        },
        {
          featureId: "feat-4",
          featureName: "Real-time Market Trend Analysis",
          description: "Live analysis of market trends correlated with personality segments for predictive insights",
          overallAppeal: 84.2,
          segmentAppeal: {
            "Value Seeker": 71.3,
            "Premium Buyer": 91.7,
            "Early Adopter": 94.6,
            "Brand Loyal": 71.9
          },
          developmentCost: 95000,
          timeToImplement: 4, // months
          roi: 3.1, // 3.1x return
          alignedTraits: [
            { trait: "Risk Tolerance", strength: 89 },
            { trait: "Analytical Thinking", strength: 94 },
            { trait: "Creative Problem Solving", strength: 81 }
          ]
        },
        {
          featureId: "feat-5",
          featureName: "Focus Group Simulator",
          description: "AI-driven tool to simulate focus group reactions to product concepts based on personality profiles",
          overallAppeal: 82.9,
          segmentAppeal: {
            "Value Seeker": 67.5,
            "Premium Buyer": 88.4,
            "Early Adopter": 95.1,
            "Brand Loyal": 70.3
          },
          developmentCost: 75000,
          timeToImplement: 3.5, // months
          roi: 2.8, // 2.8x return
          alignedTraits: [
            { trait: "Creative Problem Solving", strength: 93 },
            { trait: "Conscientiousness", strength: 79 },
            { trait: "Value Consciousness", strength: 85 }
          ]
        }
      ];
      return demoFeatures;
    }
    console.log(`Fetching feature priorities for company ID: ${companyId}`);
    
    try {
      // Get company info directly with SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      // Get survey responses for this company with SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
                        
      // Get customer segments for this company - we need this for segment appeal calculation
      const segmentsResult = await this.getCustomerSegments(companyId);
      
      // If no responses found, return empty array
      if (!responses.length) {
        console.log(`No survey responses found for company ${companyId}`);
        return [];
      }
      
      // Define default product features based on company industry
      const productFeatures = [];
      const industry = company.industry || 'Technology';
      
      // Define default features based on industry
      let features = [];
      if (industry === 'Technology') {
        features = [
          'AI-Powered Analytics', 
          'Team Collaboration', 
          'Custom Reporting',
          'Data Visualization',
          'Integration Capabilities'
        ];
      } else if (industry === 'Healthcare') {
        features = [
          'HIPAA Compliance',
          'Patient Data Integration',
          'Clinical Decision Support',
          'Healthcare Analytics',
          'Team Coordination'
        ];
      } else {
        features = [
          'AI-Powered Insights',
          'Interactive Dashboards',
          'Team Compatibility Analysis',
          'Customizable Reports',
          'API Integration'
        ];
      }
      
      // Add features to the product features array
      features.forEach(feature => {
        if (!productFeatures.includes(feature)) {
          productFeatures.push(feature);
        }
      });
      
      // Add some default product features if none found
      if (productFeatures.length === 0) {
        productFeatures.push(
          'AI-Powered Insights',
          'Interactive Dashboards',
          'Team Compatibility Analysis',
          'Customizable Reports',
          'API Integration',
          'Mobile App Access'
        );
      }
      
      // Generate unique feature IDs
      const featurePriorities = productFeatures.map((feature, index) => {
        const featureId = `feat-${index + 1}`;
        
        // Generate descriptions based on feature name
        let description = '';
        if (feature.toLowerCase().includes('ai') || feature.toLowerCase().includes('insight')) {
          description = 'Machine learning algorithms that analyze survey responses to identify patterns and provide deeper insights.';
        } else if (feature.toLowerCase().includes('dashboard') || feature.toLowerCase().includes('visual')) {
          description = 'Customizable visualizations that allow users to explore personality data from multiple angles.';
        } else if (feature.toLowerCase().includes('team') || feature.toLowerCase().includes('compatibility')) {
          description = 'Sophisticated analysis of team member traits to identify optimal working relationships and potential conflict areas.';
        } else if (feature.toLowerCase().includes('report')) {
          description = 'Flexible reporting system that generates detailed PDF and interactive web reports for sharing insights.';
        } else if (feature.toLowerCase().includes('api') || feature.toLowerCase().includes('integration')) {
          description = 'Robust API endpoints that allow seamless integration with other HR and productivity tools.';
        } else if (feature.toLowerCase().includes('mobile') || feature.toLowerCase().includes('app')) {
          description = 'Native mobile application for on-the-go access to personality insights and team management.';
        } else {
          description = `Advanced functionality for ${feature.toLowerCase()} to enhance user experience and provide valuable insights.`;
        }
        
        // Calculate appeal scores based on related terms in survey responses
        let mentionCount = 0;
        let positiveScore = 0;
        
        // First, count mentions and sentiment for this feature
        responses.forEach(response => {
          if (response.responses && typeof response.responses === 'object') {
            const responsesValues = Object.values(response.responses);
            
            // Check if any response mentions this feature
            const hasMention = responsesValues.some(value => 
              typeof value === 'string' && 
              value.toLowerCase().includes(feature.toLowerCase())
            );
            
            if (hasMention) {
              mentionCount++;
              
              // Use satisfaction score as sentiment proxy
              if (response.satisfactionScore) {
                positiveScore += response.satisfactionScore;
              }
            }
          }
        });
        
        // Calculate overall appeal (if mentioned, base on sentiment, otherwise random)
        let overallAppeal = 75 + Math.floor(Math.random() * 20);
        if (mentionCount > 0) {
          const avgSentiment = positiveScore / mentionCount;
          overallAppeal = Math.round((avgSentiment / 10) * 100);
          
          // Ensure appeal is in reasonable range
          overallAppeal = Math.min(95, Math.max(60, overallAppeal));
        }
        
        // Generate segment appeal based on segments
        const segmentAppeal = {};
        const segments = Array.isArray(segmentsResult) ? segmentsResult : [];
        segments.forEach(segment => {
          const segmentName = segment.name;
          
          // Add slight variation to overall appeal for each segment
          const variation = Math.floor(Math.random() * 16) - 8; // -8 to +7
          const appeal = Math.min(95, Math.max(60, overallAppeal + variation));
          
          segmentAppeal[segmentName] = appeal;
        });
        
        // Generate aligned traits based on survey responses
        const traitCounts = {};
        responses.forEach(response => {
          if (
            response.responses && 
            Object.values(response.responses).some(value => 
              typeof value === 'string' && 
              value.toLowerCase().includes(feature.toLowerCase())
            ) &&
            response.traits && 
            Array.isArray(response.traits)
          ) {
            // Count trait occurrences for responses mentioning this feature
            response.traits.forEach((trait: PersonalityTrait) => {
              if (trait.name && trait.score && trait.score > 70) {
                traitCounts[trait.name] = (traitCounts[trait.name] || 0) + 1;
              }
            });
          }
        });
        
        // Select top traits aligned with this feature
        const alignedTraits = Object.entries(traitCounts)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3)
          .map(([trait, count]) => ({
            trait,
            strength: 80 + Math.floor(Math.random() * 16) // 80-95 range
          }));
        
        // If no traits found, assign default traits based on feature name
        if (alignedTraits.length === 0) {
          if (feature.toLowerCase().includes('ai') || feature.toLowerCase().includes('insight')) {
            alignedTraits.push(
              { trait: 'Analytical', strength: 95 },
              { trait: 'Technical', strength: 90 }
            );
          } else if (feature.toLowerCase().includes('dashboard') || feature.toLowerCase().includes('visual')) {
            alignedTraits.push(
              { trait: 'Visual', strength: 92 },
              { trait: 'Detail-Oriented', strength: 88 }
            );
          } else if (feature.toLowerCase().includes('team') || feature.toLowerCase().includes('compatibility')) {
            alignedTraits.push(
              { trait: 'Collaborative', strength: 93 },
              { trait: 'Empathetic', strength: 91 }
            );
          } else {
            alignedTraits.push(
              { trait: 'Innovative', strength: 89 },
              { trait: 'Practical', strength: 85 }
            );
          }
        }
        
        // Calculate development metrics based on feature type
        let developmentCost = 30000 + Math.floor(Math.random() * 50000);
        let timeToImplement = 4 + Math.floor(Math.random() * 12);
        let roi = 2 + Math.random() * 3;
        
        // Adjust metrics based on feature complexity
        if (feature.toLowerCase().includes('ai') || feature.toLowerCase().includes('algorithm')) {
          developmentCost *= 1.5;
          timeToImplement *= 1.3;
          roi *= 1.2; // Higher ROI for AI features
        } else if (feature.toLowerCase().includes('integration') || feature.toLowerCase().includes('api')) {
          developmentCost *= 1.2;
          timeToImplement *= 1.1;
        } else if (feature.toLowerCase().includes('mobile') || feature.toLowerCase().includes('app')) {
          developmentCost *= 1.4;
          timeToImplement *= 1.2;
        }
        
        // Round metrics to reasonable values
        developmentCost = Math.round(developmentCost / 1000) * 1000;
        timeToImplement = Math.round(timeToImplement);
        roi = Math.round(roi * 10) / 10;
        
        return {
          featureId,
          featureName: feature,
          description,
          overallAppeal,
          segmentAppeal,
          developmentCost,
          timeToImplement,
          roi,
          alignedTraits
        };
      });
      
      // Sort by overall appeal (highest first)
      featurePriorities.sort((a, b) => b.overallAppeal - a.overallAppeal);
      
      return featurePriorities;
    } catch (error) {
      console.error(`Error fetching product feature priorities for company ${companyId}:`, error);
      throw error;
    }
  }
  
  async getPricingStrategies(companyId: number): Promise<PricingStrategy[]> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getPricingStrategies called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning hardcoded demo pricing strategies for DEMO company ID: ${companyId}`);
      // Hardcoded demo pricing strategies data instead of using require
      const demoPricingStrategies = [
        {
          strategyId: "price-1",
          name: "Value-Based Tiered Model",
          optimalPrice: 199.99,
          priceElasticity: -1.2, // Price elasticity of demand (negative indicates elastic demand)
          tiers: [
            {
              tierName: "Essential",
              price: 99.99,
              features: ["Basic Personality Scoring", "Simple Demographics", "Standard Reports"],
              targetSegments: ["Value Seeker"],
              estimatedAdoption: 45.3,
              estimatedRevenue: 452775.37
            },
            {
              tierName: "Professional",
              price: 199.99,
              features: ["Advanced Trait Analysis", "Product Recommendations", "Interactive Dashboard", "API Access"],
              targetSegments: ["Premium Buyer", "Brand Loyal"],
              estimatedAdoption: 32.8,
              estimatedRevenue: 655967.2
            },
            {
              tierName: "Enterprise",
              price: 499.99,
              features: ["Full Market Intelligence", "Gender Stereotypes", "AI Simulations", "White Labeling", "Dedicated Support"],
              targetSegments: ["Early Adopter", "Premium Buyer"],
              estimatedAdoption: 21.9,
              estimatedRevenue: 1094978.1
            }
          ],
          willingness: [
            { segment: "Value Seeker", price: 125.43 },
            { segment: "Premium Buyer", price: 349.87 },
            { segment: "Early Adopter", price: 487.65 },
            { segment: "Brand Loyal", price: 215.29 }
          ]
        },
        {
          strategyId: "price-2",
          name: "Usage-Based Model",
          optimalPrice: 0.35, // Per survey response
          priceElasticity: -1.7,
          tiers: [
            {
              tierName: "Pay-As-You-Go",
              price: 0.45, // Per survey response
              features: ["Full Platform Access", "Per-Survey Pricing"],
              targetSegments: ["Value Seeker", "Early Adopter"],
              estimatedAdoption: 38.7,
              estimatedRevenue: 348300
            },
            {
              tierName: "Volume Bundle",
              price: 0.35, // Per survey response
              features: ["Full Platform Access", "Bulk Discount", "Advanced Analytics"],
              targetSegments: ["Premium Buyer", "Brand Loyal"],
              estimatedAdoption: 42.1,
              estimatedRevenue: 736750
            },
            {
              tierName: "Enterprise Volume",
              price: 0.25, // Per survey response
              features: ["Full Platform Access", "Maximum Discount", "White Labeling", "Dedicated Account Manager"],
              targetSegments: ["Premium Buyer"],
              estimatedAdoption: 19.2,
              estimatedRevenue: 480000
            }
          ],
          willingness: [
            { segment: "Value Seeker", price: 0.29 },
            { segment: "Premium Buyer", price: 0.67 },
            { segment: "Early Adopter", price: 0.58 },
            { segment: "Brand Loyal", price: 0.41 }
          ]
        },
        {
          strategyId: "price-3",
          name: "Freemium Model",
          optimalPrice: 299.99, // For premium tier
          priceElasticity: -2.3,
          tiers: [
            {
              tierName: "Free",
              price: 0,
              features: ["Basic Trait Analysis", "Limited Responses", "Basic Reports"],
              targetSegments: ["Value Seeker", "Early Adopter"],
              estimatedAdoption: 65.2,
              estimatedRevenue: 0 // Direct revenue
            },
            {
              tierName: "Premium",
              price: 299.99,
              features: ["Unlimited Responses", "Full Trait Analysis", "Product Recommendations", "Export Capabilities"],
              targetSegments: ["Premium Buyer", "Brand Loyal", "Early Adopter"],
              estimatedAdoption: 24.8,
              estimatedRevenue: 743975.2
            },
            {
              tierName: "Business",
              price: 799.99,
              features: ["All Premium Features", "CRM Integration", "Team Collaboration", "Custom Branding"],
              targetSegments: ["Premium Buyer"],
              estimatedAdoption: 10.0,
              estimatedRevenue: 799990
            }
          ],
          willingness: [
            { segment: "Value Seeker", price: 124.56 },
            { segment: "Premium Buyer", price: 599.32 },
            { segment: "Early Adopter", price: 349.87 },
            { segment: "Brand Loyal", price: 274.65 }
          ]
        }
      ];
      return demoPricingStrategies;
    }
    console.log(`Fetching pricing strategies for company ID: ${companyId}`);
    
    try {
      // Get company info directly with SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      // Get survey responses for pricing sensitivity analysis using SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
                        
      // Get customer segments for this company
      const segments = await this.getCustomerSegments(companyId);
      
      // Set default values and override with company data if available
      let industry = company?.industry || 'Technology';
      let productName = 'Personality Assessment';
      let productCategory = 'SaaS';
      let productDescription = '';
      let targetMarket = 'Enterprise';
      
      // Analyze pricing sensitivity from survey responses
      let pricePreferences = {
        low: 0,
        medium: 0,
        high: 0
      };
      
      // Count price preference mentions in responses
      responses.forEach(response => {
        if (response.responses && typeof response.responses === 'object') {
          const responseValues = Object.values(response.responses);
          
          // Check for price-related keywords
          const hasLowPricingMention = responseValues.some(value => 
            typeof value === 'string' && 
            (
              value.toLowerCase().includes('affordable') ||
              value.toLowerCase().includes('cheap') ||
              value.toLowerCase().includes('low cost') ||
              value.toLowerCase().includes('budget') ||
              value.toLowerCase().includes('expensive')
            )
          );
          
          const hasPremiumPricingMention = responseValues.some(value => 
            typeof value === 'string' && 
            (
              value.toLowerCase().includes('premium') ||
              value.toLowerCase().includes('high-end') ||
              value.toLowerCase().includes('quality') ||
              value.toLowerCase().includes('exclusive')
            )
          );
          
          // Update price preference counts
          if (hasLowPricingMention) {
            pricePreferences.low++;
          } else if (hasPremiumPricingMention) {
            pricePreferences.high++;
          } else {
            pricePreferences.medium++;
          }
        }
      });
      
      // Determine dominant price sensitivity
      const totalPricePreferences = pricePreferences.low + pricePreferences.medium + pricePreferences.high;
      const priceSensitivity = 
        totalPricePreferences === 0 ? 'medium' :
        pricePreferences.low > pricePreferences.medium && pricePreferences.low > pricePreferences.high ? 'high' :
        pricePreferences.high > pricePreferences.medium && pricePreferences.high > pricePreferences.low ? 'low' :
        'medium';
      
      // Set price multipliers based on industry and price sensitivity
      const industryPriceMultiplier = {
        'Technology': 1.0,
        'Healthcare': 1.2,
        'Financial Services': 1.3,
        'Retail': 0.9,
        'Manufacturing': 1.1,
        'Education': 0.8
      }[industry] || 1.0;
      
      const sensitivityMultiplier = {
        'high': 0.8, // high sensitivity = lower prices
        'medium': 1.0,
        'low': 1.2  // low sensitivity = higher prices
      }[priceSensitivity];
      
      // Generate base prices for subscription tiers
      const basePrice = 100 * industryPriceMultiplier * sensitivityMultiplier;
      const basicPrice = Math.round(basePrice * 0.8);
      const professionalPrice = Math.round(basePrice * 1.8);
      const enterprisePrice = Math.round(basePrice * 3.6);
      
      // Generate usage-based prices
      const assessmentPrice = Math.round((basePrice / 4) + 5);
      const bulkAssessmentPrice = Math.round((assessmentPrice * 0.85) + 0.5);
      
      // Calculate optimal price points
      const optimalSubscriptionPrice = Math.round((basicPrice + professionalPrice + enterprisePrice) / 3);
      const optimalUsagePrice = Math.round((assessmentPrice + bulkAssessmentPrice) / 2);
      
      // Calculate price elasticity based on price sensitivity
      const subscriptionElasticity = priceSensitivity === 'high' ? 1.8 : 
                                  priceSensitivity === 'low' ? 0.9 : 1.3;
      const usageElasticity = priceSensitivity === 'high' ? 2.2 : 
                           priceSensitivity === 'low' ? 1.2 : 1.7;
      
      // Generate estimated adoption and revenue numbers
      const basicAdoption = 30 + Math.floor(Math.random() * 15);
      const proAdoption = 35 + Math.floor(Math.random() * 20);
      const enterpriseAdoption = 15 + Math.floor(Math.random() * 15);
      
      const payPerAdoption = 20 + Math.floor(Math.random() * 15);
      const bulkAdoption = 35 + Math.floor(Math.random() * 15);
      
      // Calculate revenue estimates
      const basicRevenue = Math.round(basicPrice * 12 * (basicAdoption * 10));
      const proRevenue = Math.round(professionalPrice * 12 * (proAdoption * 10));
      const enterpriseRevenue = Math.round(enterprisePrice * 12 * (enterpriseAdoption * 5));
      
      const payPerRevenue = Math.round(assessmentPrice * (payPerAdoption * 100));
      const bulkRevenue = Math.round(bulkAssessmentPrice * (bulkAdoption * 150));
      
      // Create segment willing-to-pay data
      const willingness = [];
      segments.forEach(segment => {
        // Generate different price points based on segment demographics
        let multiplier = 1.0;
        
        // Use demographic information to adjust willingness to pay
        if (segment.demographicSummary) {
          const demo = segment.demographicSummary;
          
          // Higher income = higher willingness to pay
          if (demo.averageIncome && demo.averageIncome.includes('150K')) {
            multiplier *= 1.3;
          } else if (demo.averageIncome && demo.averageIncome.includes('100K')) {
            multiplier *= 1.15;
          }
          
          // Age-based adjustments
          if (demo.averageAge > 45) {
            multiplier *= 1.1;
          } else if (demo.averageAge < 30) {
            multiplier *= 0.9;
          }
        }
        
        // Get willingness to pay for this segment
        const willingPrice = Math.round(professionalPrice * multiplier);
        
        willingness.push({
          segment: segment.name,
          price: willingPrice
        });
      });
      
      // If no segments found, create default willingness data
      if (willingness.length === 0) {
        willingness.push(
          { segment: 'Enterprise Decision Makers', price: Math.round(professionalPrice * 1.2) },
          { segment: 'HR Professionals', price: professionalPrice },
          { segment: 'Team Leaders', price: Math.round(professionalPrice * 0.8) }
        );
      }
      
      // Sort willingness by price (highest first)
      willingness.sort((a, b) => b.price - a.price);
      
      // Similarly for usage model
      const usageWillingness = willingness.map(w => ({
        segment: w.segment,
        price: Math.round(assessmentPrice * (w.price / professionalPrice))
      }));
      
      // Generate recommended pricing strategies
      const strategies = [
        {
          strategyId: 'price-1',
          name: 'Tiered Subscription Model',
          tiers: [
            {
              tierName: 'Basic',
              price: basicPrice,
              features: ['Core assessment tools', 'Basic reporting', 'Email support'],
              targetSegments: ['Small Teams', 'Startups'],
              estimatedAdoption: basicAdoption,
              estimatedRevenue: basicRevenue
            },
            {
              tierName: 'Professional',
              price: professionalPrice,
              features: ['Advanced analytics', 'Team comparison tools', 'Priority support', 'API access'],
              targetSegments: ['Mid-sized Companies', 'HR Departments'],
              estimatedAdoption: proAdoption,
              estimatedRevenue: proRevenue
            },
            {
              tierName: 'Enterprise',
              price: enterprisePrice,
              features: ['AI-powered insights', 'Custom integrations', 'Dedicated account manager', 'Unlimited assessments'],
              targetSegments: ['Large Corporations', 'Global Organizations'],
              estimatedAdoption: enterpriseAdoption,
              estimatedRevenue: enterpriseRevenue
            }
          ],
          optimalPrice: optimalSubscriptionPrice,
          priceElasticity: Math.round(subscriptionElasticity * 10) / 10,
          willingness: willingness.slice(0, 3)
        },
        {
          strategyId: 'price-2',
          name: 'Usage-Based Model',
          tiers: [
            {
              tierName: 'Pay Per Assessment',
              price: assessmentPrice,
              features: ['Full assessment access', 'Basic reporting', 'No monthly commitment'],
              targetSegments: ['Small Teams', 'Occasional Users'],
              estimatedAdoption: payPerAdoption,
              estimatedRevenue: payPerRevenue
            },
            {
              tierName: 'Assessment Packs',
              price: bulkAssessmentPrice,
              features: ['Bulk discount pricing', 'Full feature access', 'Volume reporting'],
              targetSegments: ['Medium Organizations', 'Consulting Firms'],
              estimatedAdoption: bulkAdoption,
              estimatedRevenue: bulkRevenue
            }
          ],
          optimalPrice: optimalUsagePrice,
          priceElasticity: Math.round(usageElasticity * 10) / 10,
          willingness: usageWillingness.slice(0, 3)
        }
      ];
      
      return strategies;
    } catch (error) {
      console.error(`Error fetching pricing strategies for company ${companyId}:`, error);
      throw error;
    }
  }
  
  async getMarketingStrategies(companyId: number): Promise<MarketingStrategy[]> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getMarketingStrategies called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning hardcoded demo marketing strategies for DEMO company ID: ${companyId}`);
      // Hardcoded demo marketing strategies
      const demoMarketingStrategies = [
        {
          strategyName: "Thought Leadership Content Strategy",
          effectiveness: 87,
          costEfficiency: 73,
          implementationTimeline: "3-6 months",
          revenueImpact: 78,
          brandAlignment: 92,
          customerReach: 76,
          competitiveAdvantage: 85,
          channelBreakdown: {
            "Industry Publications": 24,
            "Podcast Sponsorships": 18,
            "Webinar Series": 22,
            "LinkedIn Content": 26,
            "Email Newsletter": 10
          },
          messagingThemes: [
            "Transform team dynamics with science-backed personality insights",
            "Reduce turnover by 28% through better team alignment",
            "Make data-driven people decisions with confidence"
          ],
          targetedPersonas: ["HR Directors", "People Operations Leaders", "Executive Coaches"],
          overallScore: 82
        },
        {
          strategyName: "Growth-Focused Value Campaign",
          effectiveness: 84,
          costEfficiency: 82,
          implementationTimeline: "1-3 months",
          revenueImpact: 75,
          brandAlignment: 79,
          customerReach: 86,
          competitiveAdvantage: 72,
          channelBreakdown: {
            "LinkedIn Advertising": 28,
            "Google Search": 25,
            "Email Nurture Campaigns": 22,
            "Partner Co-marketing": 15,
            "Content Marketing": 10
          },
          messagingThemes: [
            "Accelerate team performance and cohesion",
            "Affordable personality insights for growing businesses",
            "Simple implementation, powerful results"
          ],
          targetedPersonas: ["Startup Founders", "SMB Managers", "Team Leaders"],
          overallScore: 78
        }
      ];
      return demoMarketingStrategies;
    }
    console.log(`Fetching marketing strategies for company ID: ${companyId}`);
    
    try {
      // Get company info directly with SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      // Set industry from company data
      const industry = company.industry || 'Technology';
      
      // Get survey responses for this company with SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
      
      // Define default business information
      let productName = 'Personality Assessment';
      let targetMarket = 'Enterprise';
      let targetBudget = 50000;
      let marketingGoals: string[] = [
        'Increase brand awareness',
        'Generate qualified leads',
        'Improve customer engagement',
        'Support sales initiatives'
      ];
      let competitorNames: string[] = [
        'CompetitorOne', 
        'CompetitorTwo',
        'CompetitorThree'
      ];
      let targetChannels: string[] = [
        'Email Marketing',
        'Content Marketing',
        'Social Media',
        'SEO',
        'Paid Advertising'
      ];
      
      // Analyze personality traits from survey responses
      const traitCounts: Record<string, number> = {};
      const traitScores: Record<string, number[]> = {};
      
      // Extract traits and their scores
      responses.forEach(response => {
        if (response.traits && Array.isArray(response.traits)) {
          response.traits.forEach((trait: PersonalityTrait) => {
            if (trait.name) {
              // Count frequency
              if (traitCounts[trait.name]) {
                traitCounts[trait.name]++;
              } else {
                traitCounts[trait.name] = 1;
              }
              
              // Track scores for averaging
              if (trait.score !== undefined && trait.score !== null) {
                if (!traitScores[trait.name]) {
                  traitScores[trait.name] = [];
                }
                traitScores[trait.name].push(trait.score);
              }
            }
          });
        }
      });
      
      // Get top traits by frequency and score
      const topTraits = Object.entries(traitCounts)
        .sort(([, countA], [, countB]) => (countB as number) - (countA as number))
        .slice(0, 5)
        .map(([trait]) => trait);
      
      // Calculate average scores for top traits
      const traitAverages: Record<string, number> = {};
      Object.entries(traitScores).forEach(([trait, scores]) => {
        if (scores.length > 0) {
          traitAverages[trait] = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        }
      });
      
      // Get target segments from customer segment analysis
      // Make sure segments is defined before using it
      const segmentsResult = await this.getCustomerSegments(companyId);
      const targetSegments = segmentsResult.length > 0
        ? segmentsResult.slice(0, 3).map(segment => segment.name)
        : ['Enterprise Teams', 'HR Leaders', 'Mid-Market Companies'];
      
      // Define marketing channels based on industry, target market, and any specified channels
      const channels: Array<{
        channelName: string;
        effectiveness: number;
        costPerLead: number;
        recommendedBudget: number;
      }> = [];
      
      // Start with specified channels if any
      const defaultChannels = this.getDefaultChannels(industry, targetMarket);
      const availableChannels = targetChannels.length > 0 
        ? targetChannels 
        : defaultChannels.map(c => c.channelName);
      
      // Add channels with data-driven metrics
      availableChannels.forEach(channelName => {
        // Find base metrics from defaults if possible
        const baseChannel = defaultChannels.find(c => c.channelName === channelName || 
                                                    c.channelName.toLowerCase().includes(channelName.toLowerCase()));
        
        // Start with defaults or generate reasonable values
        let effectiveness = Math.round(70 + Math.random() * 20); // 70-90
        let costPerLead = Math.round(50 + Math.random() * 150); // $50-$200
        let budget = Math.round((targetBudget * (0.1 + Math.random() * 0.3))); // 10-40% of total budget
        
        // Use base values if found
        if (baseChannel) {
          effectiveness = baseChannel.effectiveness;
          costPerLead = baseChannel.costPerLead;
          budget = baseChannel.recommendedBudget;
        }
        
        // Add some variation based on response data
        // More responses = more data = potentially more effective
        const dataDrivenAdjustment = Math.min(10, responses.length / 5); // Up to +10 points for lots of data
        
        // Adjust effectiveness based on survey data volume
        effectiveness = Math.min(95, Math.round(effectiveness + dataDrivenAdjustment));
        
        channels.push({
          channelName,
          effectiveness,
          costPerLead,
          recommendedBudget: budget
        });
      });
      
      // Sort channels by effectiveness
      channels.sort((a, b) => b.effectiveness - a.effectiveness);
      
      // Generate messaging based on industry and personality traits
      const messaging = this.getMessagingForIndustry(industry, topTraits, traitAverages);
      
      // Generate campaign ideas based on personality traits and response data
      const campaignIdeas = this.generateCampaignIdeas(
        topTraits, 
        traitAverages, 
        industry, 
        responses.length, 
        competitorNames
      );
      
      // Generate at least 3 marketing strategies
      const strategies: MarketingStrategy[] = [];
      
      // 1. Content Marketing Strategy
      strategies.push({
        strategyName: 'Content Marketing Program',
        effectiveness: Math.round(75 + (responses.length / 10)), // More data = better predictions
        costEfficiency: 85,
        implementationTimeline: responses.length > 20 ? 'Short-term (1-3 months)' : 'Medium-term (3-6 months)',
        revenueImpact: 70 + Math.floor(Math.random() * 16),
        brandAlignment: 85 + Math.floor(Math.random() * 11),
        customerReach: 75 + Math.floor(Math.random() * 16),
        competitiveAdvantage: competitorNames.length > 0 ? 70 + Math.floor(Math.random() * 21) : 60 + Math.floor(Math.random() * 26),
        channelBreakdown: {
          'Social Media': 30 + Math.floor(Math.random() * 11),
          'Blog/Website': 25 + Math.floor(Math.random() * 11),
          'Email': 20 + Math.floor(Math.random() * 11),
          'Webinars': 15 + Math.floor(Math.random() * 11),
          'Industry Publications': 10 + Math.floor(Math.random() * 6)
        },
        messagingThemes: messaging.keyMessages.slice(0, 3),
        targetedPersonas: targetSegments,
        overallScore: 80 + Math.floor(Math.random() * 11)
      });
      
      // 2. Event-Based Strategy (if applicable to industry)
      const eventStrategy: MarketingStrategy = {
        strategyName: 'Event & Relationship Marketing',
        effectiveness: 80 + Math.floor(Math.random() * 11),
        costEfficiency: industry === 'Technology' ? 75 : 65, // Tech industry events are more cost-effective
        implementationTimeline: 'Medium-term (3-6 months)',
        revenueImpact: 80 + Math.floor(Math.random() * 11),
        brandAlignment: 85 + Math.floor(Math.random() * 11),
        customerReach: 65 + Math.floor(Math.random() * 16),
        competitiveAdvantage: 75 + Math.floor(Math.random() * 16),
        channelBreakdown: {
          'Industry Conferences': 35 + Math.floor(Math.random() * 11),
          'Executive Roundtables': 25 + Math.floor(Math.random() * 11),
          'Customer Workshops': 20 + Math.floor(Math.random() * 11),
          'Partner Events': 10 + Math.floor(Math.random() * 11),
          'Webinars': 10 + Math.floor(Math.random() * 6)
        },
        messagingThemes: [
          'Experience personality insights in action',
          'See how leading organizations leverage personality data',
          'Interactive demonstrations of our assessment platform'
        ],
        targetedPersonas: targetSegments,
        overallScore: 75 + Math.floor(Math.random() * 16)
      };
      strategies.push(eventStrategy);
      
      // 3. Data-Driven Digital Strategy (always relevant)
      strategies.push({
        strategyName: 'Targeted Digital Campaign',
        effectiveness: 85 + Math.floor(Math.random() * 11),
        costEfficiency: 80 + Math.floor(Math.random() * 11),
        implementationTimeline: 'Short-term (1-3 months)',
        revenueImpact: 75 + Math.floor(Math.random() * 16),
        brandAlignment: 80 + Math.floor(Math.random() * 11),
        customerReach: 85 + Math.floor(Math.random() * 11),
        competitiveAdvantage: 70 + Math.floor(Math.random() * 16),
        channelBreakdown: {
          'LinkedIn Advertising': 40 + Math.floor(Math.random() * 11),
          'Google Ads': 25 + Math.floor(Math.random() * 11),
          'Retargeting': 20 + Math.floor(Math.random() * 11),
          'Industry Websites': 15 + Math.floor(Math.random() * 6)
        },
        messagingThemes: [
          ...messaging.valuePropositions.slice(0, 2),
          campaignIdeas[0]?.name || 'Data-Driven Personality Insights'
        ],
        targetedPersonas: targetSegments,
        overallScore: 85 + Math.floor(Math.random() * 11)
      });
      
      // Sort strategies by overall score
      strategies.sort((a, b) => b.overallScore - a.overallScore);
      
      return strategies;
    } catch (error) {
      console.error(`Error fetching marketing strategies for company ${companyId}:`, error);
      throw error;
    }
  }
  
  // Helper method to get default marketing channels based on industry and market
  private getDefaultChannels(industry: string, targetMarket: string): Array<{
    channelName: string;
    effectiveness: number;
    costPerLead: number;
    recommendedBudget: number;
  }> {
    const channels = [];
    
    // Digital channels (common across industries)
    channels.push({
      channelName: 'LinkedIn Advertising',
      effectiveness: 85,
      costPerLead: 95,
      recommendedBudget: 12000
    });
    
    channels.push({
      channelName: 'Content Marketing',
      effectiveness: 80,
      costPerLead: 65,
      recommendedBudget: 10000
    });
    
    channels.push({
      channelName: 'Email Campaigns',
      effectiveness: 75,
      costPerLead: 45,
      recommendedBudget: 8000
    });
    
    // Industry-specific channels
    if (industry === 'Technology') {
      channels.push({
        channelName: 'Tech Industry Webinars',
        effectiveness: 82,
        costPerLead: 90,
        recommendedBudget: 15000
      });
      
      channels.push({
        channelName: 'Developer Communities',
        effectiveness: 78,
        costPerLead: 70,
        recommendedBudget: 9000
      });
    } 
    else if (industry === 'Healthcare') {
      channels.push({
        channelName: 'Healthcare Conferences',
        effectiveness: 85,
        costPerLead: 120,
        recommendedBudget: 20000
      });
      
      channels.push({
        channelName: 'Medical Publications',
        effectiveness: 75,
        costPerLead: 110,
        recommendedBudget: 12000
      });
    } 
    else if (industry === 'Financial Services') {
      channels.push({
        channelName: 'Financial Industry Events',
        effectiveness: 82,
        costPerLead: 150,
        recommendedBudget: 18000
      });
      
      channels.push({
        channelName: 'Financial Publications',
        effectiveness: 78,
        costPerLead: 130,
        recommendedBudget: 14000
      });
    }
    
    // Market-specific channels
    if (targetMarket === 'Enterprise') {
      channels.push({
        channelName: 'Executive Roundtables',
        effectiveness: 90,
        costPerLead: 200,
        recommendedBudget: 25000
      });
    } 
    else if (targetMarket === 'SMB' || targetMarket === 'Small Business') {
      channels.push({
        channelName: 'Local Business Networks',
        effectiveness: 78,
        costPerLead: 60,
        recommendedBudget: 6000
      });
    }
    
    return channels;
  }
  
  // Helper method to generate messaging for different industries
  private getMessagingForIndustry(
    industry: string, 
    topTraits: string[], 
    traitScores: Record<string, number>
  ): {
    keyMessages: string[];
    toneOfVoice: string;
    valuePropositions: string[];
  } {
    const keyMessages = [];
    const valuePropositions = [];
    
    // Add industry-specific messaging
    if (industry === 'Technology') {
      keyMessages.push(
        'AI-powered personality insights for tech teams',
        'Data-driven approach to team building in tech organizations',
        'Scientifically validated technology for personality assessment'
      );
      
      valuePropositions.push(
        'Optimize engineering team dynamics',
        'Reduce developer turnover with better team fit',
        'Increase innovation through diverse personality composition'
      );
    } else if (industry === 'Healthcare') {
      keyMessages.push(
        'Evidence-based personality assessment for healthcare teams',
        'Improve patient care through better team dynamics',
        'Clinically validated approach to healthcare staffing'
      );
      
      valuePropositions.push(
        'Reduce medical errors through improved communication',
        'Increase patient satisfaction through better-matched care teams',
        'Lower staff burnout through optimal role assignment'
      );
    } else if (industry === 'Financial Services') {
      keyMessages.push(
        'Risk-optimized team composition for financial organizations',
        'Data-driven approach to financial team performance',
        'Compliance-friendly personality assessment'
      );
      
      valuePropositions.push(
        'Reduce trading risk through balanced team composition',
        'Improve client satisfaction through personality-matched advisors',
        'Increase regulatory compliance through better team communication'
      );
    } else {
      keyMessages.push(
        'Data-driven people insights',
        'Improve team performance through personality understanding',
        'Scientifically validated assessment methodology'
      );
      
      valuePropositions.push(
        'Make better hiring decisions',
        'Reduce team conflict and improve collaboration',
        'Personalized development plans for every team member'
      );
    }
    
    // Determine appropriate tone of voice based on industry and traits
    let toneOfVoice = 'Professional, authoritative, yet approachable';
    
    if (industry === 'Technology') {
      toneOfVoice = 'Technical, innovative, and data-driven';
    } else if (industry === 'Healthcare') {
      toneOfVoice = 'Caring, evidence-based, and trustworthy';
    } else if (industry === 'Financial Services') {
      toneOfVoice = 'Authoritative, precise, and security-focused';
    }
    
    // Adjust tone based on top traits if applicable
    if (topTraits.includes('Analytical') || topTraits.includes('Logical')) {
      toneOfVoice = toneOfVoice.replace('authoritative', 'logical').replace('caring', 'precise');
    } else if (topTraits.includes('Empathetic') || topTraits.includes('Cooperative')) {
      toneOfVoice = toneOfVoice.replace('authoritative', 'empathetic').replace('precise', 'supportive');
    }
    
    return {
      keyMessages,
      toneOfVoice,
      valuePropositions
    };
  }
  
  // Helper method to generate campaign ideas based on traits
  private generateCampaignIdeas(
    topTraits: string[], 
    traitScores: Record<string, number>,
    industry: string,
    responseCount: number,
    competitors: string[]
  ): Array<{
    name: string;
    description: string;
    targetTrait: string;
    estimatedResponse: number;
  }> {
    const campaignIdeas = [];
    
    // Generate campaign ideas for top traits
    if (topTraits.includes('Analytical')) {
      campaignIdeas.push({
        name: 'Data-Driven Team Performance Series',
        description: 'Case studies and research showing measurable ROI of personality-based team composition',
        targetTrait: 'Analytical',
        estimatedResponse: 3.8 + (responseCount > 20 ? 0.4 : 0.2)
      });
    }
    
    if (topTraits.includes('Innovative') || topTraits.includes('Creative')) {
      campaignIdeas.push({
        name: 'Innovation Accelerator Program',
        description: 'Framework for identifying and nurturing innovative thinkers within your organization',
        targetTrait: 'Innovative',
        estimatedResponse: 3.7 + (responseCount > 20 ? 0.4 : 0.2)
      });
    }
    
    if (topTraits.includes('Detail-Oriented') || topTraits.includes('Conscientious')) {
      campaignIdeas.push({
        name: 'Precision Performance Blueprint',
        description: 'Framework for optimizing team accuracy and attention to detail through personality composition',
        targetTrait: 'Detail-Oriented',
        estimatedResponse: 3.5 + (responseCount > 20 ? 0.4 : 0.2)
      });
    }
    
    if (topTraits.includes('Empathetic') || topTraits.includes('Supportive')) {
      campaignIdeas.push({
        name: 'Empathy-Driven Leadership Program',
        description: 'Training framework for developing supportive leadership based on personality insights',
        targetTrait: 'Empathetic',
        estimatedResponse: 3.6 + (responseCount > 20 ? 0.4 : 0.2)
      });
    }
    
    // Add competitor-focused campaign if we have competitors
    if (competitors.length > 0) {
      campaignIdeas.push({
        name: 'Competitive Advantage Analysis',
        description: `See how your team dynamics compare to industry leaders like ${competitors[0]}`,
        targetTrait: 'Competitive',
        estimatedResponse: 3.9 + (responseCount > 20 ? 0.3 : 0.1)
      });
    }
    
    // If not enough campaign ideas, add generic ones
    if (campaignIdeas.length < 3) {
      campaignIdeas.push({
        name: 'Personality at Work Series',
        description: 'A series of industry reports showing how personality affects workplace dynamics',
        targetTrait: topTraits[0] || 'Analytical',
        estimatedResponse: 3.5 + (responseCount > 20 ? 0.3 : 0.1)
      });
      
      campaignIdeas.push({
        name: 'ROI Calculator for Personality Assessment',
        description: 'Interactive tool demonstrating the financial impact of improved team dynamics',
        targetTrait: topTraits[1] || 'Practical',
        estimatedResponse: 3.7 + (responseCount > 20 ? 0.3 : 0.1)
      });
    }
    
    // Add industry-specific campaign ideas
    if (industry === 'Technology' && !campaignIdeas.some(c => c.name.includes('Developer'))) {
      campaignIdeas.push({
        name: 'Developer Team Optimization Blueprint',
        description: 'A framework for structuring developer teams based on personality compatibility',
        targetTrait: 'Technical',
        estimatedResponse: 3.8 + (responseCount > 20 ? 0.4 : 0.2)
      });
    } else if (industry === 'Healthcare' && !campaignIdeas.some(c => c.name.includes('Patient'))) {
      campaignIdeas.push({
        name: 'Patient Satisfaction Accelerator',
        description: 'How healthcare team composition affects patient outcomes and satisfaction',
        targetTrait: 'Caring',
        estimatedResponse: 3.7 + (responseCount > 20 ? 0.4 : 0.2)
      });
    } else if (industry === 'Financial Services' && !campaignIdeas.some(c => c.name.includes('Risk'))) {
      campaignIdeas.push({
        name: 'Risk Optimization Framework',
        description: 'How personality balance in financial teams affects risk management',
        targetTrait: 'Risk-aware',
        estimatedResponse: 3.9 + (responseCount > 20 ? 0.4 : 0.2)
      });
    }
    
    // Trim response rates to 1 decimal place
    campaignIdeas.forEach(campaign => {
      campaign.estimatedResponse = Math.round(campaign.estimatedResponse * 10) / 10;
    });
    
    // Sort campaign ideas by estimated response (highest first)
    campaignIdeas.sort((a, b) => b.estimatedResponse - a.estimatedResponse);
    
    return campaignIdeas;
  }
  
  async getRevenueForecasts(companyId: number): Promise<RevenueForecasting[]> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getRevenueForecasts called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning demo revenue forecasts for DEMO company ID: ${companyId}`);
      
      // Enhanced demo data for revenue forecasts with improved visualization support
      return [
        {
          id: 1,
          companyId: companyId,
          name: "Conservative Growth",
          scenarioId: "conservative",
          productId: "premium-saas",
          scenario: "Conservative Growth",
          month: 1,
          year: 2025,
          revenue: 148000,
          profit: 42000,
          customers: 760,
          churnRate: 3.2,
          growthRate: 5.1,
          confidence: 0.85,
          probabilityOfOccurrence: 0.7, 
          timeframe: 12, // 12 months
          projectedRevenue: 450000,
          marketShareProjection: 3.2,
          customerAdoption: 755,
          contributingFactors: ["Market stability", "Core customer retention", "Moderate expansion"],
          riskFactors: ["Competitor pricing pressure", "Economic downturn"],
          confidenceLevel: 76,
          // Added array format for charting
          projections: {
            monthly: [145000, 150000, 155000, 160000, 158000, 162000, 164000, 168000, 172000, 175000, 178000, 182000],
            annual: 1969000
          },
          monthlyBreakdown: {
            "Jan 2025": 145000,
            "Feb 2025": 150000,
            "Mar 2025": 155000,
            "Apr 2025": 160000,
            "May 2025": 158000,
            "Jun 2025": 162000,
            "Jul 2025": 164000,
            "Aug 2025": 168000,
            "Sep 2025": 172000,
            "Oct 2025": 175000,
            "Nov 2025": 178000,
            "Dec 2025": 182000
          }
        },
        {
          id: 2,
          companyId: companyId,
          name: "Moderate Growth",
          scenarioId: "moderate",
          productId: "premium-saas",
          scenario: "Moderate Growth",
          month: 1, 
          year: 2025,
          revenue: 165000,
          profit: 52000,
          customers: 820,
          churnRate: 2.8,
          growthRate: 7.2,
          confidence: 0.75,
          probabilityOfOccurrence: 0.5,
          timeframe: 12, // 12 months
          projectedRevenue: 520000,
          marketShareProjection: 3.8,
          customerAdoption: 820,
          contributingFactors: ["New feature adoption", "Expanded marketing", "Partnership deals"],
          riskFactors: ["Execution delays", "Customer churn"],
          confidenceLevel: 68,
          // Added array format for charting
          projections: {
            monthly: [165000, 175000, 180000, 185000, 190000, 195000, 200000, 205000, 210000, 215000, 220000, 230000],
            annual: 2370000
          },
          monthlyBreakdown: {
            "Jan 2025": 165000,
            "Feb 2025": 175000,
            "Mar 2025": 180000,
            "Apr 2025": 185000,
            "May 2025": 190000,
            "Jun 2025": 195000,
            "Jul 2025": 200000,
            "Aug 2025": 205000,
            "Sep 2025": 210000,
            "Oct 2025": 215000,
            "Nov 2025": 220000,
            "Dec 2025": 230000
          }
        },
        {
          id: 3,
          companyId: companyId,
          name: "Aggressive Growth",
          scenarioId: "aggressive",
          productId: "premium-saas",
          scenario: "Aggressive Growth",
          month: 1,
          year: 2025,
          revenue: 185000,
          profit: 60000,
          customers: 890,
          churnRate: 2.5,
          growthRate: 9.8,
          confidence: 0.65,
          probabilityOfOccurrence: 0.3,
          timeframe: 12, // 12 months
          projectedRevenue: 620000,
          marketShareProjection: 4.5,
          customerAdoption: 890,
          contributingFactors: ["Enterprise client acquisition", "International expansion", "New product launch"],
          riskFactors: ["Competitive response", "Resource constraints", "Market saturation"],
          confidenceLevel: 62,
          // Added array format for charting
          projections: {
            monthly: [190000, 210000, 220000, 235000, 245000, 260000, 280000, 295000, 310000, 325000, 340000, 360000],
            annual: 3070000
          },
          monthlyBreakdown: {
            "Jan 2025": 190000,
            "Feb 2025": 210000,
            "Mar 2025": 220000,
            "Apr 2025": 235000,
            "May 2025": 245000,
            "Jun 2025": 260000,
            "Jul 2025": 280000,
            "Aug 2025": 295000,
            "Sep 2025": 310000,
            "Oct 2025": 325000,
            "Nov 2025": 340000,
            "Dec 2025": 360000
          }
        }
      ];
    }
    console.log(`Fetching revenue forecasts for company ID: ${companyId}`);
    
    try {
      // Get company info directly with SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      // Skipping business context query since the table doesn't exist
      const businessContexts = []; // Empty array as we don't have the context table
      
      // Get survey responses for this company with SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
      
      // Get customer segments for this company
      const segments = await this.getCustomerSegments(companyId);
      
      // Get pricing strategies
      const pricingStrategies = await this.getPricingStrategies(companyId);
      
      // Extract business information from context and company data
      let industry = company.industry || 'Technology';
      let productName = 'Personality Assessment';
      let targetMarket = 'Enterprise';
      let marketSize = 5000;
      let competitivePosition = 'growing';
      let growthStage = 'initial';
      let salesCycle = 30; // days
      let customerLifetime = 12; // months
      
      // Extract information from business context if available
      if (businessContexts.length > 0) {
        const context = businessContexts[0];
        
        // Extract product name if available
        if (context.productName) {
          productName = context.productName;
        }
        
        // Extract target market if available
        if (context.targetMarket) {
          if (typeof context.targetMarket === 'string') {
            targetMarket = context.targetMarket;
          } else if (Array.isArray(context.targetMarket) && context.targetMarket.length > 0) {
            // If target market is an array, use the first value
            const firstTarget = context.targetMarket[0];
            if (typeof firstTarget === 'string') {
              targetMarket = firstTarget;
            }
          }
        }
        
        // Extract market position if available (equivalent to competitive position)
        if (context.marketPosition) {
          competitivePosition = context.marketPosition.toLowerCase();
        }
        
        // Extract company stage if available (equivalent to growth stage)
        if (context.companyStage) {
          growthStage = context.companyStage;
        }
        
        // For sales cycle and customer lifetime, use existing defaults as these
        // fields are not directly available in the business context schema
      }
      
      // Analyze survey responses for insights on market potential
      // Calculate average satisfaction and market fit scores
      let satisfactionSum = 0;
      let satisfactionCount = 0;
      let marketFitSum = 0;
      let marketFitCount = 0;
      
      responses.forEach(response => {
        // Track satisfaction scores
        if (response.satisfactionScore !== null && response.satisfactionScore !== undefined) {
          satisfactionSum += response.satisfactionScore;
          satisfactionCount++;
        }
        
        // Track market fit assessments from responses
        if (response.responses) {
          try {
            const responseData = typeof response.responses === 'string' ?
              JSON.parse(response.responses) : response.responses;
            
            // Check for market fit data in responses
            if (responseData && typeof responseData === 'object') {
              if (responseData.marketFit && !isNaN(parseFloat(responseData.marketFit))) {
                marketFitSum += parseFloat(responseData.marketFit);
                marketFitCount++;
              } else if (responseData.productFit && !isNaN(parseFloat(responseData.productFit))) {
                marketFitSum += parseFloat(responseData.productFit);
                marketFitCount++;
              }
            }
          } catch (e) {
            // Skip invalid responses
            console.log('Error parsing response data:', e);
          }
        }
      });
      
      // Calculate averages
      const avgSatisfaction = satisfactionCount > 0 ? 
        satisfactionSum / satisfactionCount : 3.5; // Default if no data
        
      const avgMarketFit = marketFitCount > 0 ? 
        marketFitSum / marketFitCount : 3.5; // Default if no data
      
      // Adjust market size based on target market
      if (targetMarket === 'Enterprise') {
        marketSize = Math.min(marketSize, 10000); // Enterprise markets tend to be smaller
      } else if (targetMarket === 'SMB' || targetMarket === 'Small Business') {
        marketSize = Math.max(marketSize, 50000); // SMB markets tend to be larger
      }
      
      // Calculate base growth rate based on industry and market position
      let baseGrowthRate = 0.1; // Default 10% monthly growth
      
      // Adjust for industry growth rates
      if (industry === 'Technology') {
        baseGrowthRate = 0.15;
      } else if (industry === 'Healthcare') {
        baseGrowthRate = 0.10;
      } else if (industry === 'Financial Services') {
        baseGrowthRate = 0.08;
      } else if (industry === 'Manufacturing') {
        baseGrowthRate = 0.07;
      } else if (industry === 'Retail') {
        baseGrowthRate = 0.12;
      }
      
      // Adjust growth rate based on competitive position
      if (competitivePosition.includes('leader') || competitivePosition.includes('dominant')) {
        baseGrowthRate *= 0.9; // Leaders grow more slowly (saturation)
      } else if (competitivePosition.includes('growing') || competitivePosition.includes('challenger')) {
        baseGrowthRate *= 1.2; // Challengers grow faster
      } else if (competitivePosition.includes('niche') || competitivePosition.includes('specialty')) {
        baseGrowthRate *= 0.95; // Niche players grow moderately
      } else if (competitivePosition.includes('new') || competitivePosition.includes('startup')) {
        baseGrowthRate *= 1.5; // Startups grow fastest
      }
      
      // Adjust growth rate based on growth stage
      if (growthStage.includes('early') || growthStage.includes('initial')) {
        baseGrowthRate *= 1.3; // Early stage companies grow faster
      } else if (growthStage.includes('scaling') || growthStage.includes('growth')) {
        baseGrowthRate *= 1.1; // Growth stage companies still grow well
      } else if (growthStage.includes('mature') || growthStage.includes('established')) {
        baseGrowthRate *= 0.7; // Mature companies grow more slowly
      }
      
      // Adjust growth rate based on market fit and satisfaction scores
      // Higher scores = better growth prospects
      const marketFitMultiplier = avgMarketFit / 3.5; // Normalized to 1.0 for average score of 3.5
      const satisfactionMultiplier = avgSatisfaction / 3.5; // Normalized to 1.0 for average score of 3.5
      
      baseGrowthRate *= (marketFitMultiplier * 0.6) + (satisfactionMultiplier * 0.4); // Weighted average
      
      // Calculate average price point from pricing strategies
      let averagePrice = 100; // Default price point
      
      if (pricingStrategies.length > 0) {
        const strategy = pricingStrategies[0];
        if (strategy.pricingStructure && strategy.pricingStructure.tiers && 
            Array.isArray(strategy.pricingStructure.tiers) && 
            strategy.pricingStructure.tiers.length > 0) {
          // Calculate average of all tier prices
          const tierPrices = strategy.pricingStructure.tiers.map(tier => tier.price);
          averagePrice = tierPrices.reduce((sum, price) => sum + price, 0) / tierPrices.length;
        }
      }
      
      // Calculate costs based on industry benchmarks
      const acquisitionCost = Math.round(averagePrice * 0.4); // 40% of the price
      const retentionCost = Math.round(averagePrice * 0.15); // 15% of the price
      const overheadCost = Math.round(20000 + (marketSize * 0.5)); // Base + scale with market
      
      // Prepare to generate multiple forecasting scenarios
      const scenarios: RevenueForecasting[] = [];
      
      // Generate conservative scenario
      scenarios.push(this.generateForecastScenario(
        companyId,
        'Conservative Growth',
        baseGrowthRate * 0.7, // 70% of base growth rate
        marketSize,
        averagePrice,
        acquisitionCost,
        retentionCost,
        overheadCost,
        responses.length,
        0.3, // 30% probability
        24, // 24 month timeframe
        salesCycle,
        customerLifetime
      ));
      
      // Generate expected scenario
      scenarios.push(this.generateForecastScenario(
        companyId,
        'Expected Growth',
        baseGrowthRate, // Base growth rate
        marketSize,
        averagePrice,
        acquisitionCost,
        retentionCost,
        overheadCost,
        responses.length,
        0.5, // 50% probability
        24, // 24 month timeframe
        salesCycle,
        customerLifetime
      ));
      
      // Generate optimistic scenario
      scenarios.push(this.generateForecastScenario(
        companyId,
        'Optimistic Growth',
        baseGrowthRate * 1.3, // 130% of base growth rate
        marketSize,
        averagePrice,
        acquisitionCost,
        retentionCost,
        overheadCost,
        responses.length,
        0.2, // 20% probability
        24, // 24 month timeframe
        salesCycle,
        customerLifetime
      ));
      
      // Sort scenarios by probability (highest first)
      scenarios.sort((a, b) => b.probabilityOfOccurrence - a.probabilityOfOccurrence);
      
      return scenarios;
    } catch (error) {
      console.error(`Error fetching revenue forecasts for company ${companyId}:`, error);
      throw error;
    }
  }
  
  // Helper method to generate a specific forecast scenario
  private generateForecastScenario(
    companyId: number,
    scenarioName: string,
    growthRate: number,
    marketSize: number,
    averagePrice: number,
    acquisitionCost: number,
    retentionCost: number,
    overheadCost: number,
    dataPoints: number,
    probability: number,
    timeframeMonths: number,
    salesCycle: number,
    customerLifetime: number
  ): RevenueForecasting {
    // Calculate confidence level based on data points (more data = higher confidence)
    const confidenceLevel = Math.min(95, 60 + (dataPoints / 10) * 5);
    
    // Generate monthly breakdown
    const monthlyBreakdown: Record<string, number> = {};
    
    // Start with a reasonable initial customer count based on market
    let initialCustomers = Math.round(marketSize * 0.01); // Start with 1% of market
    initialCustomers = Math.max(10, Math.min(500, initialCustomers)); // Constrain between 10-500
    
    // Keep track of current customer base for each month
    let currentCustomers = initialCustomers;
    let cumulativeRevenue = 0;
    
    // Calculate each month's revenue
    for (let i = 1; i <= timeframeMonths; i++) {
      // Month label (M1, M2, etc.)
      const monthLabel = `M${i}`;
      
      // Calculate new customers for this month (based on current customer base)
      const newCustomers = Math.round(currentCustomers * growthRate);
      
      // Add new customers to the total (consider churn based on customer lifetime)
      const churnRate = 1 / customerLifetime; // Monthly churn rate
      const churnedCustomers = Math.round(currentCustomers * churnRate);
      
      // Update current customer base
      currentCustomers = currentCustomers + newCustomers - churnedCustomers;
      
      // Cap at market size
      currentCustomers = Math.min(currentCustomers, marketSize);
      
      // Calculate revenue for this month and add to cumulative
      const monthRevenue = Math.round(currentCustomers * averagePrice);
      cumulativeRevenue += monthRevenue;
      
      // Add to monthly breakdown
      monthlyBreakdown[monthLabel] = monthRevenue;
    }
    
    // Calculate costs for the entire period
    const totalCost = (currentCustomers * acquisitionCost) + 
                      (currentCustomers * retentionCost) + 
                      (overheadCost * timeframeMonths);
    
    // Calculate projected market share at end of period
    const marketShareProjection = Math.round((currentCustomers / marketSize) * 100);
    
    // Calculate average monthly growth rate
    const avgMonthlyGrowth = Math.round(growthRate * 100);
    
    // Create the forecast object
    return {
      scenario: scenarioName,
      probabilityOfOccurrence: probability * 100, // Convert to percentage
      timeframe: `${timeframeMonths} months`,
      projectedRevenue: cumulativeRevenue,
      growthRate: avgMonthlyGrowth,
      marketShareProjection,
      customerAdoption: marketShareProjection, // Same as market share for now
      contributingFactors: this.getContributingFactors(scenarioName, growthRate, salesCycle),
      riskFactors: this.getRiskFactors(scenarioName, growthRate, customerLifetime),
      confidenceLevel,
      monthlyBreakdown
    };
  }
  
  // Helper method to generate contributing factors based on scenario
  private getContributingFactors(scenarioName: string, growthRate: number, salesCycle: number): string[] {
    const factors = [];
    
    // Common contributing factors
    factors.push('Increasing market awareness of personality assessment benefits');
    
    // Scenario-specific factors
    if (scenarioName.includes('Conservative')) {
      factors.push('Gradual adoption within key market segments');
      factors.push('Measured expansion of client base');
      factors.push('Stable retention rates');
    } 
    else if (scenarioName.includes('Expected')) {
      factors.push('Strong product-market fit');
      factors.push('Effective marketing channel performance');
      factors.push('Positive customer testimonials driving referrals');
    }
    else if (scenarioName.includes('Optimistic')) {
      factors.push('Accelerated market adoption through word-of-mouth');
      factors.push('Higher than projected customer lifetime value');
      factors.push('Successful expansion into adjacent markets');
      factors.push('Viral growth through network effects');
    }
    
    // Growth rate factors
    if (growthRate > 0.15) {
      factors.push('Exponential growth through strong product advocacy');
    }
    
    // Sales cycle factors
    if (salesCycle < 20) {
      factors.push('Short sales cycle increasing conversion velocity');
    }
    
    return factors;
  }
  
  // Helper method to generate risk factors based on scenario
  private getRiskFactors(scenarioName: string, growthRate: number, customerLifetime: number): string[] {
    const factors = [];
    
    // Common risk factors
    factors.push('Competitive market pressure affecting pricing');
    
    // Scenario-specific factors
    if (scenarioName.includes('Conservative')) {
      factors.push('Slower than anticipated market education cycle');
      factors.push('Potential resource constraints limiting growth');
    } 
    else if (scenarioName.includes('Expected')) {
      factors.push('Market volatility affecting adoption rates');
      factors.push('Changes in customer acquisition costs');
    }
    else if (scenarioName.includes('Optimistic')) {
      factors.push('Assumption of continued high growth may not materialize');
      factors.push('Scaling challenges could impact service quality');
      factors.push('Aggressive expansion may lead to operational inefficiencies');
    }
    
    // Growth rate factors
    if (growthRate > 0.15) {
      factors.push('Sustaining high growth rates requires continuous innovation');
      factors.push('Rapid expansion may strain organizational resources');
    }
    
    // Customer lifetime factors
    if (customerLifetime < 12) {
      factors.push('Higher than expected churn could impact revenue stability');
    }
    
    return factors;
  }
  
  async getFocusGroupSimulation(companyId: number, productConcept: string): Promise<SimulatedFocusGroup> {
    // Special handling for the demo account - could be either ID 1 or 2
    console.log(`getFocusGroupSimulation called with companyId: ${companyId}`);
    if (companyId === 1 || companyId === 2) {
      console.log(`Returning demo focus group simulation for DEMO company ID: ${companyId}`);
      
      // Create hardcoded demo focus group data
      const demoFocusGroup = {
        productConcept: productConcept || "AI-powered personality assessment tool for hiring",
        participants: [
          {
            id: "p1",
            traits: [
              { name: "Openness", score: 82 },
              { name: "Conscientiousness", score: 75 },
              { name: "Extraversion", score: 62 },
              { name: "Agreeableness", score: 68 },
              { name: "Neuroticism", score: 45 }
            ],
            demographics: {
              age: 34,
              gender: "Female",
              occupation: "HR Manager",
              industry: "Technology",
              education: "Master's Degree",
              location: "Urban",
              income: "$85,000-$110,000"
            }
          },
          {
            id: "p2",
            traits: [
              { name: "Openness", score: 65 },
              { name: "Conscientiousness", score: 88 },
              { name: "Extraversion", score: 45 },
              { name: "Agreeableness", score: 72 },
              { name: "Neuroticism", score: 38 }
            ],
            demographics: {
              age: 42,
              gender: "Male",
              occupation: "Talent Acquisition Director",
              industry: "Finance",
              education: "MBA",
              location: "Suburban",
              income: "$120,000-$150,000"
            }
          },
          {
            id: "p3",
            traits: [
              { name: "Openness", score: 78 },
              { name: "Conscientiousness", score: 62 },
              { name: "Extraversion", score: 85 },
              { name: "Agreeableness", score: 70 },
              { name: "Neuroticism", score: 52 }
            ],
            demographics: {
              age: 29,
              gender: "Female",
              occupation: "Recruiter",
              industry: "Healthcare",
              education: "Bachelor's Degree",
              location: "Urban",
              income: "$60,000-$80,000"
            }
          },
          {
            id: "p4",
            traits: [
              { name: "Openness", score: 92 },
              { name: "Conscientiousness", score: 68 },
              { name: "Extraversion", score: 75 },
              { name: "Agreeableness", score: 65 },
              { name: "Neuroticism", score: 48 }
            ],
            demographics: {
              age: 38,
              gender: "Male",
              occupation: "Chief People Officer",
              industry: "Technology",
              education: "Ph.D.",
              location: "Urban",
              income: "$160,000-$200,000"
            }
          },
          {
            id: "p5",
            traits: [
              { name: "Openness", score: 70 },
              { name: "Conscientiousness", score: 78 },
              { name: "Extraversion", score: 56 },
              { name: "Agreeableness", score: 82 },
              { name: "Neuroticism", score: 41 }
            ],
            demographics: {
              age: 45,
              gender: "Female",
              occupation: "HR Director",
              industry: "Manufacturing",
              education: "Master's Degree",
              location: "Suburban",
              income: "$110,000-$140,000"
            }
          },
          {
            id: "p6",
            traits: [
              { name: "Openness", score: 77 },
              { name: "Conscientiousness", score: 85 },
              { name: "Extraversion", score: 52 },
              { name: "Agreeableness", score: 73 },
              { name: "Neuroticism", score: 35 }
            ],
            demographics: {
              age: 51,
              gender: "Male",
              occupation: "VP of Human Resources",
              industry: "Retail",
              education: "MBA",
              location: "Urban",
              income: "$130,000-$170,000"
            }
          }
        ],
        overallSentiment: 82,
        keyThemes: {
          "Accuracy of assessments": 85,
          "Ease of use": 82,
          "Time efficiency": 90,
          "Privacy concerns": 62,
          "Integration with existing systems": 70,
          "Cost effectiveness": 75,
          "Data visualization quality": 87,
          "Scientific validity": 83,
          "Customization options": 68,
          "Onboarding experience": 74,
          "Data privacy and security": 88,
          "Reporting capabilities": 79,
          "Predictive accuracy": 85,
          "ROI and business impact": 81,
          "User interface design": 77,
          "Training and support": 75,
          "Cross-functional usability": 70,
          "Enterprise scalability": 82,
          "Compliance with regulations": 86,
          "Adaptability to industry needs": 73,
          "Mobile experience": 64,
          "Team collaboration tools": 78,
          "Pricing structure": 71,
          "Implementation complexity": 69
        },
        suggestedImprovements: [
          "Provide more customization options for different industries and business contexts",
          "Add more detailed explanations of personality traits and their workplace implications",
          "Improve the candidate experience during assessment with better UI/UX design",
          "Develop better integration with popular ATS platforms like Workday and Greenhouse",
          "Create more comprehensive team compatibility reports with actionable recommendations",
          "Enhance mobile experience for reviewing results on smartphones",
          "Offer more detailed benchmark data against industry standards",
          "Provide training resources for HR managers to better interpret results",
          "Implement more granular role-based access controls for sensitive data",
          "Add the ability to track personality trait changes over time for individuals",
          "Create dashboard templates tailored to different stakeholder needs",
          "Improve data export capabilities to common formats (CSV, Excel, PDF)",
          "Develop AI-powered recommendation engine for team optimization",
          "Offer customizable survey questions to supplement standard assessments",
          "Enhance data visualization with more interactive chart options"
        ],
        purchaseIntent: 82,
        pricePerception: "Premium but worth it",
        valuePerception: 85,
        featureFeedback: {
          "Personality assessment": {
            importance: 95,
            satisfaction: 85,
            comments: [
              "Very accurate results",
              "Wish there were more customization options",
              "Great insights for team building",
              "Scientific validity is impressive",
              "Provides data we couldn't get elsewhere"
            ]
          },
          "Team compatibility analysis": {
            importance: 85,
            satisfaction: 78,
            comments: [
              "Helpful for reorganizing teams",
              "Would like more actionable recommendations",
              "Interesting visualization of team dynamics",
              "Would benefit from additional team metrics",
              "Need more granular control over matching parameters"
            ]
          },
          "Data visualization": {
            importance: 88,
            satisfaction: 82,
            comments: [
              "Charts are intuitive and informative",
              "Would like more export options",
              "The comparative analysis view is excellent",
              "Need better filtering options",
              "Interactive elements enhance understanding"
            ]
          },
          "Integration capabilities": {
            importance: 90,
            satisfaction: 72,
            comments: [
              "API documentation is comprehensive",
              "Need more pre-built connectors with popular HR tools",
              "The Slack integration works well",
              "Would like to see more webhook options",
              "SSO implementation was straightforward"
            ]
          },
          "Reporting features": {
            importance: 87,
            satisfaction: 80,
            comments: [
              "Executive summaries are excellent",
              "Need more customizable reports",
              "The trend analysis is particularly valuable",
              "Would like scheduled report delivery",
              "PDF export quality needs improvement"
            ]
          },
          "Data security & compliance": {
            importance: 96,
            satisfaction: 89,
            comments: [
              "GDPR compliance features are comprehensive",
              "Role-based access controls work well",
              "Would like more detailed audit logging",
              "Encryption standards exceed our requirements",
              "Data retention policies are flexible and configurable"
            ]
          },
          "Talent insights": {
            importance: 92,
            satisfaction: 86,
            comments: [
              "Predictive turnover analysis is extremely valuable",
              "Skills gap identification is impressively accurate",
              "Employee growth trajectory mapping needs refinement",
              "The engagement correlation analysis is unique",
              "Would like more industry-specific benchmarking"
            ]
          },
          "Implementation & onboarding": {
            importance: 84,
            satisfaction: 79,
            comments: [
              "Implementation timeline was shorter than expected",
              "Training materials are comprehensive and well-structured",
              "Need more role-specific onboarding paths",
              "Customer success team was exceptionally responsive",
              "Data migration tools could be more flexible"
            ]
          },
          "Analytics & AI capabilities": {
            importance: 93,
            satisfaction: 83,
            comments: [
              "Pattern recognition in large datasets is impressive",
              "Predictive modeling seems accurate in our context",
              "Need more transparency in AI decision-making",
              "The anomaly detection has proven valuable",
              "Would like more control over algorithm parameters"
            ]
          },
          "Mobile experience": {
            importance: 75,
            satisfaction: 68,
            comments: [
              "Works well on tablets",
              "Smartphone experience is limited",
              "Need offline capabilities",
              "App feels more responsive than mobile web",
              "Limited functionality compared to desktop"
            ]
          }
        },
        competitiveComparisons: {
          "Traditional assessment tools": 85,
          "Other AI-powered solutions": 78,
          "In-house developed tools": 90,
          "Manual screening processes": 95,
          "DiSC assessments": 82,
          "Myers-Briggs Type Indicator": 76,
          "Predictive Index": 70,
          "Hogan Assessment": 74,
          "Caliper Profile": 68,
          "Leadership assessment platforms": 83,
          "Microsoft Viva Insights": 79,
          "Workday Talent Optimization": 77,
          "Culture Amp": 80,
          "IBM Kenexa": 71,
          "SAP SuccessFactors": 81,
          "Lattice": 75,
          "15Five": 72,
          "Qualtrics EmployeeXM": 84,
          "TalentLMS": 69,
          "Glint": 78,
          "BambooHR": 73,
          "Factorial HR": 67,
          "ADP Workforce Now": 70,
          "UKG Pro": 75
        },
        participantQuotes: [
          "This would cut our hiring time in half and improve quality of our candidate selection.",
          "I'm concerned about algorithm bias in personality assessment. How do you ensure fairness?",
          "The team compatibility feature could transform how we organize projects and assign responsibilities.",
          "We especially valued the ability to compare candidates against successful employees in similar roles.",
          "The dashboard gives me instant insights that used to take weeks to compile manually.",
          "Our department leaders have been skeptical of personality assessments, but this data is changing their minds.",
          "Integration with our existing HRIS was seamless, which was a pleasant surprise.",
          "The most valuable aspect is seeing how different personalities complement each other in team settings.",
          "Our turnover has decreased 15% since implementing the recommendations from the system.",
          "I appreciate the scientific basis behind the assessments  it gives us confidence in the results.",
          "The mobile capabilities need improvement, especially for reviewing results on the go.",
          "Having historical data and being able to track personality changes over time is incredibly valuable."
        ]
      };
      
      // Adjust values based on the product concept to make it seem dynamic
      if (productConcept && productConcept.trim() !== '') {
        const conceptLower = productConcept.toLowerCase();
        
        // Adjust sentiment based on keywords in product concept
        if (conceptLower.includes('ai') || conceptLower.includes('machine learning') || conceptLower.includes('artificial intelligence')) {
          demoFocusGroup.overallSentiment = Math.min(88, demoFocusGroup.overallSentiment + 6);
          demoFocusGroup.keyThemes["Innovation factor"] = 92;
          demoFocusGroup.keyThemes["Technology adoption"] = 86;
          demoFocusGroup.suggestedImprovements.unshift("Provide more transparency into AI decision-making process");
          demoFocusGroup.featureFeedback["AI capabilities"] = {
            importance: 94,
            satisfaction: 82,
            comments: [
              "Impressive predictive capabilities",
              "Need more explanation of how AI derives its conclusions",
              "Would like to see continuous improvement based on our data",
              "Algorithm seems to have biases we'd like to address",
              "The pattern recognition is extremely valuable"
            ]
          };
        }
        
        if (conceptLower.includes('dashboard') || conceptLower.includes('analytics') || conceptLower.includes('visualization')) {
          demoFocusGroup.overallSentiment = Math.min(86, demoFocusGroup.overallSentiment + 4);
          demoFocusGroup.keyThemes["Data visualization"] = 88;
          demoFocusGroup.keyThemes["Reporting capabilities"] = 85;
          demoFocusGroup.suggestedImprovements.unshift("Enhance dashboard customization with drag-and-drop widgets");
          demoFocusGroup.featureFeedback["Analytics dashboard"] = {
            importance: 92,
            satisfaction: 80,
            comments: [
              "Visuals are clean and professional",
              "Need more customizable reporting options",
              "The export functionality is limited",
              "Data drill-down capabilities are excellent",
              "Would like to see more comparative analysis features"
            ]
          };
        }
        
        if (conceptLower.includes('mobile') || conceptLower.includes('app') || conceptLower.includes('smartphone')) {
          demoFocusGroup.overallSentiment = Math.min(84, demoFocusGroup.overallSentiment + 2);
          demoFocusGroup.keyThemes["Accessibility"] = 86;
          demoFocusGroup.keyThemes["Mobile experience"] = 78;
          demoFocusGroup.suggestedImprovements.unshift("Develop native mobile apps for iOS and Android with offline capabilities");
          demoFocusGroup.featureFeedback["Mobile access"] = {
            importance: 85,
            satisfaction: 68,
            comments: [
              "Limited functionality on smaller screens",
              "Need offline capability for field use",
              "The responsive design works well on tablets",
              "Loading time on mobile needs improvement",
              "Mobile notifications would be a valuable addition"
            ]
          };
        }
        
        if (conceptLower.includes('team') || conceptLower.includes('collaboration') || conceptLower.includes('group')) {
          demoFocusGroup.overallSentiment = Math.min(87, demoFocusGroup.overallSentiment + 5);
          demoFocusGroup.keyThemes["Team dynamics"] = 90;
          demoFocusGroup.keyThemes["Collaboration tools"] = 84;
          demoFocusGroup.suggestedImprovements.unshift("Add real-time collaboration features for team assessment sessions");
          demoFocusGroup.featureFeedback["Team collaboration"] = {
            importance: 91,
            satisfaction: 76,
            comments: [
              "The team matching algorithm is impressively accurate",
              "Need better visualization of team relationships",
              "Would benefit from conflict prediction capabilities",
              "Shared dashboards for team leaders are valuable",
              "Team-building recommendation engine is a standout feature"
            ]
          };
        }
        
        if (conceptLower.includes('integration') || conceptLower.includes('api') || conceptLower.includes('connect')) {
          demoFocusGroup.overallSentiment = Math.min(83, demoFocusGroup.overallSentiment + 1);
          demoFocusGroup.keyThemes["Integration capabilities"] = 82;
          demoFocusGroup.keyThemes["Ecosystem connectivity"] = 79;
          demoFocusGroup.suggestedImprovements.unshift("Expand API capabilities with more granular data access");
          demoFocusGroup.featureFeedback["System integration"] = {
            importance: 88,
            satisfaction: 74,
            comments: [
              "API documentation is thorough and well-structured",
              "Need more pre-built connectors to popular HR systems",
              "The webhook functionality is limited",
              "Data synchronization sometimes has delays",
              "SSO implementation was straightforward"
            ]
          };
        }
        
        // Add a product-specific suggestion that combines product concept with industry best practices
        demoFocusGroup.suggestedImprovements.unshift(`Consider enhancing ${productConcept} with more collaborative features and industry-specific templates`);
        
        // Adjust purchase intent based on product concept keywords (more sophisticated than just length)
        let intentBoost = 0;
        
        if (conceptLower.includes('ai') || conceptLower.includes('machine learning')) intentBoost += 4;
        if (conceptLower.includes('analytics') || conceptLower.includes('insights')) intentBoost += 3;
        if (conceptLower.includes('team') || conceptLower.includes('collaboration')) intentBoost += 3;
        if (conceptLower.includes('integration') || conceptLower.includes('connectivity')) intentBoost += 2;
        if (conceptLower.includes('dashboard') || conceptLower.includes('visualization')) intentBoost += 2;
        if (conceptLower.includes('mobile') || conceptLower.includes('app')) intentBoost += 1;
        
        // Apply the combined boost with a cap
        demoFocusGroup.purchaseIntent = Math.min(95, demoFocusGroup.purchaseIntent + intentBoost);
        
        // Also adjust value perception
        demoFocusGroup.valuePerception = Math.min(92, demoFocusGroup.valuePerception + Math.floor(intentBoost * 0.8));
      }
      
      return demoFocusGroup;
    }
    console.log(`Running focus group simulation for company ID: ${companyId} with product concept: ${productConcept}`);
    
    try {
      // Get company info directly with SQL
      const companies = await db.execute(sql`
        SELECT * FROM companies WHERE id = ${companyId}
      `);
      
      // Convert to array if needed
      const companiesArray = Array.isArray(companies) ? companies : [companies];
      const company = companiesArray.length > 0 ? companiesArray[0] : null;
      
      if (!company) {
        throw new Error(`Company with ID ${companyId} not found`);
      }
      
      // Get customer segments for this company
      const segments = await this.getCustomerSegments(companyId);
      
      // Get survey responses for this company with SQL
      const responsesResult = await db.execute(sql`
        SELECT * FROM survey_responses 
        WHERE company_id = ${companyId}
      `);
      
      // Convert to array if needed
      const responses = Array.isArray(responsesResult) ? responsesResult : 
                        responsesResult && typeof responsesResult === 'object' ? [responsesResult] : [];
      
      // Define segment types based on customer segments or defaults
      const segmentNames = segments.length > 0 
        ? segments.slice(0, 3).map(segment => segment.name)
        : ['Early Adopters', 'Pragmatists', 'Business Users'];
      
      // Analyze product concept to determine features and focus areas
      const concept = productConcept.toLowerCase();
      
      // Extract key feature areas from concept
      const featureAreas = [];
      
      if (concept.includes('ai') || concept.includes('machine learning') || concept.includes('algorithm')) {
        featureAreas.push('AI', 'Automation', 'Intelligence');
      }
      
      if (concept.includes('integration') || concept.includes('connect') || concept.includes('api')) {
        featureAreas.push('Integration', 'Connectivity', 'Ecosystem');
      }
      
      if (concept.includes('dashboard') || concept.includes('visual') || concept.includes('report')) {
        featureAreas.push('Visualization', 'Reporting', 'Analytics');
      }
      
      if (concept.includes('team') || concept.includes('collaboration') || concept.includes('sharing')) {
        featureAreas.push('Collaboration', 'Team Features', 'Sharing');
      }
      
      if (concept.includes('custom') || concept.includes('personalization') || concept.includes('config')) {
        featureAreas.push('Customization', 'Personalization', 'Flexibility');
      }
      
      if (concept.includes('mobile') || concept.includes('app') || concept.includes('phone')) {
        featureAreas.push('Mobile', 'App', 'On-the-go');
      }
      
      // Default feature areas if none detected
      if (featureAreas.length === 0) {
        featureAreas.push('Usability', 'Performance', 'Functionality');
      }
      
      // Analyze sentiment towards these feature areas from survey responses
      const featureAreaSentiment = {};
      featureAreas.forEach(area => {
        featureAreaSentiment[area] = {
          positive: 0,
          negative: 0,
          total: 0
        };
      });
      
      // Count sentiment mentions in responses
      responses.forEach(response => {
        if (response.responses && typeof response.responses === 'object') {
          const responseValues = Object.values(response.responses);
          
          featureAreas.forEach(area => {
            const areaLower = area.toLowerCase();
            
            // Check if this area is mentioned in responses
            const hasMention = responseValues.some(value => 
              typeof value === 'string' && value.toLowerCase().includes(areaLower)
            );
            
            if (hasMention) {
              featureAreaSentiment[area].total++;
              
              // Use satisfaction score as sentiment proxy
              if (response.satisfactionScore) {
                if (response.satisfactionScore >= 7) {
                  featureAreaSentiment[area].positive++;
                } else {
                  featureAreaSentiment[area].negative++;
                }
              }
            }
          });
        }
      });
      
      // Create feedback for each segment
      const feedback = [];
      
      // Get personality traits for each segment to tailor feedback
      const segmentTraits = {};
      
      if (segments.length > 0) {
        segments.slice(0, 3).forEach(segment => {
          if (segment.dominantTraits && Array.isArray(segment.dominantTraits)) {
            segmentTraits[segment.name] = segment.dominantTraits;
          } else {
            segmentTraits[segment.name] = [];
          }
        });
      }
      
      // Helper to get sentiment-based adoption likelihood
      const getAdoptionLikelihood = (segmentName) => {
        // Base adoption between 50-80%
        let adoption = 65;
        
        // Adjust based on traits if available
        const traits = segmentTraits[segmentName] || [];
        
        // Early adopters are more likely to adopt new technology
        if (segmentName.includes('Early') || segmentName.includes('Innovator')) {
          adoption += 10;
        }
        
        // Pragmatists are more cautious
        if (segmentName.includes('Pragmatist') || segmentName.includes('Mainstream')) {
          adoption -= 5;
        }
        
        // Adjust based on traits
        if (traits.includes('Innovative') || traits.includes('Risk-Taking')) {
          adoption += 8;
        }
        
        if (traits.includes('Conservative') || traits.includes('Cautious')) {
          adoption -= 10;
        }
        
        // Add some randomness
        adoption += Math.floor(Math.random() * 11) - 5; // -5 to +5
        
        // Keep in reasonable range
        return Math.min(90, Math.max(40, adoption));
      };
      
      // Generate tailored feedback for each segment
      segmentNames.forEach((segmentName, index) => {
        // Determine positive and negative points based on feature areas
        const positivePoints = [];
        const negativePoints = [];
        const improvements = [];
        
        // Sort feature areas by sentiment
        const sortedAreas = [...featureAreas].sort((a, b) => {
          const aRatio = featureAreaSentiment[a].total > 0 
            ? featureAreaSentiment[a].positive / featureAreaSentiment[a].total 
            : 0.5;
          const bRatio = featureAreaSentiment[b].total > 0 
            ? featureAreaSentiment[b].positive / featureAreaSentiment[b].total 
            : 0.5;
          return bRatio - aRatio;
        });
        
        // Take top areas for positive points (more for early adopters)
        const posCount = index === 0 ? 3 : 2;
        sortedAreas.slice(0, posCount).forEach(area => {
          switch (area) {
            case 'AI':
              positivePoints.push('Innovative AI-driven approach');
              break;
            case 'Automation':
              positivePoints.push('Impressive automation capabilities');
              break;
            case 'Integration':
              positivePoints.push('Excellent integration options');
              break;
            case 'Connectivity':
              positivePoints.push('Seamless connectivity with existing tools');
              break;
            case 'Visualization':
              positivePoints.push('Intuitive visual interface');
              break;
            case 'Reporting':
              positivePoints.push('Comprehensive reporting functionality');
              break;
            case 'Collaboration':
              positivePoints.push('Strong team collaboration features');
              break;
            case 'Customization':
              positivePoints.push('Highly customizable interface');
              break;
            case 'Mobile':
              positivePoints.push('Well-designed mobile experience');
              break;
            default:
              positivePoints.push(`Strong ${area.toLowerCase()} capabilities`);
          }
        });
        
        // Additional positive points for early adopters
        if (index === 0) {
          positivePoints.push('Cutting-edge approach to solving problems');
        }
        
        // Add standard positive point based on segment
        if (segmentName.includes('Early') || segmentName.includes('Innovator')) {
          positivePoints.push('Novel approach with high innovation potential');
        } else if (segmentName.includes('Pragmatist') || segmentName.includes('Business')) {
          positivePoints.push('Clear business value proposition');
        } else {
          positivePoints.push('Addresses key pain points effectively');
        }
        
        // Handle negative points (more for pragmatists)
        const negCount = index === 1 ? 3 : 2;
        sortedAreas.slice(-negCount).forEach(area => {
          switch (area) {
            case 'AI':
              negativePoints.push('AI features need more transparency');
              improvements.push('Provide more explainable AI features');
              break;
            case 'Automation':
              negativePoints.push('Automation could be more intuitive');
              improvements.push('Simplify automation setup process');
              break;
            case 'Integration':
              negativePoints.push('More integration options needed');
              improvements.push('Expand integration ecosystem');
              break;
            case 'Visualization':
              negativePoints.push('Visualizations could be more customizable');
              improvements.push('Add more visualization options');
              break;
            case 'Reporting':
              negativePoints.push('Reporting features need enhancement');
              improvements.push('Develop more advanced reporting capabilities');
              break;
            case 'Collaboration':
              negativePoints.push('Team features lack depth');
              improvements.push('Enhance team collaboration tools');
              break;
            case 'Customization':
              negativePoints.push('More customization options needed');
              improvements.push('Increase customization flexibility');
              break;
            case 'Mobile':
              negativePoints.push('Mobile experience needs improvement');
              improvements.push('Enhance mobile app functionality');
              break;
            default:
              negativePoints.push(`${area} features need refinement`);
              improvements.push(`Improve ${area.toLowerCase()} capabilities`);
          }
        });
        
        // Common concerns by segment
        if (segmentName.includes('Early') || segmentName.includes('Innovator')) {
          negativePoints.push('Could offer more advanced features');
          improvements.push('Add more cutting-edge functionality');
        } else if (segmentName.includes('Pragmatist') || segmentName.includes('Business')) {
          negativePoints.push('ROI clarity needs improvement');
          improvements.push('Provide clearer ROI calculation tools');
        } else {
          negativePoints.push('Onboarding process could be simplified');
          improvements.push('Streamline the onboarding experience');
        }
        
        // Add segment-specific improvements
        if (index === 0) { // Early Adopters
          improvements.push('Offer early access to new features');
        } else if (index === 1) { // Pragmatists
          improvements.push('Include more case studies and social proof');
        } else { // Business Users
          improvements.push('Add more enterprise integration options');
        }
        
        // Calculate adoption likelihood
        const adoptionLikelihood = getAdoptionLikelihood(segmentName);
        
        // Add to feedback array
        feedback.push({
          segmentName,
          positivePoints,
          negativePoints,
          adoptionLikelihood,
          suggestedImprovements: improvements
        });
      });
      
      // Calculate overall sentiment
      let totalSentiment = 0;
      let sentimentCount = 0;
      
      // Average adoption likelihood across segments
      feedback.forEach(segmentFeedback => {
        totalSentiment += segmentFeedback.adoptionLikelihood;
        sentimentCount++;
      });
      
      const overallSentiment = sentimentCount > 0 ? 
        Math.round(totalSentiment / sentimentCount) : 
        70; // Default if no data
      
      // Generate key insights based on feedback patterns
      const keyInsights = [];
      
      // Look for common positives
      const allPositives = feedback.flatMap(f => f.positivePoints);
      const allNegatives = feedback.flatMap(f => f.negativePoints);
      const allImprovements = feedback.flatMap(f => f.suggestedImprovements);
      
      // Check if any feature area is mentioned frequently
      featureAreas.forEach(area => {
        const positiveCount = allPositives.filter(p => p.toLowerCase().includes(area.toLowerCase())).length;
        const negativeCount = allNegatives.filter(p => p.toLowerCase().includes(area.toLowerCase())).length;
        
        if (positiveCount > negativeCount && positiveCount >= 2) {
          keyInsights.push(`${area} features are particularly well-received`);
        } else if (negativeCount > positiveCount && negativeCount >= 2) {
          keyInsights.push(`${area} capabilities need significant improvement`);
        }
      });
      
      // Add insights based on segment adoption patterns
      const earlyAdopterFeedback = feedback[0];
      const pragmatistFeedback = feedback.length > 1 ? feedback[1] : null;
      
      if (earlyAdopterFeedback && pragmatistFeedback) {
        const adoptionGap = earlyAdopterFeedback.adoptionLikelihood - pragmatistFeedback.adoptionLikelihood;
        
        if (adoptionGap > 15) {
          keyInsights.push('Significant adoption gap between early adopters and mainstream users');
        } else if (adoptionGap < 5) {
          keyInsights.push('Product has mainstream appeal beyond just early adopters');
        }
      }
      
      // Add specific concept-related insight
      const conceptFeature = concept.includes('integration') ? 'integration' : 
                          concept.includes('automation') ? 'automation' : 
                          'customization';
      
      keyInsights.push(`Adding more ${conceptFeature} features would increase appeal`);
      
      // Add price sensitivity insight
      const pricePointMentions = allNegatives.filter(n => 
        n.toLowerCase().includes('price') || 
        n.toLowerCase().includes('cost') || 
        n.toLowerCase().includes('expensive')
      ).length;
      
      if (pricePointMentions >= 1) {
        keyInsights.push('Price sensitivity varies significantly by segment');
      }
      
      // Make sure we have at least 4 insights
      if (keyInsights.length < 4) {
        keyInsights.push('Value proposition needs to be clearer for mainstream adoption');
      }
      
      // Limit to 5 insights
      const limitedInsights = keyInsights.slice(0, 5);
      
      // Construct focus group simulation result
      const focusGroupResult = {
        id: `fg-${Date.now()}`,
        productConcept,
        segments: segmentNames,
        feedback,
        overallSentiment,
        keyInsights: limitedInsights
      };
      
      return focusGroupResult;
    } catch (error) {
      console.error(`Error running focus group simulation for company ${companyId}:`, error);
      throw error;
    }
  }
}

export const storage = new DatabaseStorage();
