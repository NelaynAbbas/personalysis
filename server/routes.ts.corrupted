import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import sessionMiddleware from "./middleware/sessionMiddleware";
import logger from "./utils/logger";
import { 
  insertSurveyResponseSchema, 
  insertUserSchema, 
  insertCompanySchema, 
  insertSubscriptionSchema,
  insertInvoiceSchema,
  insertPaymentTransactionSchema,
  insertClientSchema,
  insertNotificationSchema,
  insertIntegrationSchema,
  insertClientSurveyDeploymentSchema,
  type PersonalityTrait, 
  type GenderStereotype, 
  type ProductRecommendation,
  type Demographics,
  type Invoice,
  type Subscription,
  type PaymentTransaction,
  type NotificationType,
  type Client,
  type InsertClient,
  type Integration,
  type InsertIntegration,
  type ClientSurveyDeployment,
  type InsertClientSurveyDeployment,
  UserRole,
  Permission,
  type CollaborationAction,
  SubscriptionTier,
  type SupportTicket,
  type InsertSupportTicket,
  type SupportTicketComment,
  type InsertSupportTicketComment,
  type License,
  type InsertLicense,
  insertLicenseSchema,
  TicketStatus,
  TicketPriority,
  TicketType,
  LicenseType,
  LicenseStatus,
  IntegrationType,
  IntegrationStatus
} from "../shared/schema";
import { WebSocketServer, WebSocket } from "ws";
import { z } from "zod";
import { ZodError } from "zod";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { 
  generateAIPersonalityInsight, 
  generateAIProductRecommendations, 
  generateAICareerInsights,
  generateAIDigitalBehaviorInsights,
  generateAIEmotionalIntelligenceInsights,
  generateAIComprehensiveTraitAnalysis,
  generateAISurveyRecommendations,
  type SurveyRecommendation
} from "./gemini";
import { AppError } from './middleware/errorHandler';
import { AuthenticatedRequest, hashPassword, verifyPassword } from './auth';
import { registerDeploymentRoutes } from './routes/deployments';
// Import statements already at the top

// For ES modules, we need to define __dirname this way
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function registerRoutes(app: Express): Promise<Server> {
  // Create HTTP server
  const httpServer = createServer(app);

  // Set up WebSocket server
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });

  // Map to store active connections by session and user ID
  // The sessionId is stored as a string because WebSocket messages send it as a string
  const activeConnections = new Map<string, Map<number, WebSocket>>();

  /**
   * Wraps async route handlers to catch exceptions and forward to error middleware
   * This eliminates the need for try/catch blocks in every route handler
   */
  const asyncHandler = 
    (fn: Function) => 
    (req: Request, res: Response, next: NextFunction) => {
      Promise.resolve(fn(req, res, next))
        .catch((err) => {
          // Log the error with structured data
          logger.error(`Route error: ${req.method} ${req.path}`, err, {
            url: req.originalUrl,
            method: req.method,
            ip: req.ip,
          });

          // Special handling for validation errors
          if (err instanceof ZodError) {
            return res.status(400).json({ 
              status: 'error',
              message: "Validation error", 
              errors: err.errors 
            });
          }

          // If it's already an AppError, pass it through to the error handler middleware
          if (err instanceof AppError) {
            return next(err);
          }

          // Convert to AppError with appropriate status code
          const statusCode = err.statusCode || 500;
          const message = err.message || 'Internal Server Error';
          return next(new AppError(message, statusCode));
        });
    };

  // ============================================================================
  // AUTHENTICATION ROUTES
  // ============================================================================

  // Login route
  app.post("/api/auth/login", asyncHandler(async (req: Request, res: Response) => {
    try {
      // In a real app, we would use passport.authenticate
      const { username, password } = req.body;

      if (!username || !password) {
        return res.status(400).json({ message: "Username and password are required" });
      }

      const user = await storage.getUserByUsername(username);

      if (!user) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // In a real app, we would compare hashed passwords
      if (password !== user.password) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Record IP and user agent for security audit trail
      const ipAddress = req.ip || req.headers['x-forwarded-for'] || 'unknown';
      const userAgent = req.headers['user-agent'] || 'unknown';
      logger.security(`User ${user.id} (${user.username}) logged in from ${ipAddress} with ${userAgent}`, req);
      
      // Update last login timestamp (would update in the database in a real app)
      // await storage.updateUserLastLogin(user.id);
      
      // Initialize enhanced session with our dedicated session middleware
      if (req.session) {
        // Use our centralized session initialization for consistency
        sessionMiddleware.initializeSession(req, user.id, user.role, user.companyId || 0);
      }

      // Return user info without sensitive data
      return res.status(200).json({
        id: user.id,
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        companyId: user.companyId,
        profilePic: user.profilePic
      });
    } catch (error) {
      logger.error("Login error", error as Error, { route: '/api/auth/login' });
      return res.status(500).json({ status: 'error', message: "Authentication error" });
    }
  }));

  // Logout route
  app.post("/api/auth/logout", (req: Request, res: Response) => {
    // Record security event before destroying the session
    if (req.session && req.session.userId) {
      const userId = req.session.userId;
      const ipAddress = req.ip || req.headers['x-forwarded-for'] || 'unknown';
      const userAgent = req.headers['user-agent'] || 'unknown';
      
      // Log the logout event for security audit
      logger.security(`User ${userId} logged out from ${ipAddress} with ${userAgent}`, req);
      
      // In a real app, we would also update the user's last activity in the database
      // await storage.updateUserLastActivity(userId, 'LOGOUT');
    }
    
    req.session.destroy((err) => {
      if (err) {
        logger.error("Logout error", err as Error, { route: '/api/auth/logout' });
        return res.status(500).json({ status: 'error', message: "Logout failed" });
      }

      res.clearCookie("connect.sid");
      return res.status(200).json({ status: 'success', message: "Logged out successfully" });
    });
  });

  // Get current user info
  app.get("/api/auth/me", asyncHandler(async (req: Request, res: Response) => {
    // First check for valid authentication
    if (!req.session || !req.session.userId) {
      logger.info("Unauthenticated access attempt to /api/auth/me", { 
        ip: req.ip || req.headers['x-forwarded-for'] || 'unknown'
      });
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    // Get session config (same constants as in sessionMiddleware)
    const SESSION_IDLE_TIMEOUT = 30 * 60 * 1000; // 30 minutes in milliseconds
    const SESSION_ABSOLUTE_TIMEOUT = 8 * 60 * 60 * 1000; // 8 hours in milliseconds

    // Session configuration from environment or defaults
    const sessionConfig = {
      idleTimeout: process.env.SESSION_IDLE_TIMEOUT 
        ? parseInt(process.env.SESSION_IDLE_TIMEOUT) 
        : SESSION_IDLE_TIMEOUT,
      absoluteTimeout: process.env.SESSION_ABSOLUTE_TIMEOUT 
        ? parseInt(process.env.SESSION_ABSOLUTE_TIMEOUT) 
        : SESSION_ABSOLUTE_TIMEOUT,
      enableAbsoluteTimeout: process.env.ENABLE_ABSOLUTE_TIMEOUT === 'true'
    };
    
    // Verify session hasn't timed out (redundant with sessionMiddleware, but included as defense in depth)
    const now = Date.now();
    const lastActivity = req.session.lastActivity || 0;
    const sessionAge = now - (req.session.createdAt || 0);
    
    // If session is too old, force re-authentication
    if (sessionAge > sessionConfig.absoluteTimeout && sessionConfig.enableAbsoluteTimeout) {
      logger.security(`Session absolute timeout exceeded during /me check: ${sessionAge}ms`, req);
      req.session.destroy(() => {});
      return res.status(401).json({ message: "Session expired. Please login again." });
    }
    
    // If idle for too long, force re-authentication
    if ((now - lastActivity) > sessionConfig.idleTimeout) {
      logger.security(`Session idle timeout exceeded during /me check: ${now - lastActivity}ms`, req);
      req.session.destroy(() => {});
      return res.status(401).json({ message: "Session timed out due to inactivity. Please login again." });
    }

    const user = await storage.getUserById(req.session.userId);

    if (!user) {
      // Session refers to a user that no longer exists
      logger.security(`Session for non-existent user ID ${req.session.userId}`, req);
      req.session.destroy((err) => {
        if (err) logger.error("Error destroying invalid session", err as Error, { route: '/api/auth/me' });
      });
      return res.status(401).json({ message: "User not found" });
    }
    
    // Check if user account is still active
    if (user.isActive === false) {
      logger.security(`Inactive user account ${user.id} tried to access /api/auth/me`, req);
      req.session.destroy(() => {});
      return res.status(403).json({ message: "Account deactivated. Please contact support." });
    }

    // Update last activity time
    req.session.lastActivity = now;
    
    // Return user info without sensitive data
    return res.status(200).json({
      id: user.id,
      username: user.username,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      companyId: user.companyId,
      profilePic: user.profilePic
    });
  }));

  // Register new user
  app.post("/api/auth/register", asyncHandler(async (req: Request, res: Response) => {
    try {
      const { username, email, password, firstName, lastName, companyId, role } = req.body;

      // Check if user already exists
      const existingUser = await storage.getUserByUsername(username);
      if (existingUser) {
        return res.status(409).json({ message: "Username already exists" });
      }

      // In a real app, we would hash the password
      const newUser = await storage.createUser({
        username,
        email: email || username, // Use username as email if not provided
        password, // In real app, this would be hashed
        firstName,
        lastName,
        companyId,
        role: role || "BUSINESS_USER", // Default role
        // isActive is set to true by default in the schema
        // createdAt and updatedAt are automatically set
      });

      // Return the created user without sensitive data
      return res.status(201).json({
        id: newUser.id,
        username: newUser.username,
        email: newUser.email,
        firstName: newUser.firstName,
        lastName: newUser.lastName,
        role: newUser.role,
        companyId: newUser.companyId
      });
    } catch (error) {
      logger.error("Registration error", error as Error, { route: '/api/auth/register' });
      return res.status(500).json({ status: 'error', message: "Registration failed" });
    }
  }));

  // Request password reset
  app.post("/api/auth/forgot-password", asyncHandler(async (req: Request, res: Response) => {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ message: "Email is required" });
    }

    const user = await storage.getUserByUsername(email);

    // For security reasons, always return success even if user doesn't exist
    // This prevents enumeration attacks
    if (!user) {
      return res.status(200).json({ 
        message: "If your email is registered, you will receive a password reset link shortly." 
      });
    }

    // In a real app, we would:
    // 1. Generate a secure token
    // 2. Store it with an expiration
    // 3. Send an email with a reset link

    return res.status(200).json({ 
      message: "If your email is registered, you will receive a password reset link shortly." 
    });
  }));

  // Reset password
  app.post("/api/auth/reset-password", asyncHandler(async (req: Request, res: Response) => {
    const { token, password } = req.body;

    if (!token || !password) {
      return res.status(400).json({ message: "Token and new password are required" });
    }

    // In a real app, we would:
    // 1. Verify the token is valid and not expired
    // 2. Find the user associated with the token
    // 3. Update their password (hashed)
    // 4. Invalidate the token

    return res.status(200).json({ message: "Password has been reset successfully" });
  }));

  // CSRF token generation
  app.get("/api/auth/csrf-token", (req: Request, res: Response) => {
    // In a real app, we would generate a secure token and store it in the session
    const csrfToken = Math.random().toString(36).substring(2, 15);

    // For demo purposes, we just return a random token
    return res.status(200).json({ csrfToken });
  });

  // ============================================================================
  // USER ROUTES
  // ============================================================================
  
  // Get all users for agent dropdown (admin only)
  app.get("/api/users/agents", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // Only allow admin users to fetch all agents
    if (user.role !== UserRole.BUSINESS_ADMIN && user.role !== UserRole.PLATFORM_ADMIN) {
      return res.status(403).json({ success: false, message: "Unauthorized access" });
    }
    
    // Get all users that can be assigned to tickets
    const users = await storage.getAllUsers();
    
    // Filter out sensitive information and return only what's needed for the dropdown
    const agents = users.map(user => ({
      id: user.id,
      name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username,
      email: user.email,
      role: user.role
    }));
    
    return res.json({ success: true, agents });
  }));

  // ============================================================================
  // SYSTEM MONITORING ROUTES
  // ============================================================================

  // Get system performance metrics (admin only)
  app.get("/api/system/performance", asyncHandler(async (req: Request, res: Response) => {
    // In development mode, don't require admin for easier testing
    if (process.env.NODE_ENV === 'production') {
      if (!req.session || !req.session.userRole || req.session.userRole !== "ADMIN") {
        return res.status(403).json({ message: "Unauthorized: Admin access required" });
      }
    }

    // Import the performance monitoring utility
    const { getPerformanceStats, getSystemHealth } = await import('./utils/performance');
    
    // Get current memory usage for accurate real-time data
    const memoryUsage = process.memoryUsage();

    // Get system metrics
    const metrics = {
      memory: {
        rss: Math.round(memoryUsage.rss / 1024 / 1024), // RSS in MB
        heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024), // Heap total in MB
        heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024), // Heap used in MB
        external: Math.round(memoryUsage.external / 1024 / 1024), // External in MB
      },
      uptime: process.uptime(),
      performance: {
        endpoints: {},
        overall: {
          totalRequests: 0,
          successfulRequests: 0,
          failedRequests: 0,
          averageResponseTime: 0
        }
      },
      cache: {
        hits: 0,
        misses: 0,
        size: 0,
        groups: {}
      },
      rateLimiter: {
        activeKeys: 0,
        limitsByEndpoint: {}
      },
      activeConnections: {
        total: Array.from(activeConnections.values())
          .reduce((sum, connections) => sum + connections.size, 0)
      },
      health: getSystemHealth()
    };
    
    // Get the latest performance stats including CPU and memory metrics
    const perfStats = getPerformanceStats();
    if (perfStats) {
      metrics.performance = perfStats;
    }

    res.json(metrics);
  }));

  // ============================================================================
  // MAIN API ROUTES
  // ============================================================================

  // Create a new survey
  app.post("/api/surveys", asyncHandler(async (req: Request, res: Response) => {
    const { 
      title, 
      description, 
      welcomeMessage, 
      completionMessage,
      surveyType,
      templateId,
      estimatedTime,
      enableAIInsights,
      enableSocialSharing,
      responseLimit,
      surveyLanguage,
      allowAnonymous,
      demographics
    } = req.body;

    if (!title || !surveyType) {
      return res.status(400).json({ message: "Survey title and type are required" });
    }

    // Get the user ID from the session
    const userId = (req.session as any).userId || 1; // Default to demo user for testing
    
    // Get the user to get their company ID
    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(403).json({ message: "User not found" });
    }
    
    // Prepare the survey data
    const surveyData = {
      title,
      description,
      welcomeMessage,
      completionMessage,
      surveyType,
      templateId,
      estimatedTime: estimatedTime || 10,
      enableAIInsights: enableAIInsights ?? true,
      enableSocialSharing: enableSocialSharing ?? true,
      responseLimit: responseLimit || 1000,
      surveyLanguage: surveyLanguage || 'en',
      allowAnonymous: allowAnonymous ?? true,
      demographics: demographics || {},
      status: 'draft', // Start as draft
      createdById: userId,
      companyId: user.companyId || 1 // Use the user's company ID or default to demo company
    };

    // Save the survey to storage
    const newSurvey = await storage.createSurvey(surveyData);

    res.status(201).json(newSurvey);
  }));

  // Get all surveys
  app.get("/api/surveys", asyncHandler(async (req: Request, res: Response) => {
    // Get the user ID from the session
    const userId = (req.session as any).userId || 1; // Default to demo user for testing
    
    // Get the user to get their company ID
    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(403).json({ message: "User not found" });
    }
    
    const companyId = user.companyId || 1;
    
    // Get all surveys for the company
    const surveys = await storage.getSurveysByCompany(companyId);
    
    // If there are no surveys yet, provide some default data for demo purposes
    if (surveys.length === 0) {
      const mockSurveys = [
        {
          id: 1,
          title: "Customer Personality Assessment",
          description: "Understand your customers' personality traits",
          surveyType: "Personality Profile",
          status: "active",
          responseCount: 86,
          companyId: companyId,
          createdAt: new Date(new Date().setDate(new Date().getDate() - 15)),
          updatedAt: new Date(),
          estimatedTime: 8
        },
        {
          id: 2,
          title: "Employee Innovation Mindset",
          description: "Evaluate innovation potential and creative thinking",
          surveyType: "Innovation Mindset",
          status: "active",
          responseCount: 42,
          companyId: companyId,
          createdAt: new Date(new Date().setDate(new Date().getDate() - 5)),
          updatedAt: new Date(),
          estimatedTime: 7
        },
        {
          id: 3,
          title: "Digital Behavior Assessment",
          description: "Analyze digital usage patterns and tech adoption",
          surveyType: "Digital Behavior",
          status: "draft",
          responseCount: 0,
          companyId: companyId,
          createdAt: new Date(),
          updatedAt: new Date(),
          estimatedTime: 6
        }
      ];
      
      // Save the demo surveys to storage
      for (const survey of mockSurveys) {
        await storage.createSurvey(survey);
      }
      
      // Get the surveys again after creating the demos
      return res.json(await storage.getSurveysByCompany(companyId));
    }
    
    res.json(surveys);
  }));

  // Share a survey
  app.post("/api/survey/share", asyncHandler(async (req: Request, res: Response) => {
    const { surveyId, emails, message, title, customTitle, customDescription, platform } = req.body;

    // Check if this is an email sharing request
    if (emails && emails.length > 0) {
      // In a real application, we would send emails to the recipients
      // For this demo, we'll simulate successful email sending
      console.log(`Email invites would be sent to: ${emails.join(', ')}`);
      console.log(`Email subject: ${title}`);
      console.log(`Email message: ${message}`);

      // Return success response
      return res.json({
        success: true,
        message: `${emails.length} email invitations would be sent`,
        sentTo: emails
      });
    }

    // This is a regular sharing request (social media, link, etc.)
    const shareId = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
    const actualSurveyId = surveyId || shareId;
    const companyId = req.body.companyId || 1;
    const surveyType = req.body.surveyType || 'general';

    // Create the shareable link with the share ID - this uses the anonymous survey view
    const baseUrl = `${req.protocol}://${req.get('host')}`;
    const shareableLink = `${baseUrl}/take-survey/${shareId}`;

    // For specific platforms, generate specialized links
    const socialLinks = {
      direct: shareableLink,
      facebook: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareableLink)}`,
      linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(shareableLink)}`,
      twitter: `https://twitter.com/intent/tweet?url=${encodeURIComponent(shareableLink)}`
    };

    // Store the survey share data in memory (in a real app, this would be in a database)
    const shareData = {
      shareId,
      surveyId: actualSurveyId,
      companyId,
      surveyType,
      customSettings: {
        title: customTitle || title || undefined,
        description: customDescription || message || undefined
      },
      createdAt: new Date()
    };
    
    // Add to a global map to retrieve later when the survey is accessed
    if (!global.surveyShares) {
      global.surveyShares = new Map();
    }
    global.surveyShares.set(shareId, shareData);

    // Return the share data and links
    res.json({ 
      success: true, 
      shareId,
      surveyId: actualSurveyId,
      surveyType: surveyType,
      customSettings: {
        title: customTitle || title || undefined,
        description: customDescription || message || undefined
      },
      links: socialLinks 
    });
  }));

  // Get survey details by share ID
  app.get("/api/survey/details/:shareId", asyncHandler(async (req: Request, res: Response) => {
    const { shareId } = req.params;
    
    if (!shareId) {
      return res.status(400).json({ message: "Invalid share ID" });
    }

    // Get the survey data from the global map
    if (!global.surveyShares || !global.surveyShares.has(shareId)) {
      return res.status(404).json({ message: "Shared survey not found" });
    }

    const shareData = global.surveyShares.get(shareId);
    
    // Get company info if available
    let companyInfo = null;
    if (shareData.companyId) {
      try {
        const company = await storage.getCompany(shareData.companyId);
        if (company) {
          companyInfo = {
            name: company.name,
            logo: company.logo || null,
            website: company.website || null
          };
        }
      } catch (error) {
        console.error(`Error fetching company info for ID ${shareData.companyId}:`, error);
      }
    }
    
    // Return the share data
    res.json({
      ...shareData,
      companyInfo
    });
  }));

  // Get survey by ID
  app.get("/api/surveys/:id", asyncHandler(async (req: Request, res: Response) => {
    const surveyId = parseInt(req.params.id);
    if (isNaN(surveyId)) {
      return res.status(400).json({ message: "Invalid survey ID" });
    }

    // Get the survey from storage
    const survey = await storage.getSurvey(surveyId);

    if (!survey) {
      return res.status(404).json({ message: "Survey not found" });
    }

    res.json(survey);
  }));
  
  // Update survey template
  app.put("/api/surveys/:id", asyncHandler(async (req: Request, res: Response) => {
    const surveyId = parseInt(req.params.id);
    if (isNaN(surveyId)) {
      return res.status(400).json({ message: "Invalid survey ID" });
    }
    
    // Check if the survey exists
    const existingSurvey = await storage.getSurvey(surveyId);
    if (!existingSurvey) {
      return res.status(404).json({ message: "Survey not found" });
    }
    
    // Update the survey
    const updatedSurvey = {
      ...req.body,
      id: surveyId,
      updatedAt: new Date().toISOString()
    };
    
    const result = await storage.updateSurvey(updatedSurvey);
    res.json({ success: true, data: result });
  }));
  
  // Delete survey template
  app.delete("/api/surveys/:id", asyncHandler(async (req: Request, res: Response) => {
    const surveyId = parseInt(req.params.id);
    if (isNaN(surveyId)) {
      return res.status(400).json({ message: "Invalid survey ID" });
    }
    
    // Check if the survey exists
    const existingSurvey = await storage.getSurvey(surveyId);
    if (!existingSurvey) {
      return res.status(404).json({ message: "Survey not found" });
    }
    
    // Delete the survey
    await storage.deleteSurvey(surveyId);
    res.json({ success: true, message: "Survey deleted successfully" });
  }));

  // Get survey questions
  app.get("/api/survey/questions", asyncHandler(async (req: Request, res: Response) => {
    // Return the general questions or the specific type if requested
    const surveyType = req.query.type as string || 'general';
    const surveyQuestions = await import("../client/src/lib/surveyQuestions");

    // Get questions for the requested type, or default to general
    const questions = surveyQuestions.surveyTypes[surveyType as keyof typeof surveyQuestions.surveyTypes] || 
                      surveyQuestions.surveyTypes.general;

    res.json(questions);
  }));

  // Start a new survey session
  app.post("/api/survey/start", asyncHandler(async (req: Request, res: Response) => {
    const companyId = req.body.companyId || 1; // Default to demo company if not specified
    const surveyType = req.body.surveyType || 'general'; // Get survey type or default to general
    const surveyId = req.body.surveyId ? parseInt(req.body.surveyId) : 1; // Get specific survey ID

    // Create a new survey response record
    const newResponse = await storage.createSurveyResponse({
      companyId,
      surveyId,
      respondentId: `user-${Date.now()}`,
      responses: [],
      traits: [],
      demographics: {} // Initialize empty demographics
    });

    res.json({ 
      sessionId: newResponse.id,
      respondentId: newResponse.respondentId,
      surveyType
    });
  }));

  // Submit a survey answer
  app.post("/api/survey/answer", asyncHandler(async (req: Request, res: Response) => {
    const schema = z.object({
      sessionId: z.number(),
      questionId: z.number(),
      answer: z.string()
    });

    const { sessionId, questionId, answer } = schema.parse(req.body);

    const surveyResponse = await storage.getSurveyResponse(sessionId);
    if (!surveyResponse) {
      return res.status(404).json({ message: "Survey session not found" });
    }

    // Update the responses array
    const responses = Array.isArray(surveyResponse.responses) ? [...surveyResponse.responses] : [];

    // Check if this question was already answered
    const existingIndex = responses.findIndex((r: any) => r.questionId === questionId);
    if (existingIndex >= 0) {
      responses[existingIndex] = { questionId, answer };
    } else {
      responses.push({ questionId, answer });
    }

    await storage.updateSurveyResponse(sessionId, { 
      responses
    });

    res.json({ success: true });
  }));

  // Complete survey and generate personality traits
  app.post("/api/survey/complete", asyncHandler(async (req: Request, res: Response) => {
    const schema = z.object({
      sessionId: z.number(),
      demographicInfo: z.object({
        age: z.number().optional(),
        gender: z.string().optional(),
        location: z.string().optional(),
        education: z.string().optional(),
        income: z.string().optional(),
        occupation: z.string().optional(),
        interests: z.array(z.string()).optional()
      }).optional()
    });

    const { sessionId, demographicInfo } = schema.parse(req.body);

    const surveyResponse = await storage.getSurveyResponse(sessionId);
    if (!surveyResponse) {
      return res.status(404).json({ message: "Survey session not found" });
    }

    // Generate personality traits based on responses
    const traits = await generatePersonalityTraits(surveyResponse.responses as any[]);

    // Generate gender stereotypes based on traits
    const genderStereotypes = generateGenderStereotypes(traits);

    // Generate product recommendations based on traits
    const productRecommendations = generateProductRecommendations(traits);

    // Determine market segment based on traits
    const marketSegment = determineMarketSegment(traits);

    // Update the survey response with traits, demographic info, etc.
    await storage.updateSurveyResponse(sessionId, {
      traits,
      demographics: demographicInfo || {},
      completed: true
    });

    res.json({ 
      success: true, 
      sessionId,
      traitCount: traits.length
    });
  }));

  // Get survey results
  app.get("/api/survey/results/:sessionId", asyncHandler(async (req: Request, res: Response) => {
    try {
      const sessionId = parseInt(req.params.sessionId);
      if (isNaN(sessionId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid session ID" 
        });
      }
  
      const surveyResponse = await storage.getSurveyResponse(sessionId);
      if (!surveyResponse) {
        return res.status(404).json({ 
          success: false, 
          message: "Survey results not found" 
        });
      }
      
      // Check if traits are available and valid
      let traits = [];
      if (surveyResponse.traits && Array.isArray(surveyResponse.traits)) {
        // Filter out any potentially invalid traits
        traits = surveyResponse.traits.filter(trait => 
          trait && typeof trait === 'object' && 
          trait.name && typeof trait.name === 'string' &&
          typeof trait.score === 'number'
        );
        
        if (traits.length === 0 && surveyResponse.traits.length > 0) {
          logger.warn(`Found ${surveyResponse.traits.length} traits in the database for session ${sessionId}, but all were invalid`);
        }
      } else {
        logger.warn(`No valid traits found for survey session ${sessionId}`);
      }
  
      // Safely generate derived data using our defensive implementations
      const genderStereotypes = generateGenderStereotypes(traits as PersonalityTrait[]);
      const productRecommendations = generateProductRecommendations(traits as PersonalityTrait[]);
      const marketSegment = determineMarketSegment(traits as PersonalityTrait[]);
  
      // Ensure demographics is an object, even if empty
      const demographics = surveyResponse.demographics && typeof surveyResponse.demographics === 'object' 
        ? surveyResponse.demographics 
        : {};
  
      // Log information about the results being sent
      logger.info(`Sending survey results for session ${sessionId} with ${traits.length} traits, ` +
        `${productRecommendations.length} product recommendations, and market segment: ${marketSegment}`);
  
      return res.json({
        success: true,
        sessionId,
        respondentId: surveyResponse.respondentId,
        traits: traits,
        demographics: demographics,
        genderStereotypes,
        productRecommendations,
        marketSegment
      });
    } catch (error) {
      logger.error("Error fetching survey results:", error as Error);
      return res.status(500).json({ 
        success: false, 
        message: "Failed to retrieve survey results",
        error: (error as Error).message 
      });
    }
  }));

  // ============================================================================
  // AI INSIGHTS API ROUTES
  // ============================================================================

  // Get AI insights for a survey response
  app.get("/api/survey/ai-insights/:sessionId", asyncHandler(async (req: Request, res: Response) => {
    try {
      const sessionId = parseInt(req.params.sessionId);
      if (isNaN(sessionId)) {
        return res.status(400).json({ 
          success: false, 
          message: "Invalid session ID" 
        });
      }
  
      // Check if GEMINI_API_KEY is set - required for AI insights
      if (!process.env.GEMINI_API_KEY) {
        logger.warn("GEMINI_API_KEY is not set. AI insights will not work properly.");
        return res.status(503).json({ 
          success: false,
          message: "AI insights service is currently unavailable. Please try again later.",
          error: "Missing API key configuration"
        });
      }
  
      const surveyResponse = await storage.getSurveyResponse(sessionId);
      if (!surveyResponse) {
        return res.status(404).json({ 
          success: false, 
          message: "Survey response not found" 
        });
      }
  
      // Get the insight type from query params
      const insightType = req.query.type as string || 'personality';
      
      // Check if traits are available and valid
      let traits = [];
      if (surveyResponse.traits && Array.isArray(surveyResponse.traits)) {
        // Filter out any potentially invalid traits
        traits = surveyResponse.traits.filter(trait => 
          trait && typeof trait === 'object' && 
          trait.name && typeof trait.name === 'string' &&
          typeof trait.score === 'number'
        );
        
        if (traits.length === 0 && surveyResponse.traits.length > 0) {
          logger.warn(`Found ${surveyResponse.traits.length} traits in the database for session ${sessionId}, but all were invalid`);
        }
      } else {
        logger.warn(`No valid traits found for survey session ${sessionId}`);
      }
      
      // Check if we have enough traits to generate insights
      if (traits.length === 0) {
        logger.warn(`Cannot generate AI insights for session ${sessionId} - no valid traits found`);
        return res.status(400).json({
          success: false,
          message: "Cannot generate insights: no valid personality traits found for this session"
        });
      }
  
      // Ensure demographics is an object, even if empty
      const demographics = surveyResponse.demographics && typeof surveyResponse.demographics === 'object' 
        ? surveyResponse.demographics as Demographics
        : {};
  
      let insight = "";
  
      // Generate the appropriate insight based on the requested type
      logger.info(`Generating ${insightType} AI insight for session ${sessionId} with ${traits.length} traits`);
      switch(insightType) {
        case 'personality':
          insight = await generateAIPersonalityInsight(traits as PersonalityTrait[], demographics);
          break;
        case 'product':
          insight = await generateAIProductRecommendations(traits as PersonalityTrait[], demographics);
          break;
        case 'career':
          insight = await generateAICareerInsights(traits as PersonalityTrait[], demographics);
          break;
        case 'digital':
          insight = await generateAIDigitalBehaviorInsights(traits as PersonalityTrait[], demographics);
          break;
        case 'emotional':
          insight = await generateAIEmotionalIntelligenceInsights(traits as PersonalityTrait[], demographics);
          break;
        case 'comprehensive':
          insight = await generateAIComprehensiveTraitAnalysis(traits as PersonalityTrait[], demographics);
          break;
        default:
          logger.info(`Unknown insight type '${insightType}', defaulting to 'personality'`);
          insight = await generateAIPersonalityInsight(traits as PersonalityTrait[], demographics);
      }
  
      // Ensure insight is not empty or invalid
      if (!insight || typeof insight !== 'string' || insight.trim().length === 0) {
        logger.warn(`Generated empty or invalid insight for session ${sessionId} with type ${insightType}`);
        insight = `We couldn't generate detailed ${insightType} insights at this time. Please try again later.`;
      }
  
      return res.json({
        success: true,
        sessionId,
        insightType,
        insight
      });
    } catch (error) {
      logger.error("Error generating AI insights:", error as Error);
      return res.status(500).json({ 
        success: false, 
        message: "Failed to generate AI insights",
        error: (error as Error).message 
      });
    }
  }));
  
  // Get AI-powered survey recommendations based on user preferences
  app.get("/api/survey/recommendations", asyncHandler(async (req: Request, res: Response) => {
    try {
      // Check if GEMINI_API_KEY is set
      if (!process.env.GEMINI_API_KEY) {
        logger.warn("GEMINI_API_KEY is not set. AI recommendations will not work properly.");
        return res.status(503).json({ 
          message: "AI recommendations service is currently unavailable. Please try again later.",
          error: "Missing API key configuration"
        });
      }
      
      // Get user ID from session (default to demo user if not available)
      const userId = req.session?.userId || 1;
      
      // Parse query parameters with proper type handling
      const userPreferences = {
        interests: req.query.interests ? (req.query.interests as string).split(',') : undefined,
        industry: req.query.industry as string,
        preferredLength: req.query.preferredLength as ('short' | 'medium' | 'long'),
        preferredTopics: req.query.topics ? (req.query.topics as string).split(',') : undefined,
        userType: req.query.userType as ('personal' | 'business' | 'academic'),
        
        // Get limit as number with fallback
        limit: req.query.limit ? parseInt(req.query.limit as string) : 3
      };
      
      // Get user from storage to enhance recommendations with their history
      const user = await storage.getUserById(userId);
      
      // Enhance preferences with user data if available
      if (user) {
        // Get user's completed surveys from the past
        const userSurveys = await storage.getSurveysByUser(userId);
        
        if (userSurveys && userSurveys.length > 0) {
          userPreferences.previousSurveys = userSurveys.map(survey => ({
            id: survey.id.toString(),
            title: survey.title,
            type: survey.surveyType
          }));
        }
        
        // If we have stored demographic data for the user, add it
        const userProfile = await storage.getUserProfile(userId);
        if (userProfile?.demographics) {
          userPreferences.demographicData = userProfile.demographics as Demographics;
        }
      }
      
      // Generate recommendations using AI
      const recommendations = await generateAISurveyRecommendations(
        userPreferences as any, 
        userPreferences.limit || 3
      );
      
      // Return the recommendations
      return res.json({
        success: true,
        count: recommendations.length,
        recommendations
      });
    } catch (error) {
      logger.error("Error generating survey recommendations", error as Error);
      return res.status(500).json({ 
        message: "Failed to generate survey recommendations",
        error: (error as Error).message 
      });
    }
  }));

  // ============================================================================
  // COMPANY ANALYTICS API ROUTES
  // ============================================================================

  // Get company analytics
  app.get("/api/company/:companyId/analytics", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get analytics for the company
    const analytics = await storage.getCompanyStats(companyId);

    res.json(analytics);
  }));

  // Get company survey responses
  app.get("/api/company/:companyId/responses", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get survey responses for the company
    const responses = await storage.getSurveyResponsesForCompany(companyId);

    res.json(responses);
  }));

  // Export company data
  app.get("/api/company/:companyId/export", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get survey responses for the company
    const responses = await storage.getSurveyResponsesForCompany(companyId);

    // Format the data for export
    const exportData = {
      company: {
        id: company.id,
        name: company.name,
        email: company.email
      },
      responses: responses.map(response => ({
        id: response.id,
        respondentId: response.respondentId,
        respondentEmail: response.respondentEmail,
        surveyId: response.surveyId,
        createdAt: response.createdAt,
        traits: response.traits,
        demographics: response.demographics
      }))
    };

    // Set appropriate headers for download
    res.setHeader('Content-Disposition', `attachment; filename=company-${companyId}-data.json`);
    res.setHeader('Content-Type', 'application/json');

    res.json(exportData);
  }));

  // ============================================================================
  // BUSINESS ANALYSIS API ROUTES
  // ============================================================================

  // Get competitor analysis
  app.get("/api/company/:companyId/competitors", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get competitor analysis for the company
    const competitors = await storage.getCompetitorAnalysis(companyId);

    res.json(competitors);
  }));

  // Get market fit analysis
  app.get("/api/company/:companyId/market-fit/:productId", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const productId = req.params.productId;

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get market fit analysis for the company and product
    const marketFit = await storage.getMarketFitAnalysis(companyId, productId);

    res.json(marketFit);
  }));

  // Get customer segments
  app.get("/api/company/:companyId/segments", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get customer segments for the company
    const segments = await storage.getCustomerSegments(companyId);

    res.json(segments);
  }));

  // Get product feature priorities
  app.get("/api/company/:companyId/feature-priorities", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get product feature priorities for the company
    const priorities = await storage.getProductFeaturePriorities(companyId);

    res.json(priorities);
  }));

  // Get pricing strategies
  app.get("/api/company/:companyId/pricing-strategies", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get pricing strategies for the company
    const strategies = await storage.getPricingStrategies(companyId);

    res.json(strategies);
  }));

  // Get marketing strategies
  app.get("/api/company/:companyId/marketing-strategies", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get marketing strategies for the company
    const strategies = await storage.getMarketingStrategies(companyId);

    res.json(strategies);
  }));

  // Get revenue forecasts
  app.get("/api/company/:companyId/revenue-forecasts", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Get revenue forecasts for the company
    const forecasts = await storage.getRevenueForecasts(companyId);

    res.json(forecasts);
  }));

  // Simulate focus group
  app.post("/api/company/:companyId/focus-group", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    const { productConcept } = req.body;
    if (!productConcept) {
      return res.status(400).json({ message: "Product concept is required" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Simulate focus group for the company and product concept    const focusGroup = await storage.getFocusGroupSimulation(companyId, productConcept);

    res.json(focusGroup);
  }));

  // ============================================================================
  // BILLING API ROUTES
  // ============================================================================

  // Get company subscription
  app.get("/api/company/:companyId/subscription", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Verify user has permission to manage billing for this company
    const hasPermission = await storage.hasPermission(req.session.userId, Permission.MANAGE_BILLING);
    if (!hasPermission && req.session.userRole !== UserRole.PLATFORM_ADMIN && req.session.userRole !== UserRole.PLATFORM_BILLING) {
      return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Sample subscription data
    const subscription = {
      id: 1,
      companyId,
      planType: company.subscriptionTier,
      status: company.licenseStatus,
      startDate: company.licenseStartDate,
      endDate: company.licenseEndDate,
      autoRenew: true,
      billingCycle: "annual",
      amount: company.subscriptionTier === SubscriptionTier.BASIC ? 4900 : 
              company.subscriptionTier === SubscriptionTier.PROFESSIONAL ? 14900 : 
              company.subscriptionTier === SubscriptionTier.ENTERPRISE ? 49900 : 0,
      currency: "USD",
      features: {
        maxUsers: company.maxUsers,
        maxSurveys: company.maxSurveys,
        maxResponses: company.maxResponses,
        maxStorage: company.maxStorage,
        customBranding: company.customBranding,
        aiInsights: company.aiInsights,
        advancedAnalytics: company.advancedAnalytics,
        dataExport: company.dataExport
      }
    };

    res.json(subscription);
  }));

  // Update company subscription
  app.post("/api/company/:companyId/subscription", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Verify user has permission to manage billing for this company
    const hasPermission = await storage.hasPermission(req.session.userId, Permission.MANAGE_SUBSCRIPTION);
    if (!hasPermission && req.session.userRole !== UserRole.PLATFORM_ADMIN && req.session.userRole !== UserRole.PLATFORM_BILLING) {
      return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
    }

    // Validate input
    const { planType, billingCycle, autoRenew } = req.body;
    if (!planType || !Object.values(SubscriptionTier).includes(planType)) {
      return res.status(400).json({ message: "Valid plan type is required" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // In a real app, we would update the subscription in the database
    // For this demo, just return the updated subscription

    // Update the company subscription tier
    // In a real app, this would be persisted to the database
    const updatedSubscription = {
      id: 1,
      companyId,
      planType,
      status: "active",
      startDate: new Date(),
      endDate: new Date(new Date().setFullYear(new Date().getFullYear() + 1)),
      autoRenew: autoRenew !== undefined ? autoRenew : true,
      billingCycle: billingCycle || "annual",
      amount: planType === SubscriptionTier.BASIC ? 4900 : 
              planType === SubscriptionTier.PROFESSIONAL ? 14900 : 
              planType === SubscriptionTier.ENTERPRISE ? 49900 : 0,
      currency: "USD",
      features: {
        maxUsers: planType === SubscriptionTier.BASIC ? 10 : 
                 planType === SubscriptionTier.PROFESSIONAL ? 50 : 
                 planType === SubscriptionTier.ENTERPRISE ? 250 : 3,
        maxSurveys: planType === SubscriptionTier.BASIC ? 5 : 
                    planType === SubscriptionTier.PROFESSIONAL ? 25 : 
                    planType === SubscriptionTier.ENTERPRISE ? 100 : 2,
        maxResponses: planType === SubscriptionTier.BASIC ? 1000 : 
                     planType === SubscriptionTier.PROFESSIONAL ? 10000 : 
                     planType === SubscriptionTier.ENTERPRISE ? 100000 : 100,
        maxStorage: planType === SubscriptionTier.BASIC ? 10 : 
                   planType === SubscriptionTier.PROFESSIONAL ? 50 : 
                   planType === SubscriptionTier.ENTERPRISE ? 250 : 5,
        customBranding: planType !== SubscriptionTier.BASIC && planType !== SubscriptionTier.TRIAL,
        aiInsights: planType === SubscriptionTier.PROFESSIONAL || planType === SubscriptionTier.ENTERPRISE,
        advancedAnalytics: planType === SubscriptionTier.PROFESSIONAL || planType === SubscriptionTier.ENTERPRISE,
        dataExport: planType !== SubscriptionTier.TRIAL
      }
    };

    // In a real app, create a record of this change in audit logs
    logger.info("Subscription updated", { 
      companyId, 
      userId: req.session.userId,
      planType, 
      billingCycle 
    });

    res.json(updatedSubscription);
  }));

  // Get company invoices
  app.get("/api/company/:companyId/invoices", asyncHandler(async (req: Request, res: Response) => {
    const companyId = parseInt(req.params.companyId);
    if (isNaN(companyId)) {
      return res.status(400).json({ message: "Invalid company ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Verify user has permission to view billing information for this company
    const hasPermission = await storage.hasPermission(req.session.userId, Permission.MANAGE_BILLING);
    if (!hasPermission && req.session.userRole !== UserRole.PLATFORM_ADMIN && req.session.userRole !== UserRole.PLATFORM_BILLING) {
      return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
    }

    const company = await storage.getCompany(companyId);
    if (!company) {
      return res.status(404).json({ message: "Company not found" });
    }

    // Fetch invoices from database
    const invoices = await storage.getCompanyInvoices(companyId);
    
    res.json(invoices);
  }));

  // Get invoice details
  app.get("/api/invoices/:invoiceId", asyncHandler(async (req: Request, res: Response) => {
    const invoiceId = parseInt(req.params.invoiceId);
    if (isNaN(invoiceId)) {
      return res.status(400).json({ message: "Invalid invoice ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Fetch the invoice from the database
    const invoice = await storage.getInvoiceById(invoiceId);
    
    if (!invoice) {
      return res.status(404).json({ message: "Invoice not found" });
    }
    
    // Verify user has permission to view this invoice
    // If user is not a platform admin or billing admin, they should only see their own company's invoices
    if (req.session.userRole !== UserRole.PLATFORM_ADMIN && 
        req.session.userRole !== UserRole.PLATFORM_BILLING) {
      const user = await storage.getUserById(req.session.userId);
      if (!user || user.companyId !== invoice.companyId) {
        return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
      }
    }

    res.json(invoice);
  }));

  // Process payment
  app.post("/api/invoices/:invoiceId/pay", asyncHandler(async (req: Request, res: Response) => {
    const invoiceId = parseInt(req.params.invoiceId);
    if (isNaN(invoiceId)) {
      return res.status(400).json({ message: "Invalid invoice ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Verify payment details from request body
    const { paymentMethod, paymentToken, billingAddress } = req.body;
    if (!paymentMethod || !paymentToken) {
      return res.status(400).json({ message: "Payment method and token are required" });
    }

    // Verify the invoice exists and is unpaid
    const invoice = await storage.getInvoiceById(invoiceId);
    
    if (!invoice) {
      return res.status(404).json({ message: "Invoice not found" });
    }
    
    if (invoice.status === 'paid') {
      return res.status(400).json({ message: "Invoice is already paid" });
    }
    
    // Verify user has permission to pay this invoice
    if (req.session.userRole !== UserRole.PLATFORM_ADMIN && 
        req.session.userRole !== UserRole.PLATFORM_BILLING) {
      const user = await storage.getUserById(req.session.userId);
      if (!user || user.companyId !== invoice.companyId) {
        return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
      }
    }
    
    // Process the payment with a payment gateway would happen here in a real app
    // For now, we'll just simulate the payment success
    
    // Process the payment
    try {
      // Pay the invoice in the database
      const updatedInvoice = await storage.payInvoice(invoiceId, {
        paymentMethod,
        paymentToken,
        userId: req.session.userId
      });
      
      // Get the transaction that was created
      const transactions = await storage.getInvoiceTransactions(invoiceId);
      const transaction = transactions[0]; // The most recent transaction
      
      logger.info("Payment processed", { 
        invoiceId, 
        userId: req.session.userId,
        transactionId: transaction.transactionId,
        amount: transaction.amount
      });
  
      res.json({
        success: true,
        transaction,
        invoice: updatedInvoice
      });
    } catch (error) {
      logger.error("Payment failed", { 
        invoiceId, 
        userId: req.session.userId, 
        error: error.message 
      });
      res.status(500).json({ 
        success: false, 
        message: "Payment processing failed", 
        error: error.message 
      });
    }
  }));

  // Generate invoice PDF (download)
  app.get("/api/invoices/:invoiceId/pdf", asyncHandler(async (req: Request, res: Response) => {
    const invoiceId = parseInt(req.params.invoiceId);
    if (isNaN(invoiceId)) {
      return res.status(400).json({ message: "Invalid invoice ID" });
    }

    // Check if user has permission
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }

    // Fetch the invoice from the database
    const invoice = await storage.getInvoiceById(invoiceId);
    
    if (!invoice) {
      return res.status(404).json({ message: "Invoice not found" });
    }
    
    // Verify user has permission to view this invoice
    if (req.session.userRole !== UserRole.PLATFORM_ADMIN && 
        req.session.userRole !== UserRole.PLATFORM_BILLING) {
      const user = await storage.getUserById(req.session.userId);
      if (!user || user.companyId !== invoice.companyId) {
        return res.status(403).json({ message: "Unauthorized: Insufficient permissions" });
      }
    }

    // Get company information for the invoice
    const company = await storage.getCompany(invoice.companyId);
    if (!company) {
      return res.status(500).json({ message: "Company information not found" });
    }
    
    // In a real application, we would generate a PDF here
    // For this demo, we'll simulate the download by returning JSON
    res.json({
      success: true,
      message: `Invoice #${invoiceId} PDF for ${company.name} would be generated and downloaded in a real application`,
      invoice: invoice
    });
  }));

  // ============================================================================
  // PERMISSIONS API ROUTES
  // ============================================================================

  // Get role permissions
  app.get("/api/roles/:role/permissions", asyncHandler(async (req: Request, res: Response) => {
    const role = req.params.role;

    // Get permissions for the role
    const permissions = await storage.getRolePermissions(role);

    res.json(permissions);
  }));

  // Check if a user has a specific permission
  app.get("/api/users/:userId/has-permission/:permission", asyncHandler(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const permission = req.params.permission;

    // Check if the user has the permission
    const hasPermission = await storage.hasPermission(userId, permission);

    res.json({ hasPermission });
  }));

  // Get user permissions
  app.get("/api/users/:userId/permissions", asyncHandler(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    // Get permissions for the user
    const permissions = await storage.getUserPermissions(userId);

    res.json(permissions);
  }));

  // Grant a permission to a user
  app.post("/api/users/:userId/permissions/:permission", asyncHandler(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.userId);
    if (isNaN(userId)) {
      return res.status(400).json({ message: "Invalid user ID" });
    }

    const permission = req.params.permission;

    // Grant the permission to the user
    const userPermission = await storage.createUserPermission({
      userId,
      permission,
      grantedBy: req.body.grantedById || 1,
      granted: true
    });

    res.json(userPermission);
  }));

  // ============================================================================
  // SUPPORT TICKET ROUTES
  // ============================================================================
  
  // Create a new support ticket
  app.post("/api/support/tickets", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const { companyId, subject, description, priority, type, dueDate, tags, attachments } = req.body;
    
    const ticket = await storage.createSupportTicket({
      companyId,
      userId: req.session.userId,
      subject,
      description,
      priority: priority || TicketPriority.MEDIUM,
      type: type || TicketType.GENERAL,
      status: TicketStatus.NEW,
      dueDate: dueDate ? new Date(dueDate) : null,
      assignedToId: null,
      tags: tags ? JSON.stringify(tags) : null,
      attachments: attachments ? JSON.stringify(attachments) : null
    });
    
    return res.json({ success: true, ticket });
  }));
  
  // Get all support tickets (filtered by company or all for admins)
  app.get("/api/support/tickets", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // If user has appropriate permission, they can see all tickets
    const hasAdminAccess = await storage.hasPermission(user.id, Permission.MANAGE_SUPPORT);
    
    let tickets: SupportTicket[];
    
    if (hasAdminAccess) {
      // Admin can see all tickets
      // In a real app, we'd add filtering by company, status, etc.
      tickets = Array.from(storage.supportTickets.values());
    } else {
      // Regular users only see their company's tickets
      tickets = await storage.getCompanySupportTickets(user.companyId!);
    }
    
    return res.json({ success: true, tickets });
  }));

  // Get tickets assigned to the current user
  app.get("/api/support/tickets/assigned", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const assignedTickets = await storage.getAssignedSupportTickets(req.session.userId);
    
    return res.json({ success: true, tickets: assignedTickets });
  }));
  
  // Get a specific ticket by ID
  app.get("/api/support/tickets/:id", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const ticketId = parseInt(req.params.id);
    const ticket = await storage.getSupportTicket(ticketId);
    
    if (!ticket) {
      return res.status(404).json({ success: false, message: "Ticket not found" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // Check if user has permission to view this ticket
    const hasAdminAccess = await storage.hasPermission(user.id, Permission.MANAGE_SUPPORT);
    const isCompanyTicket = user.companyId === ticket.companyId;
    
    if (!hasAdminAccess && !isCompanyTicket) {
      return res.status(403).json({ success: false, message: "You don't have permission to view this ticket" });
    }
    
    return res.json({ success: true, ticket });
  }));
  
  // Update a ticket
  app.patch("/api/support/tickets/:id", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const ticketId = parseInt(req.params.id);
    const ticket = await storage.getSupportTicket(ticketId);
    
    if (!ticket) {
      return res.status(404).json({ success: false, message: "Ticket not found" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // Check if user has permission to update this ticket
    const hasAdminAccess = await storage.hasPermission(user.id, Permission.MANAGE_SUPPORT);
    const isCompanyTicket = user.companyId === ticket.companyId;
    
    if (!hasAdminAccess && !isCompanyTicket) {
      return res.status(403).json({ success: false, message: "You don't have permission to update this ticket" });
    }
    
    // Restrict what regular users can update vs. admins
    const { subject, description, status, priority, type, dueDate, assignedToId, tags, attachments } = req.body;
    
    const updateData: Partial<InsertSupportTicket> = {};
    
    // Regular users can only update certain fields
    if (isCompanyTicket) {
      if (subject) updateData.subject = subject;
      if (description) updateData.description = description;
      if (tags) updateData.tags = JSON.stringify(tags);
      if (attachments) updateData.attachments = JSON.stringify(attachments);
      
      // Regular users can only set the status to CLOSED if it's already RESOLVED
      if (status === TicketStatus.CLOSED && ticket.status === TicketStatus.RESOLVED) {
        updateData.status = TicketStatus.CLOSED;
      }
    }
    
    // Admins can update all fields
    if (hasAdminAccess) {
      if (subject) updateData.subject = subject;
      if (description) updateData.description = description;
      if (status) updateData.status = status;
      if (priority) updateData.priority = priority;
      if (type) updateData.type = type;
      if (dueDate) updateData.dueDate = new Date(dueDate);
      if (assignedToId !== undefined) updateData.assignedToId = assignedToId;
      if (tags) updateData.tags = JSON.stringify(tags);
      if (attachments) updateData.attachments = JSON.stringify(attachments);
    }
    
    const updatedTicket = await storage.updateSupportTicket(ticketId, updateData);
    
    return res.json({ success: true, ticket: updatedTicket });
  }));
  
  // Add a comment to a ticket
  app.post("/api/support/tickets/:id/comments", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const ticketId = parseInt(req.params.id);
    const ticket = await storage.getSupportTicket(ticketId);
    
    if (!ticket) {
      return res.status(404).json({ success: false, message: "Ticket not found" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // Check if user has permission to comment on this ticket
    const hasAdminAccess = await storage.hasPermission(user.id, Permission.MANAGE_SUPPORT);
    const isCompanyTicket = user.companyId === ticket.companyId;
    
    if (!hasAdminAccess && !isCompanyTicket) {
      return res.status(403).json({ success: false, message: "You don't have permission to comment on this ticket" });
    }
    
    const { content, isInternal, attachments } = req.body;
    
    // Only admins can create internal comments
    const commentIsInternal = hasAdminAccess && isInternal === true;
    
    const comment = await storage.createTicketComment({
      ticketId,
      userId: user.id,
      content,
      isInternal: commentIsInternal,
      attachments: attachments ? JSON.stringify(attachments) : null
    });
    
    return res.json({ success: true, comment });
  }));
  
  // Get comments for a ticket
  app.get("/api/support/tickets/:id/comments", asyncHandler(async (req: Request, res: Response) => {
    // Ensure user is authenticated
    if (!req.session.userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    
    const ticketId = parseInt(req.params.id);
    const ticket = await storage.getSupportTicket(ticketId);
    
    if (!ticket) {
      return res.status(404).json({ success: false, message: "Ticket not found" });
    }
    
    const user = await storage.getUserById(req.session.userId);
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found" });
    }
    
    // Check if user has permission to view this ticket's comments
    const hasAdminAccess = await storage.hasPermission(user.id, Permission.MANAGE_SUPPORT);
    const isCompanyTicket = user.companyId === ticket.companyId;
    
    if (!hasAdminAccess && !isCompanyTicket) {
      return res.status(403).json({ success: false, message: "You don't have permission to view this ticket's comments" });
    }
    
    // Include internal comments only for admins
    const comments = await storage.getTicketComments(ticketId, hasAdminAccess);
    
    return res.json({ success: true, comments });
  }));

  // ============================================================================
  // REAL-TIME COLLABORATION - WEBSOCKET HANDLING
  // ============================================================================

  wss.on('connection', (ws: WebSocket) => {
    console.log('WebSocket client connected');

    ws.on('message', async (message: string) => {
      try {
        const data = JSON.parse(message);

        if (!data.action || !data.sessionId) {
          ws.send(JSON.stringify({ error: 'Invalid message format' }));
          return;
        }

        // Handle the collaboration action
        switch (data.action) {
          case 'join':
            // A user is joining a collaboration session
            if (!data.userId) {
              ws.send(JSON.stringify({ error: 'userId is required to join a session' }));
              return;
            }

            // Add to active connections
            if (!activeConnections.has(data.sessionId)) {
              activeConnections.set(data.sessionId, new Map());
            }

            activeConnections.get(data.sessionId)!.set(data.userId, ws);

            // Get or create the session
            let session = await storage.getCollaborationSession(parseInt(data.sessionId));

            if (!session) {
              // Create a new session if it doesn't exist
              session = await storage.createCollaborationSession({
                surveyId: data.surveyId,
                createdById: data.userId,
                isActive: true,
                metadata: data.metadata || {}
              });
            }

            // Add the participant to the session
            await storage.addParticipantToSession({
              sessionId: parseInt(data.sessionId),
              userId: data.userId,
              status: 'active',
              color: getRandomColor()
            });

            // Get all participants in the session
            const participants = await storage.getSessionParticipants(parseInt(data.sessionId));

            // Notify all participants about the new user
            broadcastToSession(parseInt(data.sessionId), {
              action: 'participant_joined',
              sessionId: data.sessionId,
              userId: data.userId,
              participants
            });

            // Send session history to the new participant
            const recentChanges = await storage.getCollaborationChanges(
              parseInt(data.sessionId), 
              new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
            );

            ws.send(JSON.stringify({
              action: 'session_history',
              sessionId: data.sessionId,
              session,
              participants,
              changes: recentChanges
            }));
            break;

          case 'leave':
            // A user is leaving a collaboration session
            if (!data.userId) {
              ws.send(JSON.stringify({ error: 'userId is required to leave a session' }));
              return;
            }

            // Remove from active connections
            if (activeConnections.has(data.sessionId)) {
              activeConnections.get(data.sessionId)!.delete(data.userId);

              // If no more connections for this session, clean up
              if (activeConnections.get(data.sessionId)!.size === 0) {
                activeConnections.delete(data.sessionId);
              }
            }

            // Update participant status
            await storage.updateParticipantStatus(
              parseInt(data.sessionId),
              data.userId,
              'inactive'
            );

            // Get updated list of participants
            const remainingParticipants = await storage.getSessionParticipants(parseInt(data.sessionId));

            // Notify all participants about the user leaving
            broadcastToSession(parseInt(data.sessionId), {
              action: 'participant_left',
              sessionId: data.sessionId,
              userId: data.userId,
              participants: remainingParticipants
            });
            break;

          case 'cursor_move':
            // A user moved their cursor
            if (!data.userId || !data.cursor) {
              ws.send(JSON.stringify({ error: 'userId and cursor are required for cursor_move' }));
              return;
            }

            // Update participant cursor
            await storage.updateParticipantCursor(
              parseInt(data.sessionId),
              data.userId,
              data.cursor
            );

            // Broadcast cursor position to all participants except sender
            broadcastToSession(parseInt(data.sessionId), {
              action: 'cursor_update',
              sessionId: data.sessionId,
              userId: data.userId,
              cursor: data.cursor
            }, data.userId);
            break;

          case 'change':
            // A user made a change to the survey
            if (!data.userId || !data.change) {
              ws.send(JSON.stringify({ error: 'userId and change are required for change action' }));
              return;
            }

            // Record the change
            const recordedChange = await storage.recordCollaborationChange({
              sessionId: parseInt(data.sessionId),
              userId: data.userId,
              entityType: data.change.entityType,
              entityId: data.change.entityId,
              changeType: data.change.changeType,
              previousValue: data.change.oldValue,
              newValue: data.change.newValue
            });

            // Broadcast change to all participants
            broadcastToSession(parseInt(data.sessionId), {
              action: 'change_applied',
              sessionId: data.sessionId,
              userId: data.userId,
              change: recordedChange
            });
            break;

          case 'comment':
            // A user added a comment
            if (!data.userId || !data.comment) {
              ws.send(JSON.stringify({ error: 'userId and comment are required for comment action' }));
              return;
            }

            // Add the comment
            const comment = await storage.addCollaborationComment({
              sessionId: parseInt(data.sessionId),
              userId: data.userId,
              entityType: data.comment.entityType,
              entityId: data.comment.entityId,
              comment: data.comment.content
            });

            // Broadcast comment to all participants
            broadcastToSession(parseInt(data.sessionId), {
              action: 'comment_added',
              sessionId: data.sessionId,
              userId: data.userId,
              comment
            });
            break;

          case 'resolve_comment':
            // A user resolved a comment
            if (!data.userId || !data.commentId) {
              ws.send(JSON.stringify({ error: 'userId and commentId are required for resolve_comment action' }));
              return;
            }

            // Resolve the comment
            const resolvedComment = await storage.resolveCollaborationComment(
              data.commentId,
              data.userId
            );

            if (!resolvedComment) {
              ws.send(JSON.stringify({ error: 'Comment not found or already resolved' }));
              return;
            }

            // Broadcast resolution to all participants
            broadcastToSession(parseInt(data.sessionId), {
              action: 'comment_resolved',
              sessionId: data.sessionId,
              userId: data.userId,
              commentId: data.commentId,
              comment: resolvedComment
            });
            break;

          case 'ping':
            // Client is checking connection, send pong
            ws.send(JSON.stringify({ action: 'pong', time: new Date().toISOString() }));
            break;

          default:
            ws.send(JSON.stringify({ error: `Unknown action: ${data.action}` }));
        }
      } catch (error) {
        console.error('Error processing WebSocket message:', error);
        ws.send(JSON.stringify({ error: 'Error processing message' }));
      }
    });

    ws.on('close', () => {
      console.log('WebSocket client disconnected');

      // Find and remove the connection from all sessions
      activeConnections.forEach((connections, sessionId) => {
        connections.forEach((connection, userId) => {
          if (connection === ws) {
            // Remove this connection
            connections.delete(userId);

            // Update participant status and notify others
            storage.updateParticipantStatus(parseInt(sessionId), userId, 'inactive')
              .then(() => storage.getSessionParticipants(parseInt(sessionId)))
              .then(participants => {
                broadcastToSession(parseInt(sessionId), {
                  action: 'participant_left',
                  sessionId,
                  userId,
                  participants
                });
              })
              .catch(err => console.error('Error handling disconnection:', err));

            // Clean up empty session
            if (connections.size === 0) {
              activeConnections.delete(sessionId);
            }
          }
        });
      });
    });
  });

  // Utility function to broadcast a message to all clients in a session
  function broadcastToSession(sessionId: number | string, data: any, excludeUserId?: number) {
    // Always convert sessionId to string to match the map key
    const sessionIdStr = sessionId.toString();
    const sessionConnections = activeConnections.get(sessionIdStr);

    if (!sessionConnections) {
      // No active connections for this session
      logger.debug(`No active connections found for session: ${sessionIdStr}`);
      return;
    }

    const message = JSON.stringify(data);
    let sentCount = 0;

    sessionConnections.forEach((ws, userId) => {
      // Skip excluded user if specified
      if (excludeUserId !== undefined && userId === excludeUserId) return;

      if (ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(message);
          sentCount++;
        } catch (error) {
          logger.error(`Failed to send message to user ${userId} in session ${sessionIdStr}`, error as Error);
        }
      }
    });

    logger.debug(`Broadcast message to ${sentCount} clients in session ${sessionIdStr}`);
  }

  // Utility function to generate a random color for collaboration
  function getRandomColor(): string {
    const colors = [
      '#FF5733', '#33FF57', '#3357FF', '#FF33F5', '#F5FF33',
      '#33FFF5', '#FF5733', '#5733FF', '#33FF57', '#FF3333'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // ============================================================================
  // HELPER FUNCTIONS FOR PERSONALITY TRAITS
  // ============================================================================

  function generateGenderStereotypes(traits: PersonalityTrait[]): GenderStereotype[] {
    // Mock data for gender stereotypes based on personality traits
    const stereotypes: GenderStereotype[] = [];

    // Map traits to gender stereotypes
    for (const trait of traits) {
      if (trait.score > 75) {
        // High scores in certain traits are mapped to stereotypes
        switch (trait.name) {
          case 'Assertiveness':
            stereotypes.push({
              trait: trait.name,
              score: Math.round(trait.score / 10),
              stereotypeType: 'male',
              description: 'Traditionally associated with male leadership roles'
            });
            break;
          case 'Empathy':
            stereotypes.push({
              trait: trait.name,
              score: Math.round(trait.score / 10),
              stereotypeType: 'female',
              description: 'Commonly associated with feminine caregiving qualities'
            });
            break;
          case 'Risk-taking':
            stereotypes.push({
              trait: trait.name,
              score: Math.round(trait.score / 10),
              stereotypeType: 'male',
              description: 'Traditionally linked to masculine adventurousness'
            });
            break;
          case 'Nurturing':
            stereotypes.push({
              trait: trait.name,
              score: Math.round(trait.score / 10),
              stereotypeType: 'female',
              description: 'Historically connected to feminine caretaking roles'
            });
            break;
        }
      }
    }

    return stereotypes;
  }

  function generateProductRecommendations(traits: PersonalityTrait[]): ProductRecommendation[] {
    try {
      // Generate product recommendations based on personality traits
      const recommendations: ProductRecommendation[] = [];
      
      // Safety check for traits
      if (!traits || !Array.isArray(traits) || traits.length === 0) {
        console.log("No valid traits provided for product recommendations. Returning default recommendations.");
        return [
          {
            category: 'Technology',
            products: [{
              name: 'Smart Home Devices',
              confidence: 75,
              description: 'Innovative smart home technology for modern living.',
              attributes: ['innovative', 'technology-focused', 'convenience']
            }],
            reason: 'These products are popular choices for many customers.'
          },
          {
            category: 'Productivity',
            products: [{
              name: 'Task Management Software',
              confidence: 70,
              description: 'Tools that help maintain organization and productivity.',
              attributes: ['organized', 'efficient', 'systematic']
            }],
            reason: 'Productivity tools can help anyone improve their workflow and efficiency.'
          },
          {
            category: 'Wellness',
            products: [{
              name: 'Meditation Apps',
              confidence: 65,
              description: 'Applications that help maintain mental well-being through guided meditation.',
              attributes: ['relaxing', 'mindful', 'stress-relieving']
            }],
            reason: 'Wellness products can benefit everyone in today\'s busy world.'
          }
        ];
      }
  
      // Group traits by category for easier processing
      const traitsByCategory: Record<string, PersonalityTrait[]> = {};
      for (const trait of traits) {
        // Safety check for trait object structure
        if (!trait || typeof trait !== 'object' || !trait.category || typeof trait.score !== 'number') {
          continue; // Skip invalid traits
        }
        
        if (!traitsByCategory[trait.category]) {
          traitsByCategory[trait.category] = [];
        }
        traitsByCategory[trait.category].push(trait);
      }
  
      // Generate recommendations based on trait categories
      if (traitsByCategory['openness'] && traitsByCategory['openness'].some(t => t.score > 70)) {
        recommendations.push({
          category: 'Technology',
          products: [{
            name: 'Smart Home Devices',
            confidence: Math.round(Math.random() * 20 + 80),
            description: 'Your openness to new experiences suggests you would enjoy innovative smart home technology.',
            attributes: ['innovative', 'technology-focused', 'convenience']
          }],
          reason: 'Your openness to new experiences suggests you would enjoy innovative smart home technology.'
        });
      }
  
      if (traitsByCategory['conscientiousness'] && traitsByCategory['conscientiousness'].some(t => t.score > 70)) {
        recommendations.push({
          category: 'Productivity',
          products: [{
            name: 'Task Management Software',
            confidence: Math.round(Math.random() * 20 + 80),
            description: 'Your conscientious nature indicates you would value tools that help maintain organization and productivity.',
            attributes: ['organized', 'efficient', 'systematic']
          }],
          reason: 'Your conscientious nature indicates you would value tools that help maintain organization and productivity.'
        });
      }
  
      if (traitsByCategory['extraversion'] && traitsByCategory['extraversion'].some(t => t.score > 70)) {
        recommendations.push({
          category: 'Entertainment',
          products: [{
            name: 'Social Gaming Platforms',
            confidence: Math.round(Math.random() * 20 + 80),
            description: 'These platforms facilitate social interaction and shared experiences.',
            attributes: ['social', 'interactive', 'engaging']
          }],
          reason: 'Your extraverted traits suggest you would enjoy products that facilitate social interaction and shared experiences.'
        });
      }
  
      if (traitsByCategory['agreeableness'] && traitsByCategory['agreeableness'].some(t => t.score > 70)) {
        recommendations.push({
          category: 'Sustainability',
          products: [{
            name: 'Eco-friendly Products',
            confidence: Math.round(Math.random() * 20 + 80),
            description: 'Products that are environmentally sustainable and ethically sourced.',
            attributes: ['eco-friendly', 'sustainable', 'ethical']
          }],
          reason: 'Your agreeable nature often correlates with concern for others and the environment, making sustainable products a good match.'
        });
      }
  
      if (traitsByCategory['emotional_stability'] && traitsByCategory['emotional_stability'].some(t => t.score > 70)) {
        recommendations.push({
          category: 'Wellness',
          products: [{
            name: 'Meditation Apps',
            confidence: Math.round(Math.random() * 20 + 80),
            description: 'Applications that help maintain mental well-being through guided meditation.',
            attributes: ['relaxing', 'mindful', 'stress-relieving']
          }],
          reason: 'Your emotional stability suggests you might appreciate products that help maintain mental well-being.'
        });
      }
  
      // Add some random recommendations if we don't have enough
      const categories = ['Fashion', 'Food & Beverage', 'Travel', 'Fitness', 'Education'];
      const productNames = ['Subscription Services', 'Premium Products', 'Budget Options', 'Custom Solutions', 'Experience-based Services'];
  
      let safetyCounter = 0; // Prevent infinite loops
      while (recommendations.length < 3 && safetyCounter < 10) {
        const category = categories[Math.floor(Math.random() * categories.length)];
        const productName = productNames[Math.floor(Math.random() * productNames.length)];
  
        // Check if we already have this category/name combination
        if (!recommendations.some(r => r.category === category && r.products.some(p => p.name === productName))) {
          recommendations.push({
            category,
            products: [{
              name: productName,
              confidence: Math.round(Math.random() * 30 + 50), // Lower confidence for random recommendations
              description: `${productName} in the ${category} category.`,
              attributes: ['personalized', 'recommended', 'matched']
            }],
            reason: 'Based on a combination of your personality traits, this product category may be of interest to you.'
          });
        }
        safetyCounter++;
      }
  
      console.log(`Generated ${recommendations.length} product recommendations based on ${traits.length} traits.`);
      return recommendations;
      
    } catch (error) {
      console.error("Error in generateProductRecommendations:", error);
      
      // Return fallback recommendations in case of error
      return [
        {
          category: 'Technology',
          products: [{
            name: 'Smart Home Devices',
            confidence: 75,
            description: 'Innovative smart home technology for modern living.',
            attributes: ['innovative', 'technology-focused', 'convenience']
          }],
          reason: 'These products are popular choices for many customers.'
        },
        {
          category: 'Productivity',
          products: [{
            name: 'Task Management Software',
            confidence: 70,
            description: 'Tools that help maintain organization and productivity.',
            attributes: ['organized', 'efficient', 'systematic']
          }],
          reason: 'Productivity tools can help anyone improve their workflow and efficiency.'
        },
        {
          category: 'Wellness',
          products: [{
            name: 'Meditation Apps',
            confidence: 65,
            description: 'Applications that help maintain mental well-being through guided meditation.',
            attributes: ['relaxing', 'mindful', 'stress-relieving']
          }],
          reason: 'Wellness products can benefit everyone in today\'s busy world.'
        }
      ];
    }
  }

  function determineMarketSegment(traits: PersonalityTrait[]): string {
    try {
      // Safety check for traits array
      if (!traits || !Array.isArray(traits) || traits.length === 0) {
        console.log("No valid traits provided for market segment determination. Returning default segment.");
        return 'General Consumer';
      }
      
      // Calculate average scores by trait category
      const categoryScores: Record<string, { total: number, count: number }> = {};
  
      for (const trait of traits) {
        // Safety check for trait object structure
        if (!trait || typeof trait !== 'object' || !trait.category || typeof trait.score !== 'number') {
          continue; // Skip invalid traits
        }
        
        if (!categoryScores[trait.category]) {
          categoryScores[trait.category] = { total: 0, count: 0 };
        }
  
        categoryScores[trait.category].total += trait.score;
        categoryScores[trait.category].count++;
      }
  
      // If no valid traits were processed, return default
      if (Object.keys(categoryScores).length === 0) {
        console.log("No valid trait categories found. Returning default segment.");
        return 'General Consumer';
      }
  
      // Calculate average for each category
      const categoryAverages: Record<string, number> = {};
      for (const [category, scores] of Object.entries(categoryScores)) {
        // Avoid division by zero
        if (scores.count > 0) {
          categoryAverages[category] = scores.total / scores.count;
        } else {
          categoryAverages[category] = 0;
        }
      }
  
      // Determine segment based on highest scoring categories
      let highestCategory = '';
      let highestScore = 0;
  
      for (const [category, average] of Object.entries(categoryAverages)) {
        if (average > highestScore) {
          highestScore = average;
          highestCategory = category;
        }
      }
  
      // Map categories to market segments
      const segmentMap: Record<string, string> = {
        'openness': 'Innovative Adopters',
        'conscientiousness': 'Quality Seekers',
        'extraversion': 'Social Consumers',
        'agreeableness': 'Ethical Consumers',
        'emotional_stability': 'Balanced Pragmatists',
        'innovation_mindset': 'Early Adopters',
        'risk_attitude': 'Risk Takers',
        'decision_style': 'Analytical Deciders',
        'digital_behavior': 'Digital Natives',
        'sustainability': 'Eco-conscious Consumers'
      };
  
      const segment = segmentMap[highestCategory] || 'General Consumer';
      console.log(`Determined market segment "${segment}" based on highest category "${highestCategory}" with score ${highestScore.toFixed(2)}`);
      
      return segment;
    } catch (error) {
      console.error("Error in determineMarketSegment:", error);
      return 'General Consumer';
    }
  }

  async function generatePersonalityTraits(responses: any[]): Promise<any[]> {
    // In a real application, this would use a sophisticated algorithm
    // to analyze responses and generate accurate personality traits.
    // For this demo, we'll create mock traits based on response patterns.

    try {
      // Define some mock trait categories and traits
      const traitCategories = [
        'openness',
        'conscientiousness',
        'extraversion',
        'agreeableness',
        'emotional_stability'
      ];
  
      const traitsInCategories: Record<string, string[]> = {
        'openness': ['Creativity', 'Curiosity', 'Openness to new experiences', 'Imagination', 'Intellectual curiosity'],
        'conscientiousness': ['Organization', 'Responsibility', 'Reliability', 'Thoroughness', 'Self-discipline'],
        'extraversion': ['Sociability', 'Assertiveness', 'Energy', 'Enthusiasm', 'Outgoingness'],
        'agreeableness': ['Empathy', 'Cooperation', 'Trustworthiness', 'Altruism', 'Compassion'],
        'emotional_stability': ['Calmness', 'Emotional regulation', 'Resilience', 'Stress tolerance', 'Self-confidence']
      };
  
      // Generate traits based on the number of responses
      const traits: any[] = [];
  
      // Validate responses array
      if (!responses || !Array.isArray(responses) || responses.length === 0) {
        console.log("No valid responses provided to generatePersonalityTraits. Returning default traits.");
        
        // Return at least one trait from each category as a fallback
        traitCategories.forEach(category => {
          const defaultTrait = traitsInCategories[category][0];
          traits.push({
            name: defaultTrait,
            score: 50, // Neutral score
            category: category
          });
        });
        
        return traits;
      }
  
      // Filter out invalid responses
      const validResponses = responses.filter(response => 
        response !== null && response !== undefined && 
        response.questionId !== undefined && response.answer !== undefined
      );
  
      if (validResponses.length === 0) {
        console.log("No valid response data found. Returning default traits.");
        
        // Return at least one trait from each category as a fallback
        traitCategories.forEach(category => {
          const defaultTrait = traitsInCategories[category][0];
          traits.push({
            name: defaultTrait,
            score: 50, // Neutral score
            category: category
          });
        });
        
        return traits;
      }
  
      // Select a random subset of trait categories, ensuring we have at least 3 categories
      const categoryCount = Math.min(traitCategories.length, Math.max(3, Math.floor(validResponses.length / 3)));
      const selectedCategories = traitCategories.slice(0, categoryCount);
  
      // Generate traits for each selected category
      for (const category of selectedCategories) {
        // Safety check for category
        if (!traitsInCategories[category] || !Array.isArray(traitsInCategories[category])) {
          console.log(`Invalid category: ${category}. Skipping.`);
          continue;
        }
        
        const traitsForCategory = traitsInCategories[category];
        // Ensure we generate at least 2 traits per category, but no more than are available
        const numTraitsToGenerate = Math.min(traitsForCategory.length, Math.max(2, Math.floor(validResponses.length / 5)));
  
        // Select a random subset of traits
        const selectedTraits = traitsForCategory.slice(0, numTraitsToGenerate);
  
        // Generate a trait score for each selected trait
        for (const traitName of selectedTraits) {
          const baseScore = 50;
          const variation = Math.floor(Math.random() * 40) - 20; // -20 to +20
          const score = Math.max(0, Math.min(100, baseScore + variation));
  
          traits.push({
            name: traitName,
            score,
            category
          });
        }
      }
  
      // Ensure we have at least some traits
      if (traits.length === 0) {
        console.log("Failed to generate traits. Returning default traits.");
        
        // Return at least one trait from each category as a fallback
        traitCategories.forEach(category => {
          const defaultTrait = traitsInCategories[category][0];
          traits.push({
            name: defaultTrait,
            score: 50, // Neutral score
            category: category
          });
        });
      }
  
      // For debugging
      console.log(`Generated ${traits.length} personality traits from ${validResponses.length} valid responses.`);
      
      return traits;
    } catch (error) {
      console.error("Error in generatePersonalityTraits:", error);
      
      // In case of error, return at least a minimal set of traits
      return [
        { name: "Adaptability", score: 50, category: "openness" },
        { name: "Reliability", score: 50, category: "conscientiousness" },
        { name: "Sociability", score: 50, category: "extraversion" }
      ];
    }
  }

  // Authentication middleware for protected routes
  const requireAuth = (req: Request, res: Response, next: NextFunction) => {
    // Check for mock admin authentication for development/testing
    // Accept both uppercase (standard) and lowercase (fallback) header formats
    const mockAdminHeader = req.headers['X-Mock-Admin'] || req.headers['x-mock-admin'];
    const mockUserId = req.headers['X-User-ID'] || req.headers['x-user-id'];
    const mockUserRole = req.headers['X-User-Role'] || req.headers['x-user-role'];
    
    if (mockAdminHeader === 'true' && mockUserId && mockUserRole === 'platform_admin') {
      // Add mock admin user information to the request object
      (req as AuthenticatedRequest).user = {
        id: Number(mockUserId),
        username: 'admin@personalysispro.com',
        email: 'admin@personalysispro.com',
        role: UserRole.PLATFORM_ADMIN, // Use proper role from UserRole enum
        companyId: null,
        firstName: 'Admin',
        lastName: 'User'
      };
      console.log('Mock admin authentication successful');
      return next();
    }
    
    // Regular session-based authentication
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ 
        success: false,
        message: "Authentication required" 
      });
    }
    
    // Add user information from session to the request object
    (req as AuthenticatedRequest).user = {
      id: req.session.userId,
      username: '',  // These will be populated from database in a real app
      email: '',
      role: req.session.userRole || '',
      companyId: req.session.companyId
    };
    
    next();
  };

  // Request body validation middleware
  const validateRequestBody = (schema: z.ZodTypeAny) => {
    return (req: Request, res: Response, next: NextFunction) => {
      try {
        schema.parse(req.body);
        next();
      } catch (error) {
        if (error instanceof ZodError) {
          return res.status(400).json({
            success: false,
            message: "Validation error",
            errors: error.errors
          });
        }
        next(error);
      }
    };
  };

  // Client Management API endpoints
  app.get('/api/clients', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view clients
      if (req.user?.role !== UserRole.PLATFORM_ADMIN && 
          req.user?.role !== UserRole.PLATFORM_SUPPORT) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view client accounts"
        });
      }
      
      const clients = await storage.getClients();
      return res.json({
        success: true,
        data: clients
      });
    } catch (error) {
      logger.error(`Error fetching clients: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch clients"
      });
    }
  });
  
  // Admin Analytics API
  app.get("/api/admin/analytics", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view analytics
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view platform analytics"
        });
      }
      
      const { period = '12months' } = req.query;
      
      // Get analytics data
      const clients = await storage.getClients();
      const invoices = await storage.getAllInvoices();
      const subscriptions = await storage.getAllSubscriptions();
      
      // Format data for clientGrowth
      const clientGrowth = generateClientGrowth(clients, period as string);
      
      // Format data for revenue
      const revenue = generateRevenueData(invoices, period as string);
      
      // Generate key metrics
      const keyMetrics = generateKeyMetrics(clients, subscriptions, invoices);
      
      // Generate industry breakdown
      const industryBreakdown = generateIndustryBreakdown(clients, invoices);
      
      return res.json({
        success: true,
        data: {
          clientGrowth,
          revenue,
          keyMetrics,
          industryBreakdown
        }
      });
    } catch (error) {
      logger.error(`Error generating analytics: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to generate analytics data"
      });
    }
  });
  
  // Helper function to generate client growth data
  function generateClientGrowth(clients: any[], period: string) {
    const months = period === '3months' ? 3 : period === '6months' ? 6 : 12;
    const now = new Date();
    const result = [];
    
    for (let i = months - 1; i >= 0; i--) {
      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
      const month = date.toLocaleString('default', { month: 'short', year: '2-digit' });
      
      // Find clients created in this month
      const newClients = clients.filter(client => {
        const createdAt = new Date(client.createdAt);
        return createdAt >= date && createdAt <= monthEnd;
      }).length;
      
      // Clients active at the end of the month (created before or during this month)
      const activeClients = clients.filter(client => {
        const createdAt = new Date(client.createdAt);
        return createdAt <= monthEnd && client.status === 'active';
      }).length;
      
      // Clients who churned this month (status changed to inactive)
      const churnedClients = clients.filter(client => {
        const updatedAt = new Date(client.updatedAt);
        return updatedAt >= date && updatedAt <= monthEnd && client.status === 'inactive';
      }).length;
      
      result.push({
        month,
        newClients,
        activeClients,
        churnedClients
      });
    }
    
    return result;
  }
  
  // Helper function to generate revenue data
  function generateRevenueData(invoices: any[], period: string) {
    const months = period === '3months' ? 3 : period === '6months' ? 6 : 12;
    const now = new Date();
    const result = [];
    
    for (let i = months - 1; i >= 0; i--) {
      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
      const month = date.toLocaleString('default', { month: 'short', year: '2-digit' });
      
      // Filter invoices for this month
      const monthInvoices = invoices.filter(invoice => {
        const createdAt = new Date(invoice.createdAt);
        return createdAt >= date && createdAt <= monthEnd && invoice.status === 'paid';
      });
      
      // Calculate revenue
      const subscriptionRevenue = monthInvoices
        .filter(invoice => invoice.items && typeof invoice.items === 'object' && 
                invoice.items.type === 'subscription')
        .reduce((sum, invoice) => sum + invoice.amount, 0);
      
      const oneTimeRevenue = monthInvoices
        .filter(invoice => invoice.items && typeof invoice.items === 'object' && 
                invoice.items.type === 'one-time')
        .reduce((sum, invoice) => sum + invoice.amount, 0);
      
      const totalRevenue = subscriptionRevenue + oneTimeRevenue;
      
      result.push({
        month,
        totalRevenue,
        subscriptionRevenue,
        oneTimeRevenue
      });
    }
    
    return result;
  }
  
  // Helper function to generate key metrics
  function generateKeyMetrics(clients: any[], subscriptions: any[], invoices: any[]) {
    // Total active clients
    const totalClients = clients.filter(client => client.status === 'active').length;
    const previousClients = clients.filter(client => {
      const createdAt = new Date(client.createdAt);
      const lastMonth = new Date();
      lastMonth.setMonth(lastMonth.getMonth() - 1);
      return createdAt <= lastMonth && client.status === 'active';
    }).length;
    const clientChange = previousClients ? ((totalClients - previousClients) / previousClients) * 100 : 0;
    
    // Active licenses
    const activeLicenses = subscriptions
      .filter(sub => sub.status === 'active')
      .reduce((sum, sub) => sum + (sub.quantity || 1), 0);
    const previousLicenses = subscriptions
      .filter(sub => {
        const lastMonth = new Date();
        lastMonth.setMonth(lastMonth.getMonth() - 1);
        return new Date(sub.updatedAt) <= lastMonth && sub.status === 'active';
      })
      .reduce((sum, sub) => sum + (sub.quantity || 1), 0);
    const licenseChange = previousLicenses ? ((activeLicenses - previousLicenses) / previousLicenses) * 100 : 0;
    
    // Monthly recurring revenue
    const now = new Date();
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const monthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
    
    const mrr = subscriptions
      .filter(sub => sub.status === 'active' && sub.billingCycle === 'monthly')
      .reduce((sum, sub) => sum + (sub.price || 0), 0);
    
    const previousMrr = subscriptions
      .filter(sub => {
        const updatedAt = new Date(sub.updatedAt);
        return updatedAt <= monthEnd && sub.status === 'active' && sub.billingCycle === 'monthly';
      })
      .reduce((sum, sub) => sum + (sub.price || 0), 0);
    
    const mrrChange = previousMrr ? ((mrr - previousMrr) / previousMrr) * 100 : 0;
    
    // Churn rate
    const churnedLastMonth = clients.filter(client => {
      const updatedAt = new Date(client.updatedAt);
      return updatedAt >= lastMonth && updatedAt <= monthEnd && client.status === 'inactive';
    }).length;
    
    const activeLastMonth = clients.filter(client => {
      const createdAt = new Date(client.createdAt);
      return createdAt <= lastMonth && client.status === 'active';
    }).length;
    
    const churnRate = activeLastMonth ? (churnedLastMonth / activeLastMonth) * 100 : 0;
    const previousChurnRate = 2.5; // We would calculate this based on historical data
    const churnChange = previousChurnRate ? ((churnRate - previousChurnRate) / previousChurnRate) * 100 : 0;
    
    return [
      {
        id: 'total-clients',
        metric: 'Total Clients',
        value: totalClients,
        change: parseFloat(clientChange.toFixed(1)),
        trend: clientChange >= 0 ? 'up' : 'down'
      },
      {
        id: 'active-licenses',
        metric: 'Active Licenses',
        value: activeLicenses,
        change: parseFloat(licenseChange.toFixed(1)),
        trend: licenseChange >= 0 ? 'up' : 'down'
      },
      {
        id: 'mrr',
        metric: 'Monthly Recurring Revenue',
        value: mrr,
        change: parseFloat(mrrChange.toFixed(1)),
        trend: mrrChange >= 0 ? 'up' : 'down'
      },
      {
        id: 'churn-rate',
        metric: 'Churn Rate',
        value: parseFloat(churnRate.toFixed(1)),
        change: parseFloat(Math.abs(churnChange).toFixed(1)),
        trend: churnChange <= 0 ? 'down' : 'up'
      }
    ];
  }
  
  // Helper function to generate industry breakdown
  function generateIndustryBreakdown(clients: any[], invoices: any[]) {
    const industries: { [key: string]: { clients: number, revenue: number } } = {};
    
    clients.forEach(client => {
      if (client.industry) {
        if (!industries[client.industry]) {
          industries[client.industry] = { clients: 0, revenue: 0 };
        }
        industries[client.industry].clients++;
        
        // Sum up revenue for this client
        const clientInvoices = invoices.filter(invoice => invoice.companyId === client.id && invoice.status === 'paid');
        const clientRevenue = clientInvoices.reduce((sum, invoice) => sum + invoice.amount, 0);
        industries[client.industry].revenue += clientRevenue;
      }
    });
    
    // If no industries found, create some defaults
    if (Object.keys(industries).length === 0) {
      industries['Technology'] = { clients: 12, revenue: 15000 };
      industries['Healthcare'] = { clients: 8, revenue: 12000 };
      industries['Finance'] = { clients: 7, revenue: 11000 };
      industries['Education'] = { clients: 9, revenue: 8000 };
      industries['Retail'] = { clients: 6, revenue: 7500 };
    }
    
    return Object.entries(industries).map(([name, data]) => ({
      name,
      clients: data.clients,
      revenue: data.revenue
    }));
  }

  app.post('/api/clients', requireAuth, validateRequestBody(insertClientSchema), async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to create clients
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can create client accounts"
        });
      }
      
      const newClient = { ...req.body };
      
      // Hash the initial password if provided
      if (newClient.initialPassword) {
        const { hash } = hashPassword(newClient.initialPassword);
        newClient.initialPassword = hash;
      }
      
      const result = await storage.createClient(newClient);
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'client_created',
        entityType: 'client',
        entityId: result.id.toString(),
        details: { clientName: result.name, clientEmail: result.email }
      });
      
      return res.status(201).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error(`Error creating client: ${error}`);
      if (error.code === '23505') { // PostgreSQL unique violation error code
        return res.status(409).json({
          success: false,
          message: "A client with this email already exists"
        });
      }
      return res.status(500).json({
        success: false,
        message: "Failed to create client"
      });
    }
  });

  app.put('/api/clients/:id', requireAuth, validateRequestBody(insertClientSchema), async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to update clients
      if (req.user?.role !== UserRole.PLATFORM_ADMIN && 
          req.user?.role !== UserRole.PLATFORM_SUPPORT) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can update client accounts"
        });
      }
      
      const clientId = parseInt(req.params.id);
      if (isNaN(clientId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid client ID format"
        });
      }
      
      const client = await storage.getClientById(clientId);
      if (!client) {
        return res.status(404).json({
          success: false,
          message: "Client not found"
        });
      }
      
      const updatedClient = { ...req.body };
      
      // Hash the initial password if provided
      if (updatedClient.initialPassword) {
        const { hash } = hashPassword(updatedClient.initialPassword);
        updatedClient.initialPassword = hash;
      }
      
      const result = await storage.updateClient(clientId, updatedClient);
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'client_updated',
        entityType: 'client',
        entityId: clientId.toString(),
        details: { 
          clientName: result.name, 
          clientEmail: result.email,
          previousStatus: client.status,
          newStatus: result.status
        }
      });
      
      return res.json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error(`Error updating client: ${error}`);
      if (error.code === '23505') { // PostgreSQL unique violation error code
        return res.status(409).json({
          success: false,
          message: "A client with this email already exists"
        });
      }
      return res.status(500).json({
        success: false,
        message: "Failed to update client"
      });
    }
  });

  app.delete('/api/clients/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to delete clients
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can delete client accounts"
        });
      }
      
      const clientId = parseInt(req.params.id);
      if (isNaN(clientId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid client ID format"
        });
      }
      
      const client = await storage.getClientById(clientId);
      if (!client) {
        return res.status(404).json({
          success: false,
          message: "Client not found"
        });
      }
      
      await storage.deleteClient(clientId);
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'client_deleted',
        entityType: 'client',
        entityId: clientId.toString(),
        details: { clientName: client.name, clientEmail: client.email }
      });
      
      return res.json({
        success: true,
        message: "Client deleted successfully"
      });
    } catch (error) {
      logger.error(`Error deleting client: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to delete client"
      });
    }
  });

  // Create a new invoice
  app.post("/api/invoices", requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      // Check if user has permission to create invoices
      if (req.user?.role !== UserRole.PLATFORM_ADMIN && 
          req.user?.role !== UserRole.PLATFORM_SUPPORT) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can create invoices"
        });
      }
      
      // Validate request body
      const { companyId, subscriptionId, invoiceNumber, amount, currency, tax, status, dueDate, items, notes } = req.body;
      
      if (!companyId || !invoiceNumber || !amount || !currency || !status || !dueDate || !items) {
        return res.status(400).json({ 
          success: false, 
          message: "Missing required fields for invoice creation" 
        });
      }
      
      // Check if company exists
      const client = await storage.getClientById(companyId);
      if (!client) {
        return res.status(404).json({ 
          success: false, 
          message: "Client company not found" 
        });
      }
      
      // Parse items if it's a string
      let parsedItems = items;
      if (typeof items === 'string') {
        try {
          parsedItems = JSON.parse(items);
        } catch (err) {
          return res.status(400).json({ 
            success: false, 
            message: "Invalid items format" 
          });
        }
      }
      
      // Create invoice in storage
      const invoice = await storage.createInvoice({
        companyId,
        subscriptionId: subscriptionId || null,
        invoiceNumber,
        amount,
        currency,
        tax: tax || 0,
        status,
        dueDate: new Date(dueDate),
        items: parsedItems,
        notes: notes || null
      });
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'invoice_created',
        entityType: 'invoice',
        entityId: invoice.id.toString(),
        details: { 
          companyId,
          invoiceNumber,
          amount,
          status
        }
      });
      
      // Return the created invoice
      res.status(201).json({
        success: true,
        message: "Invoice created successfully",
        data: invoice
      });
      
    } catch (error: any) {
      console.error("Error creating invoice:", error);
      res.status(500).json({ 
        success: false, 
        message: "Failed to create invoice", 
        error: error.message 
      });
    }
  }));

  // Integration Management API endpoints
  app.get('/api/integrations', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view all integrations"
        });
      }
      
      const integrations = await storage.getIntegrations();
      
      return res.json({
        success: true,
        data: integrations
      });
    } catch (error) {
      logger.error(`Error fetching integrations: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch integrations"
      });
    }
  });

  app.get('/api/integrations/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view integration details"
        });
      }
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid integration ID"
        });
      }
      
      const integration = await storage.getIntegration(id);
      if (!integration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      
      return res.json({
        success: true,
        data: integration
      });
    } catch (error) {
      logger.error(`Error fetching integration: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch integration"
      });
    }
  });

  app.get('/api/integrations/type/:type', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view integrations"
        });
      }
      
      const type = req.params.type;
      const integrations = await storage.getIntegrationsByType(type);
      
      return res.json({
        success: true,
        data: integrations
      });
    } catch (error) {
      logger.error(`Error fetching integrations by type: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch integrations by type"
      });
    }
  });

  app.post('/api/integrations', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to create integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can create integrations"
        });
      }
      
      const integrationData = req.body;
      
      // Basic validation
      if (!integrationData.name || !integrationData.type || !integrationData.provider) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields. Name, type, and provider are required."
        });
      }
      
      const newIntegration = await storage.createIntegration({
        name: integrationData.name,
        type: integrationData.type,
        provider: integrationData.provider,
        status: integrationData.status || IntegrationStatus.CONFIGURED,
        apiKey: integrationData.apiKey || null,
        apiSecret: integrationData.apiSecret || null,
        apiUrl: integrationData.apiUrl || null,
        companyId: integrationData.companyId || 1, // Default to main company if not specified
        lastSynced: null,
        config: integrationData.config || {}
      });
      
      // Create audit log for the new integration
      await storage.createAuditLog({
        userId: req.user?.id || 1,
        action: 'create',
        entityType: 'integration',
        entityId: String(newIntegration.id),
        details: {
          type: newIntegration.type,
          provider: newIntegration.provider,
          name: newIntegration.name
        }
      });
      
      return res.status(201).json({
        success: true,
        data: newIntegration
      });
    } catch (error) {
      logger.error(`Error creating integration: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to create integration"
      });
    }
  });

  app.put('/api/integrations/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to update integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can update integrations"
        });
      }
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid integration ID"
        });
      }
      
      // Get the existing integration to compare changes
      const existingIntegration = await storage.getIntegration(id);
      if (!existingIntegration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      
      const integrationData = req.body;
      const updatedIntegration = await storage.updateIntegration(id, integrationData);
      
      // Create audit log for the updated integration
      await storage.createAuditLog({
        userId: req.user?.id || 1,
        action: 'update',
        entityType: 'integration',
        entityId: String(id),
        details: {
          type: updatedIntegration.type,
          provider: updatedIntegration.provider,
          changes: integrationData
        }
      });
      
      return res.json({
        success: true,
        data: updatedIntegration
      });
    } catch (error) {
      logger.error(`Error updating integration: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to update integration"
      });
    }
  });

  app.patch('/api/integrations/:id/status', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to update integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can update integration status"
        });
      }
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid integration ID"
        });
      }
      
      const { status } = req.body;
      if (!status) {
        return res.status(400).json({
          success: false,
          message: "Status is required"
        });
      }
      
      // Get the existing integration to compare status
      const existingIntegration = await storage.getIntegration(id);
      if (!existingIntegration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      
      const updatedIntegration = await storage.updateIntegrationStatus(id, status);
      
      // Create audit log for the status change
      await storage.createAuditLog({
        userId: req.user?.id || 1,
        action: 'update_status',
        entityType: 'integration',
        entityId: String(id),
        details: {
          oldStatus: existingIntegration.status,
          newStatus: status
        }
      });
      
      return res.json({
        success: true,
        data: updatedIntegration
      });
    } catch (error) {
      logger.error(`Error updating integration status: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to update integration status"
      });
    }
  });

  // Test integration connection
  app.post('/api/integrations/:id/test', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to test integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can test integrations"
        });
      }
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid integration ID"
        });
      }
      
      // Get the integration
      const integration = await storage.getIntegration(id);
      if (!integration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      
      // Simulate testing the integration connection
      // In a real app, we would actually connect to the third-party API
      // For demo purposes, we'll simulate a successful test
      logger.info(`Testing integration connection: ${integration.name} (${integration.provider})`);
      
      // Add a delay to simulate actual API testing
      await new Promise(resolve => setTimeout(resolve, 1500));
      
      return res.json({
        success: true,
        message: `Successfully connected to ${integration.provider}`
      });
    } catch (error) {
      logger.error('Error testing integration', error as Error);
      return res.status(500).json({
        success: false,
        message: "Failed to test integration connection",
        error: (error as Error).message
      });
    }
  });

  app.delete('/api/integrations/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to delete integrations
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can delete integrations"
        });
      }
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({
          success: false,
          message: "Invalid integration ID"
        });
      }
      
      // Get the integration before deleting for audit log
      const integration = await storage.getIntegration(id);
      if (!integration) {
        return res.status(404).json({
          success: false,
          message: "Integration not found"
        });
      }
      
      const success = await storage.deleteIntegration(id);
      
      // Create audit log for the deletion
      await storage.createAuditLog({
        userId: req.user?.id || 1,
        action: 'delete',
        entityType: 'integration',
        entityId: String(id),
        details: {
          type: integration.type,
          provider: integration.provider,
          name: integration.name
        }
      });
      
      return res.json({
        success: true,
        message: "Integration deleted successfully"
      });
    } catch (error) {
      logger.error(`Error deleting integration: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to delete integration"
      });
    }
  });

  // License Management API endpoints
  app.get('/api/licenses', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view licenses
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view all licenses"
        });
      }
      
      const licenses = await storage.getLicenses();
      
      return res.json({
        success: true,
        count: licenses.length,
        data: licenses
      });
    } catch (error) {
      logger.error(`Error fetching licenses: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch licenses"
      });
    }
  });

  app.get('/api/licenses/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to view license details
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can view license details"
        });
      }
      
      const licenseId = parseInt(req.params.id);
      if (isNaN(licenseId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid license ID format"
        });
      }
      
      const license = await storage.getLicenseById(licenseId);
      if (!license) {
        return res.status(404).json({
          success: false,
          message: "License not found"
        });
      }
      
      return res.json({
        success: true,
        data: license
      });
    } catch (error) {
      logger.error(`Error fetching license: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch license"
      });
    }
  });

  app.post('/api/licenses', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to create licenses
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can create licenses"
        });
      }
      
      // Log the request body to see what's being sent
      console.log("License creation request body:", req.body);
      
      // Manually validate the request
      try {
        console.log("Pre-processing license data for validation - dates:", {
          startDateType: typeof req.body.startDate,
          endDateType: typeof req.body.endDate,
          startDateValue: req.body.startDate,
          endDateValue: req.body.endDate
        });
        
        // Pre-process dates to ensure they're in the right format for validation
        const processedData = {
          ...req.body,
          // Parse string dates into Date objects
          startDate: typeof req.body.startDate === 'string' ? new Date(req.body.startDate) : req.body.startDate,
          endDate: typeof req.body.endDate === 'string' ? new Date(req.body.endDate) : req.body.endDate,
        };
        
        console.log("Processed license data for validation:", processedData);
        
        const validatedData = insertLicenseSchema.parse(processedData);
        console.log("Validated license data:", validatedData);
        
        const newLicense = await storage.createLicense(validatedData);
        
        // Create audit log for this action
        await storage.createAuditLog({
          userId: req.user!.id,
          action: 'license_created',
          entityType: 'license',
          entityId: newLicense.id.toString(),
          details: { 
            name: newLicense.name, 
            type: newLicense.type,
            status: newLicense.status
          }
        });
        
        return res.status(201).json({
          success: true,
          message: "License created successfully",
          data: newLicense
        });
      } catch (validationError: any) {
        // Log the validation error details
        console.error("License validation error:", validationError);
        return res.status(400).json({
          success: false,
          message: "Validation error",
          errors: validationError.errors || validationError
        });
      }
    } catch (error) {
      logger.error(`Error creating license: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to create license"
      });
    }
  });

  app.put('/api/licenses/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to update licenses
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can update licenses"
        });
      }
      
      const licenseId = parseInt(req.params.id);
      if (isNaN(licenseId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid license ID format"
        });
      }
      
      // Check if license exists
      const existingLicense = await storage.getLicenseById(licenseId);
      if (!existingLicense) {
        return res.status(404).json({
          success: false,
          message: "License not found"
        });
      }
      
      // Pre-process dates to ensure they're in the right format
      console.log("License update request body:", req.body);
      const processedData = { ...req.body };
      
      if (req.body.startDate && typeof req.body.startDate === 'string') {
        processedData.startDate = new Date(req.body.startDate);
      }
      
      if (req.body.endDate && typeof req.body.endDate === 'string') {
        processedData.endDate = new Date(req.body.endDate);
      }
      
      console.log("Processed license data for update:", processedData);
      
      // Update the license
      const updatedLicense = await storage.updateLicense(licenseId, processedData);
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'license_updated',
        entityType: 'license',
        entityId: licenseId.toString(),
        details: { 
          name: updatedLicense?.name,
          changes: req.body
        }
      });
      
      return res.json({
        success: true,
        message: "License updated successfully",
        data: updatedLicense
      });
    } catch (error) {
      logger.error(`Error updating license: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to update license"
      });
    }
  });

  app.delete('/api/licenses/:id', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Check if user has permission to delete licenses
      if (req.user?.role !== UserRole.PLATFORM_ADMIN) {
        return res.status(403).json({
          success: false,
          message: "Permission denied: Only platform administrators can delete licenses"
        });
      }
      
      const licenseId = parseInt(req.params.id);
      if (isNaN(licenseId)) {
        return res.status(400).json({
          success: false,
          message: "Invalid license ID format"
        });
      }
      
      // Check if license exists
      const license = await storage.getLicenseById(licenseId);
      if (!license) {
        return res.status(404).json({
          success: false,
          message: "License not found"
        });
      }
      
      // Check if license is in use by any clients
      const clients = await storage.getClients();
      const licensedClients = clients.filter(client => client.licenseId === licenseId);
      
      if (licensedClients.length > 0) {
        return res.status(400).json({
          success: false,
          message: "License cannot be deleted because it is currently assigned to one or more clients",
          data: {
            clients: licensedClients.map(c => ({ id: c.id, name: c.name, company: c.company }))
          }
        });
      }
      
      // Delete the license
      await storage.deleteLicense(licenseId);
      
      // Create audit log for this action
      await storage.createAuditLog({
        userId: req.user!.id,
        action: 'license_deleted',
        entityType: 'license',
        entityId: licenseId.toString(),
        details: { 
          name: license.name,
          type: license.type
        }
      });
      
      return res.json({
        success: true,
        message: "License deleted successfully"
      });
    } catch (error) {
      logger.error(`Error deleting license: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to delete license"
      });
    }
  });

  // Authentication middlewares
  const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
    // Check for mock admin authentication for testing
    // Accept both uppercase (standard) and lowercase (fallback) header formats
    const mockAdminHeader = req.headers['X-Mock-Admin'] || req.headers['x-mock-admin'];
    const mockUserId = req.headers['X-User-ID'] || req.headers['x-user-id'];
    const mockUserRole = req.headers['X-User-Role'] || req.headers['x-user-role'];
    
    if (mockAdminHeader === 'true' && mockUserId && mockUserRole === 'platform_admin') {
      return next();
    }
    
    if (!req.session || !req.session.userId) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    next();
  };

  const hasRole = (roles: string[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
      // Check for mock admin authentication for testing
      // Accept both uppercase (standard) and lowercase (fallback) header formats
      const mockAdminHeader = req.headers['X-Mock-Admin'] || req.headers['x-mock-admin'];
      const mockUserRole = req.headers['X-User-Role'] || req.headers['x-user-role'];
      
      if (mockAdminHeader === 'true' && mockUserRole === 'platform_admin') {
        return next();
      }
      
      if (!req.session || !req.session.userId || !req.session.userRole) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      if (!roles.includes(req.session.userRole)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      
      next();
    };
  };

  // ==================== NOTIFICATION ENDPOINTS ====================
  
  // Get all notifications for current user
  app.get("/api/notifications", isAuthenticated, asyncHandler(async (req: Request, res: Response) => {
    try {
      // Get userId from session or mock headers
      const userId = req.session.userId || 
                     (req.headers['X-User-ID'] || req.headers['x-user-id'] as string);
      
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID not found"
        });
      }
      
      // Parse as number if needed
      const userIdNum = typeof userId === 'string' ? parseInt(userId) : userId;
      const notifications = await storage.getNotifications(userIdNum);
      
      return res.json({
        success: true,
        data: notifications
      });
    } catch (error) {
      logger.error(`Error fetching notifications: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch notifications"
      });
    }
  }));
  
  // Get a single notification by ID
  app.get("/api/notifications/:id", isAuthenticated, asyncHandler(async (req: Request, res: Response) => {
    try {
      const notificationId = parseInt(req.params.id);
      if (isNaN(notificationId)) {
        return res.status(400).json({ 
          success: false,
          message: "Invalid notification ID" 
        });
      }
      
      // Get userId from session or mock headers
      const userId = req.session.userId || 
                     (req.headers['X-User-ID'] || req.headers['x-user-id'] as string);
      
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID not found"
        });
      }
      
      // Parse as number if needed
      const userIdNum = typeof userId === 'string' ? parseInt(userId) : userId;
      const notification = await storage.getNotification(notificationId);
      
      if (!notification) {
        return res.status(404).json({
          success: false,
          message: "Notification not found"
        });
      }
      
      // Check if the notification belongs to the requesting user
      if (notification.userId !== userIdNum) {
        return res.status(403).json({
          success: false,
          message: "You don't have permission to access this notification"
        });
      }
      
      return res.json({
        success: true,
        data: notification
      });
    } catch (error) {
      logger.error(`Error fetching notification: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to fetch notification"
      });
    }
  }));
  
  // Create a new notification
  app.post("/api/notifications", isAuthenticated, hasRole([UserRole.BUSINESS_ADMIN, UserRole.BUSINESS_OWNER]), asyncHandler(async (req: Request, res: Response) => {
    try {
      const validation = insertNotificationSchema.safeParse(req.body);
      
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid notification data",
          errors: validation.error.format()
        });
      }
      
      const notificationData = validation.data;
      const newNotification = await storage.createNotification(notificationData);
      
      return res.status(201).json({
        success: true,
        message: "Notification created successfully",
        data: newNotification
      });
    } catch (error) {
      logger.error(`Error creating notification: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to create notification"
      });
    }
  }));
  
  // Mark notification as read
  app.patch("/api/notifications/:id/read", isAuthenticated, asyncHandler(async (req: Request, res: Response) => {
    try {
      const notificationId = parseInt(req.params.id);
      if (isNaN(notificationId)) {
        return res.status(400).json({ 
          success: false,
          message: "Invalid notification ID" 
        });
      }
      
      // Get userId from session or mock headers
      const userId = req.session.userId || 
                     (req.headers['X-User-ID'] || req.headers['x-user-id'] as string);
      
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID not found"
        });
      }
      
      // Parse as number if needed
      const userIdNum = typeof userId === 'string' ? parseInt(userId) : userId;
      const notification = await storage.getNotification(notificationId);
      
      if (!notification) {
        return res.status(404).json({
          success: false,
          message: "Notification not found"
        });
      }
      
      // Check if the notification belongs to the requesting user
      if (notification.userId !== userIdNum) {
        return res.status(403).json({
          success: false,
          message: "You don't have permission to modify this notification"
        });
      }
      
      const updatedNotification = await storage.markNotificationAsRead(notificationId);
      
      return res.json({
        success: true,
        message: "Notification marked as read",
        data: updatedNotification
      });
    } catch (error) {
      logger.error(`Error marking notification as read: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to mark notification as read"
      });
    }
  }));
  
  // Delete a notification
  app.delete("/api/notifications/:id", isAuthenticated, asyncHandler(async (req: Request, res: Response) => {
    try {
      const notificationId = parseInt(req.params.id);
      if (isNaN(notificationId)) {
        return res.status(400).json({ 
          success: false,
          message: "Invalid notification ID" 
        });
      }
      
      // Get userId from session or mock headers
      const userId = req.session.userId || 
                     (req.headers['X-User-ID'] || req.headers['x-user-id'] as string);
      
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: "User ID not found"
        });
      }
      
      // Parse as number if needed
      const userIdNum = typeof userId === 'string' ? parseInt(userId) : userId;
      const notification = await storage.getNotification(notificationId);
      
      if (!notification) {
        return res.status(404).json({
          success: false,
          message: "Notification not found"
        });
      }
      
      // Check if the notification belongs to the requesting user
      if (notification.userId !== userIdNum) {
        return res.status(403).json({
          success: false,
          message: "You don't have permission to delete this notification"
        });
      }
      
      await storage.deleteNotification(notificationId);
      
      return res.json({
        success: true,
        message: "Notification deleted successfully"
      });
    } catch (error) {
      logger.error(`Error deleting notification: ${error}`);
      return res.status(500).json({
        success: false,
        message: "Failed to delete notification"
      });
    }
  }));

  // Register client survey deployment routes
  registerDeploymentRoutes(app);

  // Create test data for development only
  if (process.env.NODE_ENV !== 'production') {
    // Endpoint to create a test company
    app.get('/api/test/create-company', asyncHandler(async (req: Request, res: Response) => {
      try {
        // Check if test company already exists to avoid duplicates
        const existingCompanies = await storage.getCompanies();
        if (existingCompanies.some(company => company.name === 'Test Business Context Company')) {
          return res.json({
            success: true,
            message: 'Test company already exists',
            companies: existingCompanies
          });
        }
        
        // Create a test company with only required fields as per insertCompanySchema
        const newCompany = await storage.createCompany({
          name: 'Test Business Context Company',
          email: 'test@businesscontext.com',
          apiKey: 'test-api-key-123',
          industry: 'Technology',
          size: '100-500',
          primaryContact: 'Test User',
          contactPhone: '555-123-4567',
          website: 'https://testcompany.com'
        });
        
        return res.status(201).json({
          success: true,
          message: 'Test company created successfully',
          data: newCompany,
          companies: await storage.getCompanies()
        });
      } catch (error) {
        console.error('Error creating test company:', error);
        return res.status(500).json({
          success: false,
          message: 'Failed to create test company',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }));
    
    // Endpoint to create a test survey response with business context data
    // Helper function for enhanced demo data generation
    function generateResponses(count: number): any[] {
      return Array.from({ length: count }, (_, i) => ({
        questionId: i + 1,
        answer: ["Strongly Agree", "Agree", "Neutral", "Disagree", "Strongly Disagree"][Math.floor(Math.random() * 5)],
        timeSpent: 5 + Math.floor(Math.random() * 20) // 5-25 seconds per question
      }));
    }
    
    function determineMarketSegment(traits: any[]): string {
      // Find key traits that determine market segments
      const analyticalThinking = traits.find(t => t.name === "Analytical Thinking")?.score || 50;
      const riskTolerance = traits.find(t => t.name === "Risk Tolerance")?.score || 50;
      const innovationAdoption = traits.find(t => t.name === "Innovation Adoption")?.score || 50;
      const valueCon = traits.find(t => t.name === "Value Consciousness")?.score || 50;
      
      // Determine segment based on trait combinations
      if (innovationAdoption > 70 && riskTolerance > 60) {
        return "Early Adopter";
      } else if (analyticalThinking > 75 && valueCon > 70) {
        return "Value Researcher";
      } else if (riskTolerance < 40 && valueCon > 80) {
        return "Cautious Consumer";
      } else if (innovationAdoption < 40 && valueCon > 75) {
        return "Traditional Buyer";
      } else if (innovationAdoption > 60 && valueCon > 70) {
        return "Smart Innovator";
      } else if (analyticalThinking > 70 && riskTolerance > 65) {
        return "Calculated Risk-Taker";
      } else {
        return "Balanced Consumer";
      }
    }
    
    // Endpoint to enhance the demo account with realistic data (using direct database access)
    app.get('/api/test/enhance-demo-account', asyncHandler(async (req: Request, res: Response) => {
      console.log('Enhance demo account endpoint called');
      try {
        // Import the dedicated function for generating demo data
        const { generateDemoData } = await import('./generateDemoData');
        
        // Generate demo data
        console.log('Starting demo data generation process...');
        const result = await generateDemoData();
        
        // Return result
        if (result.success) {
          return res.status(200).json(result);
        } else {
          return res.status(500).json(result);
        }
      } catch (error) {
        console.error('Error in enhance-demo-account endpoint:', error);
        return res.status(500).json({
          success: false,
          message: 'Error enhancing demo account',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }));
    
    // Endpoint to create a test survey response
    app.get('/api/test/create-survey-response', asyncHandler(async (req: Request, res: Response) => {
      try {
        // Find the first survey
        const surveys = await storage.getSurveys();
        
        if (surveys.length === 0) {
          return res.status(404).json({
            success: false,
            message: 'No surveys found. Please create a survey first.'
          });
        }
        
        const survey = surveys[0];
        
        // Create a test response
        const sampleResponse = {
          surveyId: survey.id,
          companyId: survey.companyId,
          respondentId: `test-${Date.now()}`,
          respondentEmail: 'test@example.com',
          responses: JSON.stringify([
            { questionId: 1, answer: 'Agree', timeSpent: 5 },
            { questionId: 2, answer: 'Strongly Agree', timeSpent: 7 },
            { questionId: 3, answer: 'Neutral', timeSpent: 10 }
          ]),
          traits: JSON.stringify([
            { name: 'Analytical Thinking', score: 85, category: 'cognitive' },
            { name: 'Risk Tolerance', score: 65, category: 'decision-making' },
            { name: 'Innovation Adoption', score: 78, category: 'professional' }
          ]),
          demographics: JSON.stringify({
            age: 35,
            gender: 'Male',
            location: 'New York',
            education: "Master's",
            income: '$100k-$150k',
            occupation: 'Manager',
            interests: ['Technology', 'Business Strategy'],
            businessContext: {
              industry: 'Technology',
              companySize: '51-200',
              department: 'IT',
              role: 'Decision Maker',
              decisionTimeframe: '1-3 months',
              budget: '$50k-$100k'
            }
          }),
          genderStereotypes: JSON.stringify([]),
          productRecommendations: JSON.stringify([
            {
              category: 'Enterprise Software',
              products: [
                {
                  name: 'PersonalysisPro Enterprise Analytics Suite',
                  confidence: 92,
                  description: 'Advanced analytics platform with customizable reporting and AI-driven insights',
                  attributes: ['scalable', 'integration-friendly', 'ai-powered', 'secure']
                }
              ],
              reason: 'Based on your technical complexity tolerance and analytical thinking profile'
            }
          ]),
          marketSegment: 'Early Adopter',
          completed: true,
          startTime: new Date(Date.now() - 1000 * 60 * 15), // 15 minutes ago
          completeTime: new Date(),
          satisfactionScore: 9
        };
        
        const createdResponse = await storage.createSurveyResponse(sampleResponse);
        
        return res.status(201).json({
          success: true,
          message: 'Test survey response created successfully',
          data: createdResponse
        });
      } catch (error) {
        console.error('Error creating test survey response:', error);
        return res.status(500).json({
          success: false,
          message: 'Failed to create test survey response',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }));
          {
            title: "Product Market Fit Analysis",
            description: "Evaluate how well your products align with customer needs and market demands",
            companyId: demoCompany.id,
            createdById: 888, // Demo user ID
            surveyType: "market research",
            isPublic: true,
            isActive: true,
            accessCode: null,
            customLogo: null,
            estimatedTime: 10,
            customTheme: JSON.stringify({
              primaryColor: "#e76f51",
              secondaryColor: "#f4a261",
              backgroundColor: "#ffffff",
              textColor: "#333333"
            }),
            collectDemographics: true
          }
        ];
        
        // Create all demo surveys
        const createdSurveys = [];
        for (const survey of demoSurveys) {
          const createdSurvey = await storage.createSurvey(survey);
          createdSurveys.push(createdSurvey);
        }
        
        // Generate industry-specific survey responses with realistic data
        const businessIndustries = [
          "Technology", "Finance", "Healthcare", "Education", 
          "Retail", "Manufacturing", "Consulting", "Marketing"
        ];
        
        const companySpecificContexts = {
          Technology: {
            decisionTimeframe: ["1-3 months", "3-6 months"],
            budget: ["$50,000-$100,000", "$100,000-$250,000"],
            stakeholders: ["CTO", "IT Director", "DevOps Lead"],
            competitors: ["TechCorp Solutions", "InnovateX", "CloudWave Systems"],
            painPoints: ["Integration complexity", "Legacy system compatibility", "Security concerns"]
          },
          Finance: {
            decisionTimeframe: ["2-4 months", "4-8 months"],
            budget: ["$100,000-$500,000", "$500,000+"],
            stakeholders: ["CFO", "Financial Controller", "Risk Manager"],
            competitors: ["AlphaFinance", "Secure Banking Solutions", "Financial Intelligence Group"],
            painPoints: ["Compliance requirements", "Data security", "System reliability"]
          },
          Healthcare: {
            decisionTimeframe: ["3-6 months", "6-12 months"],
            budget: ["$75,000-$200,000", "$200,000-$500,000"],
            stakeholders: ["Medical Director", "IT Health Systems Manager", "Chief of Medicine"],
            competitors: ["MediTech Solutions", "HealthSystems Pro", "CareWave Analytics"],
            painPoints: ["Patient data privacy", "Integration with EHR systems", "Regulatory compliance"]
          }
        };
        
        // Generate 150 realistic survey responses across all surveys
        const createdResponses = [];
        const responseCount = 150;
        
        for (let i = 0; i < responseCount; i++) {
          // Round-robin between surveys
          const surveyIndex = i % createdSurveys.length;
          const survey = createdSurveys[surveyIndex];
          
          // Select random industry (weighted toward technology and finance)
          const industryWeight = Math.random();
          let industry;
          if (industryWeight < 0.4) {
            industry = "Technology";
          } else if (industryWeight < 0.7) {
            industry = "Finance";
          } else if (industryWeight < 0.9) {
            industry = "Healthcare";
          } else {
            industry = businessIndustries[Math.floor(Math.random() * businessIndustries.length)];
          }
          
          // Select company size with realistic distribution
          const companySizeWeight = Math.random();
          let companySize;
          if (companySizeWeight < 0.2) {
            companySize = "1-50";
          } else if (companySizeWeight < 0.5) {
            companySize = "51-200";
          } else if (companySizeWeight < 0.8) {
            companySize = "201-1000";
          } else {
            companySize = "1000+";
          }
          
          // Determine decision timeframe based on industry
          const industryContext = companySpecificContexts[industry as keyof typeof companySpecificContexts] || 
            companySpecificContexts.Technology;
          
          const decisionTimeframe = industryContext.decisionTimeframe[
            Math.floor(Math.random() * industryContext.decisionTimeframe.length)
          ];
          
          const budget = industryContext.budget[
            Math.floor(Math.random() * industryContext.budget.length)
          ];
          
          // Create demographics data with business context
          const demographics: Demographics = {
            age: 25 + Math.floor(Math.random() * 35), // Age range 25-60
            gender: Math.random() > 0.6 ? "Male" : Math.random() > 0.3 ? "Female" : "Prefer not to say",
            location: ["New York", "San Francisco", "Chicago", "Austin", "Boston", "Seattle", "London", "Toronto", "Singapore"][Math.floor(Math.random() * 9)],
            education: ["Bachelor's", "Master's", "MBA", "PhD"][Math.floor(Math.random() * 4)],
            income: ["$75k-$100k", "$100k-$150k", "$150k-$200k", "$200k+"][Math.floor(Math.random() * 4)],
            occupation: ["Executive", "Manager", "Director", "Specialist", "Consultant", "Analyst"][Math.floor(Math.random() * 6)],
            interests: [
              ["Technology", "Innovation", "Digital Transformation"][Math.floor(Math.random() * 3)],
              ["Business Strategy", "Leadership", "Market Trends"][Math.floor(Math.random() * 3)],
            ],
            // No need to add business context in demographics object as we'll be enhancing it separately
            // We'll add business context data to the response in other fields
          };
          
          // Generate personalized traits based on industry and survey type
          const traitsCount = 8 + Math.floor(Math.random() * 5); // 8-12 traits
          const traits = [];
          
          // Core traits that are always included
          const coreTrait1 = {
            name: "Analytical Thinking",
            score: industry === "Technology" || industry === "Finance" ? 
              70 + Math.floor(Math.random() * 30) : // Higher for tech/finance
              40 + Math.floor(Math.random() * 40),  // More varied for others
            category: "cognitive"
          };
          
          const coreTrait2 = {
            name: "Risk Tolerance",
            score: industry === "Finance" ? 
              40 + Math.floor(Math.random() * 30) : // Lower for finance (more risk-averse)
              50 + Math.floor(Math.random() * 50),  // More varied for others
            category: "decision-making"
          };
          
          const coreTrait3 = {
            name: "Innovation Adoption",
            score: industry === "Technology" ? 
              60 + Math.floor(Math.random() * 40) : // Higher for tech
              40 + Math.floor(Math.random() * 60),  // More varied for others
            category: "professional"
          };
          
          traits.push(coreTrait1, coreTrait2, coreTrait3);
          
          // Industry-specific traits
          if (industry === "Technology") {
            traits.push(
              {
                name: "Technical Complexity Tolerance",
                score: 65 + Math.floor(Math.random() * 35),
                category: "professional"
              },
              {
                name: "Rapid Adaptation",
                score: 70 + Math.floor(Math.random() * 30),
                category: "behavioral"
              }
            );
          } else if (industry === "Finance") {
            traits.push(
              {
                name: "Detail Orientation",
                score: 75 + Math.floor(Math.random() * 25),
                category: "professional"
              },
              {
                name: "Regulatory Compliance Focus",
                score: 80 + Math.floor(Math.random() * 20),
                category: "behavioral"
              }
            );
          } else if (industry === "Healthcare") {
            traits.push(
              {
                name: "Empathy",
                score: 70 + Math.floor(Math.random() * 30),
                category: "interpersonal"
              },
              {
                name: "Precision",
                score: 75 + Math.floor(Math.random() * 25),
                category: "professional"
              }
            );
          }
          
          // Additional general traits to fill up to the desired count
          const generalTraits = [
            {
              name: "Decision Confidence",
              score: 40 + Math.floor(Math.random() * 60),
              category: "decision-making"
            },
            {
              name: "Collaborative Leadership",
              score: 45 + Math.floor(Math.random() * 55),
              category: "interpersonal"
            },
            {
              name: "Strategic Vision",
              score: 50 + Math.floor(Math.random() * 50),
              category: "professional"
            },
            {
              name: "Communication Style",
              score: 40 + Math.floor(Math.random() * 60),
              category: "interpersonal"
            },
            {
              name: "Value Consciousness",
              score: 55 + Math.floor(Math.random() * 45),
              category: "financial"
            },
            {
              name: "Budget Sensitivity",
              score: 60 + Math.floor(Math.random() * 40),
              category: "financial"
            },
            {
              name: "Timeline Flexibility",
              score: 35 + Math.floor(Math.random() * 65),
              category: "operational"
            }
          ];
          
          // Add remaining traits to reach the desired count
          while (traits.length < traitsCount) {
            const randomTrait = generalTraits[Math.floor(Math.random() * generalTraits.length)];
            // Check if trait is already added
            if (!traits.some(t => t.name === randomTrait.name)) {
              traits.push({...randomTrait});
            }
          }
          
          // Generate product recommendations based on traits and industry
          const productRecommendations = [];
          
          if (industry === "Technology") {
            productRecommendations.push({
              category: "Enterprise Software",
              products: [
                {
                  name: "PersonalysisPro Enterprise Analytics Suite",
                  confidence: 85 + Math.floor(Math.random() * 15),
                  description: "Advanced analytics platform with customizable reporting and AI-driven insights",
                  attributes: ["scalable", "integration-friendly", "ai-powered", "secure"]
                },
                {
                  name: "PersonalysisPro Developer API",
                  confidence: 75 + Math.floor(Math.random() * 20),
                  description: "Robust API access for custom implementations and system integrations",
                  attributes: ["flexible", "documented", "developer-friendly"]
                }
              ],
              reason: "Based on your technical complexity tolerance and analytical thinking profile"
            });
          } else if (industry === "Finance") {
            productRecommendations.push({
              category: "Financial Intelligence Solutions",
              products: [
                {
                  name: "PersonalysisPro Compliance Analytics",
                  confidence: 90 + Math.floor(Math.random() * 10),
                  description: "Regulatory-focused analytics solution with audit-ready reporting",
                  attributes: ["compliant", "secure", "auditable", "comprehensive"]
                },
                {
                  name: "PersonalysisPro Risk Assessment Framework",
                  confidence: 80 + Math.floor(Math.random() * 15),
                  description: "Integrated risk profiling and assessment platform",
                  attributes: ["risk-focused", "data-driven", "predictive"]
                }
              ],
              reason: "Aligned with your regulatory compliance focus and detail orientation"
            });
          } else if (industry === "Healthcare") {
            productRecommendations.push({
              category: "Healthcare Analytics",
              products: [
                {
                  name: "PersonalysisPro Patient Insights Platform",
                  confidence: 85 + Math.floor(Math.random() * 15),
                  description: "HIPAA-compliant patient experience and outcome analytics",
                  attributes: ["patient-centered", "HIPAA-compliant", "outcome-focused"]
                },
                {
                  name: "PersonalysisPro Care Provider Dashboard",
                  confidence: 80 + Math.floor(Math.random() * 15),
                  description: "Interactive analytics dashboard for healthcare professionals",
                  attributes: ["intuitive", "real-time", "integrative"]
                }
              ],
              reason: "Designed for your empathetic approach and precision requirements"
            });
          }
          
          // Add a second, more general recommendation category
          productRecommendations.push({
            category: "Business Intelligence",
            products: [
              {
                name: "PersonalysisPro Executive Dashboard",
                confidence: 75 + Math.floor(Math.random() * 20),
                description: "Custom executive reporting with key business insights",
                attributes: ["executive-focused", "strategic", "comprehensive"]
              },
              {
                name: "PersonalysisPro Team Analytics",
                confidence: 70 + Math.floor(Math.random() * 25),
                description: "Team performance and collaboration analytics platform",
                attributes: ["team-oriented", "performance-focused", "actionable"]
              }
            ],
            reason: "Matches your strategic vision and decision-making profile"
          });
          
          // Create the survey response
          const demoResponse = {
            surveyId: survey.id,
            companyId: demoCompany.id,
            respondentId: `business-${i + 1}`,
            respondentEmail: `respondent${i + 1}@${industry.toLowerCase().replace(/\s+/g, '')}.example.com`,
            responses: generateResponses(15), // Generate 15 question responses
            traits: traits,
            demographics: demographics,
            genderStereotypes: [],
            productRecommendations: productRecommendations,
            marketSegment: determineMarketSegment(traits),
            completed: true,
            startTime: new Date(Date.now() - Math.floor(Math.random() * 30) * 24 * 60 * 60 * 1000), // Random date within last 30 days
            completeTime: new Date(Date.now() - Math.floor(Math.random() * 29) * 24 * 60 * 60 * 1000), // Slightly after start time
            satisfactionScore: 7 + Math.floor(Math.random() * 4) // 7-10 satisfaction score
          };
          
          const createdResponse = await storage.createSurveyResponse(demoResponse);
          createdResponses.push(createdResponse);
        }
        
        return res.status(200).json({
          success: true,
          message: `Enhanced demo account with ${createdSurveys.length} surveys and ${createdResponses.length} realistic responses`,
          data: {
            surveys: createdSurveys.map(s => ({ id: s.id, title: s.title })),
            responseCount: createdResponses.length
          }
        });
      } catch (error) {
        console.error('Error enhancing demo account:', error);
        return res.status(500).json({
          success: false,
          message: 'Failed to enhance demo account',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }));
    
    app.get('/api/test/create-survey-response', asyncHandler(async (req: Request, res: Response) => {
      try {
        // Get the test company
        const companies = await storage.getCompanies();
        console.log('Companies found:', companies); // Debug all companies
        
        const testCompany = companies.find(company => company.name === 'Test Business Context Company');
        console.log('Test company found:', testCompany); // Debug test company
        
        if (!testCompany) {
          return res.status(404).json({
            success: false,
            message: 'Test company not found. Please create it first with /api/test/create-company'
          });
        }
        
        // Create a test survey first
        const testSurvey = await storage.createSurvey({
          title: 'Test Business Context Survey',
          description: 'A survey with business context data for testing',
          companyId: testCompany.id,
          createdById: 1, // Admin user ID
          surveyType: 'personality',
          isPublic: true,
          isActive: true,
          accessCode: null,
          customLogo: null
        });
        
        // Create a sample survey response with business context data
        const testResponse = await storage.createSurveyResponse({
          surveyId: testSurvey.id,
          companyId: testCompany.id,
          respondentId: 'test-respondent-123',
          respondentEmail: 'respondent@test.com',
          responses: JSON.stringify([
            { questionId: 1, answer: 'Technology' },
            { questionId: 2, answer: '100-500' },
            { questionId: 3, answer: 'C-Suite' },
            { questionId: 4, answer: '3-6 months' }
          ]),
          traits: JSON.stringify([
            { trait: 'Openness', score: 85 },
            { trait: 'Conscientiousness', score: 75 },
            { trait: 'Extraversion', score: 65 },
            { trait: 'Agreeableness', score: 80 },
            { trait: 'Neuroticism', score: 30 }
          ]),
          demographics: JSON.stringify({
            age: '35-44',
            gender: 'Female',
            education: 'Masters',
            income: '$100,000-$150,000',
            location: 'United States',
            businessContext: {
              industry: 'Technology',
              companySize: '100-500',
              role: 'C-Suite',
              decisionTimeframe: '3-6 months',
              budget: '$50,000-$100,000',
              pain_points: ['Integration complexity', 'Scalability']
            }
          }),
          completed: true
        });
        
        return res.status(201).json({
          success: true,
          message: 'Test survey and response with business context created successfully',
          survey: testSurvey,
          response: testResponse
        });
      } catch (error) {
        console.error('Error creating test survey response:', error);
        return res.status(500).json({
          success: false,
          message: 'Failed to create test survey response',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }));
  }

  return httpServer;
}