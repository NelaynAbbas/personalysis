  async getRevenueForecasts(companyId: number): Promise<any> {
    console.log(`Fetching revenue forecasts for company ID: ${companyId}`);
    
    try {
      // Get business context for this company
      const businessContexts = await db.query.businessContexts.findMany({
        where: (businessContexts, { eq }) => eq(businessContexts.companyId, companyId)
      });
      
      // Get customer segments for this company
      const segments = await this.getCustomerSegments(companyId);
      
      // Get pricing strategies
      const pricingStrategies = await this.getPricingStrategies(companyId);
      
      // Extract business information from context
      let industry = 'Technology';
      let productName = 'Personality Assessment';
      let targetMarket = 'Enterprise';
      let marketSize = 5000;
      let competitivePosition = 'growing';
      
      if (businessContexts.length > 0) {
        const context = businessContexts[0];
        industry = context.industry || industry;
        productName = context.productName || productName;
        targetMarket = context.targetMarket || targetMarket;
        
        // Extract market size if available
        if (context.marketSize && typeof context.marketSize === 'number') {
          marketSize = context.marketSize;
        } else if (context.marketSize && typeof context.marketSize === 'string') {
          try {
            marketSize = parseInt(context.marketSize, 10) || 5000;
          } catch (e) {
            marketSize = 5000;
          }
        }
        
        // Extract competitive position if available
        if (context.competitivePosition && typeof context.competitivePosition === 'string') {
          competitivePosition = context.competitivePosition.toLowerCase();
        }
      }
      
      // Determine growth trajectory based on industry and competitive position
      let baseGrowthRate = 0.15; // 15% monthly growth
      
      // Adjust for industry growth rates
      if (industry === 'Technology') {
        baseGrowthRate = 0.18;
      } else if (industry === 'Healthcare') {
        baseGrowthRate = 0.12;
      } else if (industry === 'Financial Services') {
        baseGrowthRate = 0.10;
      } else if (industry === 'Manufacturing') {
        baseGrowthRate = 0.08;
      } else if (industry === 'Retail') {
        baseGrowthRate = 0.14;
      }
      
      // Adjust for competitive position
      if (competitivePosition.includes('leader') || competitivePosition.includes('dominant')) {
        baseGrowthRate *= 1.3;
      } else if (competitivePosition.includes('challenger') || competitivePosition.includes('growing')) {
        baseGrowthRate *= 1.1;
      } else if (competitivePosition.includes('niche') || competitivePosition.includes('specialty')) {
        baseGrowthRate *= 0.9;
      } else if (competitivePosition.includes('new') || competitivePosition.includes('startup')) {
        baseGrowthRate *= 1.5;
      }
      
      // Calculate average price from pricing strategies
      let averagePrice = 200; // Default price
      
      if (pricingStrategies.length > 0) {
        const strategy = pricingStrategies[0];
        if (strategy.tiers && Array.isArray(strategy.tiers) && strategy.tiers.length > 0) {
          // Calculate average of all tier prices
          const tierPrices = strategy.tiers.map(tier => tier.price);
          averagePrice = tierPrices.reduce((sum, price) => sum + price, 0) / tierPrices.length;
        }
      }
      
      // Calculate costs based on industry benchmarks
      const acquisitionCost = Math.round(averagePrice * 0.4); // 40% of the price
      const retentionCost = Math.round(averagePrice * 0.15); // 15% of the price
      const overheadCost = Math.round(20000 + (marketSize * 0.5)); // Base + scale with market
      
      // Determine forecast scenario based on company ID
      const isConservative = (companyId % 2 === 0);
      
      // Apply scenario adjustment to growth rate
      const growthRate = isConservative ? 
                      baseGrowthRate * 0.8 : // Conservative
                      baseGrowthRate * 1.2;  // Aggressive
      
      // Generate 24 months of forecasts
      const monthlyAcquisition = [];
      const cumulativeAcquisition = [];
      const monthlyRevenue = [];
      const cumulativeRevenue = [];
      
      // Start with a reasonable initial customer count
      let initialCustomers = Math.round(marketSize * 0.01); // Start with 1% of market
      initialCustomers = Math.max(20, Math.min(500, initialCustomers)); // Between 20 and 500
      
      // First month acquisition is the initial customers
      monthlyAcquisition.push(initialCustomers);
      cumulativeAcquisition.push(initialCustomers);
      
      // First month revenue
      const firstMonthRevenue = Math.round(initialCustomers * averagePrice);
      monthlyRevenue.push(firstMonthRevenue);
      cumulativeRevenue.push(firstMonthRevenue);
      
      // Generate remaining months
      for (let i = 1; i < 24; i++) {
        // Apply growth rate, but taper off in later months (s-curve)
        const growthTaper = 1 - (i / 48); // Simple linear tapering
        const growthFactor = 1 + (growthRate * growthTaper);
        
        // Calculate new customers for this month
        let newCustomers = Math.round(monthlyAcquisition[i-1] * growthFactor);
        
        // Apply some randomness for realism
        const randomFactor = 0.9 + (Math.random() * 0.2); // 0.9 to 1.1
        newCustomers = Math.round(newCustomers * randomFactor);
        
        // Add to arrays
        monthlyAcquisition.push(newCustomers);
        cumulativeAcquisition.push(cumulativeAcquisition[i-1] + newCustomers);
        
        // Calculate revenue
        const monthRevenue = Math.round(newCustomers * averagePrice);
        monthlyRevenue.push(monthRevenue);
        cumulativeRevenue.push(cumulativeRevenue[i-1] + monthRevenue);
      }
      
      // Calculate profitability metrics
      // Find break-even point (month where cumulative revenue exceeds costs)
      let breakevenPoint = 24; // Default to not breaking even in forecast period
      const monthlyCost = (acquisitionCost * monthlyAcquisition[0]) + overheadCost;
      let cumulativeCost = monthlyCost;
      
      for (let i = 0; i < 24; i++) {
        // Monthly costs are acquisition costs for new customers + retention + overhead
        const monthCost = (acquisitionCost * monthlyAcquisition[i]) + 
                        (retentionCost * cumulativeAcquisition[i]) + 
                        overheadCost;
        
        cumulativeCost += (i > 0) ? monthCost : 0;
        
        if (cumulativeRevenue[i] >= cumulativeCost && breakevenPoint === 24) {
          breakevenPoint = i + 1; // +1 because months are 1-indexed for users
          break;
        }
      }
      
      // Calculate ROI at the end of 24 months
      const totalCost = cumulativeCost;
      const totalRevenue = cumulativeRevenue[23];
      const roi = totalCost > 0 ? Math.round((totalRevenue / totalCost) * 10) / 10 : 0;
      
      // Calculate margin
      const margin = totalRevenue > 0 ? 
                   Math.round(((totalRevenue - totalCost) / totalRevenue) * 100) : 0;
      
      // Construct the forecast object
      const scenarioId = `s-${companyId}-forecast`;
      const scenarioName = isConservative ? 'Conservative Growth Plan' : 'Aggressive Growth Plan';
      
      const forecast = {
        scenarioId,
        scenarioName,
        timeframe: 24,
        customerAcquisition: {
          monthly: monthlyAcquisition,
          cumulative: cumulativeAcquisition
        },
        revenue: {
          monthly: monthlyRevenue,
          cumulative: cumulativeRevenue
        },
        costs: {
          acquisition: acquisitionCost,
          retention: retentionCost,
          overhead: overheadCost
        },
        profitability: {
          breakevenPoint,
          roi,
          margin
        }
      };
      
      return forecast;
    } catch (error) {
      console.error(`Error fetching revenue forecasts for company ${companyId}:`, error);
      throw error;
    }
